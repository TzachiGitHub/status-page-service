
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model Member
 * 
 */
export type Member = $Result.DefaultSelection<Prisma.$MemberPayload>
/**
 * Model Monitor
 * 
 */
export type Monitor = $Result.DefaultSelection<Prisma.$MonitorPayload>
/**
 * Model MonitorCheck
 * 
 */
export type MonitorCheck = $Result.DefaultSelection<Prisma.$MonitorCheckPayload>
/**
 * Model MonitorAlert
 * 
 */
export type MonitorAlert = $Result.DefaultSelection<Prisma.$MonitorAlertPayload>
/**
 * Model ComponentGroup
 * 
 */
export type ComponentGroup = $Result.DefaultSelection<Prisma.$ComponentGroupPayload>
/**
 * Model Component
 * 
 */
export type Component = $Result.DefaultSelection<Prisma.$ComponentPayload>
/**
 * Model Incident
 * 
 */
export type Incident = $Result.DefaultSelection<Prisma.$IncidentPayload>
/**
 * Model IncidentUpdate
 * 
 */
export type IncidentUpdate = $Result.DefaultSelection<Prisma.$IncidentUpdatePayload>
/**
 * Model IncidentComponent
 * 
 */
export type IncidentComponent = $Result.DefaultSelection<Prisma.$IncidentComponentPayload>
/**
 * Model Subscriber
 * 
 */
export type Subscriber = $Result.DefaultSelection<Prisma.$SubscriberPayload>
/**
 * Model Alert
 * 
 */
export type Alert = $Result.DefaultSelection<Prisma.$AlertPayload>
/**
 * Model NotificationChannel
 * 
 */
export type NotificationChannel = $Result.DefaultSelection<Prisma.$NotificationChannelPayload>
/**
 * Model ApiKey
 * 
 */
export type ApiKey = $Result.DefaultSelection<Prisma.$ApiKeyPayload>
/**
 * Model StatusPageConfig
 * 
 */
export type StatusPageConfig = $Result.DefaultSelection<Prisma.$StatusPageConfigPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const MemberRole: {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  EDITOR: 'EDITOR',
  VIEWER: 'VIEWER'
};

export type MemberRole = (typeof MemberRole)[keyof typeof MemberRole]


export const MonitorType: {
  HTTP: 'HTTP',
  TCP: 'TCP',
  PING: 'PING',
  DNS: 'DNS',
  SSL: 'SSL',
  HEARTBEAT: 'HEARTBEAT'
};

export type MonitorType = (typeof MonitorType)[keyof typeof MonitorType]


export const HttpMethod: {
  GET: 'GET',
  POST: 'POST',
  PUT: 'PUT',
  PATCH: 'PATCH',
  DELETE: 'DELETE',
  HEAD: 'HEAD',
  OPTIONS: 'OPTIONS'
};

export type HttpMethod = (typeof HttpMethod)[keyof typeof HttpMethod]


export const MonitorStatus: {
  UP: 'UP',
  DOWN: 'DOWN',
  DEGRADED: 'DEGRADED',
  UNKNOWN: 'UNKNOWN'
};

export type MonitorStatus = (typeof MonitorStatus)[keyof typeof MonitorStatus]


export const KeywordType: {
  CONTAINS: 'CONTAINS',
  NOT_CONTAINS: 'NOT_CONTAINS'
};

export type KeywordType = (typeof KeywordType)[keyof typeof KeywordType]


export const ComponentStatus: {
  OPERATIONAL: 'OPERATIONAL',
  DEGRADED_PERFORMANCE: 'DEGRADED_PERFORMANCE',
  PARTIAL_OUTAGE: 'PARTIAL_OUTAGE',
  MAJOR_OUTAGE: 'MAJOR_OUTAGE',
  UNDER_MAINTENANCE: 'UNDER_MAINTENANCE'
};

export type ComponentStatus = (typeof ComponentStatus)[keyof typeof ComponentStatus]


export const IncidentStatus: {
  INVESTIGATING: 'INVESTIGATING',
  IDENTIFIED: 'IDENTIFIED',
  MONITORING: 'MONITORING',
  RESOLVED: 'RESOLVED'
};

export type IncidentStatus = (typeof IncidentStatus)[keyof typeof IncidentStatus]


export const IncidentSeverity: {
  MINOR: 'MINOR',
  MAJOR: 'MAJOR',
  CRITICAL: 'CRITICAL'
};

export type IncidentSeverity = (typeof IncidentSeverity)[keyof typeof IncidentSeverity]


export const SubscriberType: {
  EMAIL: 'EMAIL',
  WEBHOOK: 'WEBHOOK',
  SLACK: 'SLACK'
};

export type SubscriberType = (typeof SubscriberType)[keyof typeof SubscriberType]


export const AlertStatus: {
  PENDING: 'PENDING',
  SENT: 'SENT',
  FAILED: 'FAILED'
};

export type AlertStatus = (typeof AlertStatus)[keyof typeof AlertStatus]


export const NotificationChannelType: {
  EMAIL: 'EMAIL',
  SLACK: 'SLACK',
  WEBHOOK: 'WEBHOOK',
  SMS: 'SMS'
};

export type NotificationChannelType = (typeof NotificationChannelType)[keyof typeof NotificationChannelType]

}

export type MemberRole = $Enums.MemberRole

export const MemberRole: typeof $Enums.MemberRole

export type MonitorType = $Enums.MonitorType

export const MonitorType: typeof $Enums.MonitorType

export type HttpMethod = $Enums.HttpMethod

export const HttpMethod: typeof $Enums.HttpMethod

export type MonitorStatus = $Enums.MonitorStatus

export const MonitorStatus: typeof $Enums.MonitorStatus

export type KeywordType = $Enums.KeywordType

export const KeywordType: typeof $Enums.KeywordType

export type ComponentStatus = $Enums.ComponentStatus

export const ComponentStatus: typeof $Enums.ComponentStatus

export type IncidentStatus = $Enums.IncidentStatus

export const IncidentStatus: typeof $Enums.IncidentStatus

export type IncidentSeverity = $Enums.IncidentSeverity

export const IncidentSeverity: typeof $Enums.IncidentSeverity

export type SubscriberType = $Enums.SubscriberType

export const SubscriberType: typeof $Enums.SubscriberType

export type AlertStatus = $Enums.AlertStatus

export const AlertStatus: typeof $Enums.AlertStatus

export type NotificationChannelType = $Enums.NotificationChannelType

export const NotificationChannelType: typeof $Enums.NotificationChannelType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Organizations
 * const organizations = await prisma.organization.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Organizations
   * const organizations = await prisma.organization.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs>;

  /**
   * `prisma.member`: Exposes CRUD operations for the **Member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Members
    * const members = await prisma.member.findMany()
    * ```
    */
  get member(): Prisma.MemberDelegate<ExtArgs>;

  /**
   * `prisma.monitor`: Exposes CRUD operations for the **Monitor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Monitors
    * const monitors = await prisma.monitor.findMany()
    * ```
    */
  get monitor(): Prisma.MonitorDelegate<ExtArgs>;

  /**
   * `prisma.monitorCheck`: Exposes CRUD operations for the **MonitorCheck** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MonitorChecks
    * const monitorChecks = await prisma.monitorCheck.findMany()
    * ```
    */
  get monitorCheck(): Prisma.MonitorCheckDelegate<ExtArgs>;

  /**
   * `prisma.monitorAlert`: Exposes CRUD operations for the **MonitorAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MonitorAlerts
    * const monitorAlerts = await prisma.monitorAlert.findMany()
    * ```
    */
  get monitorAlert(): Prisma.MonitorAlertDelegate<ExtArgs>;

  /**
   * `prisma.componentGroup`: Exposes CRUD operations for the **ComponentGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComponentGroups
    * const componentGroups = await prisma.componentGroup.findMany()
    * ```
    */
  get componentGroup(): Prisma.ComponentGroupDelegate<ExtArgs>;

  /**
   * `prisma.component`: Exposes CRUD operations for the **Component** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Components
    * const components = await prisma.component.findMany()
    * ```
    */
  get component(): Prisma.ComponentDelegate<ExtArgs>;

  /**
   * `prisma.incident`: Exposes CRUD operations for the **Incident** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Incidents
    * const incidents = await prisma.incident.findMany()
    * ```
    */
  get incident(): Prisma.IncidentDelegate<ExtArgs>;

  /**
   * `prisma.incidentUpdate`: Exposes CRUD operations for the **IncidentUpdate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IncidentUpdates
    * const incidentUpdates = await prisma.incidentUpdate.findMany()
    * ```
    */
  get incidentUpdate(): Prisma.IncidentUpdateDelegate<ExtArgs>;

  /**
   * `prisma.incidentComponent`: Exposes CRUD operations for the **IncidentComponent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IncidentComponents
    * const incidentComponents = await prisma.incidentComponent.findMany()
    * ```
    */
  get incidentComponent(): Prisma.IncidentComponentDelegate<ExtArgs>;

  /**
   * `prisma.subscriber`: Exposes CRUD operations for the **Subscriber** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscribers
    * const subscribers = await prisma.subscriber.findMany()
    * ```
    */
  get subscriber(): Prisma.SubscriberDelegate<ExtArgs>;

  /**
   * `prisma.alert`: Exposes CRUD operations for the **Alert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alerts
    * const alerts = await prisma.alert.findMany()
    * ```
    */
  get alert(): Prisma.AlertDelegate<ExtArgs>;

  /**
   * `prisma.notificationChannel`: Exposes CRUD operations for the **NotificationChannel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationChannels
    * const notificationChannels = await prisma.notificationChannel.findMany()
    * ```
    */
  get notificationChannel(): Prisma.NotificationChannelDelegate<ExtArgs>;

  /**
   * `prisma.apiKey`: Exposes CRUD operations for the **ApiKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeys
    * const apiKeys = await prisma.apiKey.findMany()
    * ```
    */
  get apiKey(): Prisma.ApiKeyDelegate<ExtArgs>;

  /**
   * `prisma.statusPageConfig`: Exposes CRUD operations for the **StatusPageConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StatusPageConfigs
    * const statusPageConfigs = await prisma.statusPageConfig.findMany()
    * ```
    */
  get statusPageConfig(): Prisma.StatusPageConfigDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Organization: 'Organization',
    Member: 'Member',
    Monitor: 'Monitor',
    MonitorCheck: 'MonitorCheck',
    MonitorAlert: 'MonitorAlert',
    ComponentGroup: 'ComponentGroup',
    Component: 'Component',
    Incident: 'Incident',
    IncidentUpdate: 'IncidentUpdate',
    IncidentComponent: 'IncidentComponent',
    Subscriber: 'Subscriber',
    Alert: 'Alert',
    NotificationChannel: 'NotificationChannel',
    ApiKey: 'ApiKey',
    StatusPageConfig: 'StatusPageConfig'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "organization" | "member" | "monitor" | "monitorCheck" | "monitorAlert" | "componentGroup" | "component" | "incident" | "incidentUpdate" | "incidentComponent" | "subscriber" | "alert" | "notificationChannel" | "apiKey" | "statusPageConfig"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      Member: {
        payload: Prisma.$MemberPayload<ExtArgs>
        fields: Prisma.MemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findFirst: {
            args: Prisma.MemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findMany: {
            args: Prisma.MemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          create: {
            args: Prisma.MemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          createMany: {
            args: Prisma.MemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          delete: {
            args: Prisma.MemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          update: {
            args: Prisma.MemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          deleteMany: {
            args: Prisma.MemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          aggregate: {
            args: Prisma.MemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMember>
          }
          groupBy: {
            args: Prisma.MemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberCountArgs<ExtArgs>
            result: $Utils.Optional<MemberCountAggregateOutputType> | number
          }
        }
      }
      Monitor: {
        payload: Prisma.$MonitorPayload<ExtArgs>
        fields: Prisma.MonitorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MonitorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MonitorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorPayload>
          }
          findFirst: {
            args: Prisma.MonitorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MonitorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorPayload>
          }
          findMany: {
            args: Prisma.MonitorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorPayload>[]
          }
          create: {
            args: Prisma.MonitorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorPayload>
          }
          createMany: {
            args: Prisma.MonitorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MonitorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorPayload>[]
          }
          delete: {
            args: Prisma.MonitorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorPayload>
          }
          update: {
            args: Prisma.MonitorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorPayload>
          }
          deleteMany: {
            args: Prisma.MonitorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MonitorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MonitorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorPayload>
          }
          aggregate: {
            args: Prisma.MonitorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonitor>
          }
          groupBy: {
            args: Prisma.MonitorGroupByArgs<ExtArgs>
            result: $Utils.Optional<MonitorGroupByOutputType>[]
          }
          count: {
            args: Prisma.MonitorCountArgs<ExtArgs>
            result: $Utils.Optional<MonitorCountAggregateOutputType> | number
          }
        }
      }
      MonitorCheck: {
        payload: Prisma.$MonitorCheckPayload<ExtArgs>
        fields: Prisma.MonitorCheckFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MonitorCheckFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorCheckPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MonitorCheckFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorCheckPayload>
          }
          findFirst: {
            args: Prisma.MonitorCheckFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorCheckPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MonitorCheckFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorCheckPayload>
          }
          findMany: {
            args: Prisma.MonitorCheckFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorCheckPayload>[]
          }
          create: {
            args: Prisma.MonitorCheckCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorCheckPayload>
          }
          createMany: {
            args: Prisma.MonitorCheckCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MonitorCheckCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorCheckPayload>[]
          }
          delete: {
            args: Prisma.MonitorCheckDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorCheckPayload>
          }
          update: {
            args: Prisma.MonitorCheckUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorCheckPayload>
          }
          deleteMany: {
            args: Prisma.MonitorCheckDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MonitorCheckUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MonitorCheckUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorCheckPayload>
          }
          aggregate: {
            args: Prisma.MonitorCheckAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonitorCheck>
          }
          groupBy: {
            args: Prisma.MonitorCheckGroupByArgs<ExtArgs>
            result: $Utils.Optional<MonitorCheckGroupByOutputType>[]
          }
          count: {
            args: Prisma.MonitorCheckCountArgs<ExtArgs>
            result: $Utils.Optional<MonitorCheckCountAggregateOutputType> | number
          }
        }
      }
      MonitorAlert: {
        payload: Prisma.$MonitorAlertPayload<ExtArgs>
        fields: Prisma.MonitorAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MonitorAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MonitorAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorAlertPayload>
          }
          findFirst: {
            args: Prisma.MonitorAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MonitorAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorAlertPayload>
          }
          findMany: {
            args: Prisma.MonitorAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorAlertPayload>[]
          }
          create: {
            args: Prisma.MonitorAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorAlertPayload>
          }
          createMany: {
            args: Prisma.MonitorAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MonitorAlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorAlertPayload>[]
          }
          delete: {
            args: Prisma.MonitorAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorAlertPayload>
          }
          update: {
            args: Prisma.MonitorAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorAlertPayload>
          }
          deleteMany: {
            args: Prisma.MonitorAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MonitorAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MonitorAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorAlertPayload>
          }
          aggregate: {
            args: Prisma.MonitorAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonitorAlert>
          }
          groupBy: {
            args: Prisma.MonitorAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<MonitorAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.MonitorAlertCountArgs<ExtArgs>
            result: $Utils.Optional<MonitorAlertCountAggregateOutputType> | number
          }
        }
      }
      ComponentGroup: {
        payload: Prisma.$ComponentGroupPayload<ExtArgs>
        fields: Prisma.ComponentGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComponentGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComponentGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentGroupPayload>
          }
          findFirst: {
            args: Prisma.ComponentGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComponentGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentGroupPayload>
          }
          findMany: {
            args: Prisma.ComponentGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentGroupPayload>[]
          }
          create: {
            args: Prisma.ComponentGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentGroupPayload>
          }
          createMany: {
            args: Prisma.ComponentGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComponentGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentGroupPayload>[]
          }
          delete: {
            args: Prisma.ComponentGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentGroupPayload>
          }
          update: {
            args: Prisma.ComponentGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentGroupPayload>
          }
          deleteMany: {
            args: Prisma.ComponentGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComponentGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComponentGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentGroupPayload>
          }
          aggregate: {
            args: Prisma.ComponentGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComponentGroup>
          }
          groupBy: {
            args: Prisma.ComponentGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComponentGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComponentGroupCountArgs<ExtArgs>
            result: $Utils.Optional<ComponentGroupCountAggregateOutputType> | number
          }
        }
      }
      Component: {
        payload: Prisma.$ComponentPayload<ExtArgs>
        fields: Prisma.ComponentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComponentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComponentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          findFirst: {
            args: Prisma.ComponentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComponentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          findMany: {
            args: Prisma.ComponentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>[]
          }
          create: {
            args: Prisma.ComponentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          createMany: {
            args: Prisma.ComponentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComponentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>[]
          }
          delete: {
            args: Prisma.ComponentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          update: {
            args: Prisma.ComponentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          deleteMany: {
            args: Prisma.ComponentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComponentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComponentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          aggregate: {
            args: Prisma.ComponentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComponent>
          }
          groupBy: {
            args: Prisma.ComponentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComponentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComponentCountArgs<ExtArgs>
            result: $Utils.Optional<ComponentCountAggregateOutputType> | number
          }
        }
      }
      Incident: {
        payload: Prisma.$IncidentPayload<ExtArgs>
        fields: Prisma.IncidentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncidentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncidentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          findFirst: {
            args: Prisma.IncidentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncidentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          findMany: {
            args: Prisma.IncidentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>[]
          }
          create: {
            args: Prisma.IncidentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          createMany: {
            args: Prisma.IncidentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IncidentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>[]
          }
          delete: {
            args: Prisma.IncidentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          update: {
            args: Prisma.IncidentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          deleteMany: {
            args: Prisma.IncidentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncidentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IncidentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          aggregate: {
            args: Prisma.IncidentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncident>
          }
          groupBy: {
            args: Prisma.IncidentGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncidentGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncidentCountArgs<ExtArgs>
            result: $Utils.Optional<IncidentCountAggregateOutputType> | number
          }
        }
      }
      IncidentUpdate: {
        payload: Prisma.$IncidentUpdatePayload<ExtArgs>
        fields: Prisma.IncidentUpdateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncidentUpdateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentUpdatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncidentUpdateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentUpdatePayload>
          }
          findFirst: {
            args: Prisma.IncidentUpdateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentUpdatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncidentUpdateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentUpdatePayload>
          }
          findMany: {
            args: Prisma.IncidentUpdateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentUpdatePayload>[]
          }
          create: {
            args: Prisma.IncidentUpdateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentUpdatePayload>
          }
          createMany: {
            args: Prisma.IncidentUpdateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IncidentUpdateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentUpdatePayload>[]
          }
          delete: {
            args: Prisma.IncidentUpdateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentUpdatePayload>
          }
          update: {
            args: Prisma.IncidentUpdateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentUpdatePayload>
          }
          deleteMany: {
            args: Prisma.IncidentUpdateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncidentUpdateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IncidentUpdateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentUpdatePayload>
          }
          aggregate: {
            args: Prisma.IncidentUpdateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncidentUpdate>
          }
          groupBy: {
            args: Prisma.IncidentUpdateGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncidentUpdateGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncidentUpdateCountArgs<ExtArgs>
            result: $Utils.Optional<IncidentUpdateCountAggregateOutputType> | number
          }
        }
      }
      IncidentComponent: {
        payload: Prisma.$IncidentComponentPayload<ExtArgs>
        fields: Prisma.IncidentComponentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncidentComponentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentComponentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncidentComponentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentComponentPayload>
          }
          findFirst: {
            args: Prisma.IncidentComponentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentComponentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncidentComponentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentComponentPayload>
          }
          findMany: {
            args: Prisma.IncidentComponentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentComponentPayload>[]
          }
          create: {
            args: Prisma.IncidentComponentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentComponentPayload>
          }
          createMany: {
            args: Prisma.IncidentComponentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IncidentComponentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentComponentPayload>[]
          }
          delete: {
            args: Prisma.IncidentComponentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentComponentPayload>
          }
          update: {
            args: Prisma.IncidentComponentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentComponentPayload>
          }
          deleteMany: {
            args: Prisma.IncidentComponentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncidentComponentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IncidentComponentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentComponentPayload>
          }
          aggregate: {
            args: Prisma.IncidentComponentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncidentComponent>
          }
          groupBy: {
            args: Prisma.IncidentComponentGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncidentComponentGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncidentComponentCountArgs<ExtArgs>
            result: $Utils.Optional<IncidentComponentCountAggregateOutputType> | number
          }
        }
      }
      Subscriber: {
        payload: Prisma.$SubscriberPayload<ExtArgs>
        fields: Prisma.SubscriberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>
          }
          findFirst: {
            args: Prisma.SubscriberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>
          }
          findMany: {
            args: Prisma.SubscriberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>[]
          }
          create: {
            args: Prisma.SubscriberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>
          }
          createMany: {
            args: Prisma.SubscriberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>[]
          }
          delete: {
            args: Prisma.SubscriberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>
          }
          update: {
            args: Prisma.SubscriberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>
          }
          deleteMany: {
            args: Prisma.SubscriberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriberPayload>
          }
          aggregate: {
            args: Prisma.SubscriberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriber>
          }
          groupBy: {
            args: Prisma.SubscriberGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriberGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriberCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriberCountAggregateOutputType> | number
          }
        }
      }
      Alert: {
        payload: Prisma.$AlertPayload<ExtArgs>
        fields: Prisma.AlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findFirst: {
            args: Prisma.AlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findMany: {
            args: Prisma.AlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          create: {
            args: Prisma.AlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          createMany: {
            args: Prisma.AlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          delete: {
            args: Prisma.AlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          update: {
            args: Prisma.AlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          deleteMany: {
            args: Prisma.AlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          aggregate: {
            args: Prisma.AlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlert>
          }
          groupBy: {
            args: Prisma.AlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertCountArgs<ExtArgs>
            result: $Utils.Optional<AlertCountAggregateOutputType> | number
          }
        }
      }
      NotificationChannel: {
        payload: Prisma.$NotificationChannelPayload<ExtArgs>
        fields: Prisma.NotificationChannelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationChannelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationChannelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationChannelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationChannelPayload>
          }
          findFirst: {
            args: Prisma.NotificationChannelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationChannelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationChannelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationChannelPayload>
          }
          findMany: {
            args: Prisma.NotificationChannelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationChannelPayload>[]
          }
          create: {
            args: Prisma.NotificationChannelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationChannelPayload>
          }
          createMany: {
            args: Prisma.NotificationChannelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationChannelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationChannelPayload>[]
          }
          delete: {
            args: Prisma.NotificationChannelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationChannelPayload>
          }
          update: {
            args: Prisma.NotificationChannelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationChannelPayload>
          }
          deleteMany: {
            args: Prisma.NotificationChannelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationChannelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationChannelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationChannelPayload>
          }
          aggregate: {
            args: Prisma.NotificationChannelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationChannel>
          }
          groupBy: {
            args: Prisma.NotificationChannelGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationChannelGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationChannelCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationChannelCountAggregateOutputType> | number
          }
        }
      }
      ApiKey: {
        payload: Prisma.$ApiKeyPayload<ExtArgs>
        fields: Prisma.ApiKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findFirst: {
            args: Prisma.ApiKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findMany: {
            args: Prisma.ApiKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          create: {
            args: Prisma.ApiKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          createMany: {
            args: Prisma.ApiKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          delete: {
            args: Prisma.ApiKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          update: {
            args: Prisma.ApiKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          deleteMany: {
            args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApiKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          aggregate: {
            args: Prisma.ApiKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiKey>
          }
          groupBy: {
            args: Prisma.ApiKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeyCountArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyCountAggregateOutputType> | number
          }
        }
      }
      StatusPageConfig: {
        payload: Prisma.$StatusPageConfigPayload<ExtArgs>
        fields: Prisma.StatusPageConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StatusPageConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusPageConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StatusPageConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusPageConfigPayload>
          }
          findFirst: {
            args: Prisma.StatusPageConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusPageConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StatusPageConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusPageConfigPayload>
          }
          findMany: {
            args: Prisma.StatusPageConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusPageConfigPayload>[]
          }
          create: {
            args: Prisma.StatusPageConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusPageConfigPayload>
          }
          createMany: {
            args: Prisma.StatusPageConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StatusPageConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusPageConfigPayload>[]
          }
          delete: {
            args: Prisma.StatusPageConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusPageConfigPayload>
          }
          update: {
            args: Prisma.StatusPageConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusPageConfigPayload>
          }
          deleteMany: {
            args: Prisma.StatusPageConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StatusPageConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StatusPageConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusPageConfigPayload>
          }
          aggregate: {
            args: Prisma.StatusPageConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStatusPageConfig>
          }
          groupBy: {
            args: Prisma.StatusPageConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<StatusPageConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.StatusPageConfigCountArgs<ExtArgs>
            result: $Utils.Optional<StatusPageConfigCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    members: number
    monitors: number
    components: number
    componentGroups: number
    incidents: number
    subscribers: number
    notificationChannels: number
    apiKeys: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | OrganizationCountOutputTypeCountMembersArgs
    monitors?: boolean | OrganizationCountOutputTypeCountMonitorsArgs
    components?: boolean | OrganizationCountOutputTypeCountComponentsArgs
    componentGroups?: boolean | OrganizationCountOutputTypeCountComponentGroupsArgs
    incidents?: boolean | OrganizationCountOutputTypeCountIncidentsArgs
    subscribers?: boolean | OrganizationCountOutputTypeCountSubscribersArgs
    notificationChannels?: boolean | OrganizationCountOutputTypeCountNotificationChannelsArgs
    apiKeys?: boolean | OrganizationCountOutputTypeCountApiKeysArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountMonitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonitorWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountComponentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComponentWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountComponentGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComponentGroupWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountIncidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountSubscribersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriberWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountNotificationChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationChannelWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
  }


  /**
   * Count Type MonitorCountOutputType
   */

  export type MonitorCountOutputType = {
    checks: number
    alerts: number
  }

  export type MonitorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checks?: boolean | MonitorCountOutputTypeCountChecksArgs
    alerts?: boolean | MonitorCountOutputTypeCountAlertsArgs
  }

  // Custom InputTypes
  /**
   * MonitorCountOutputType without action
   */
  export type MonitorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitorCountOutputType
     */
    select?: MonitorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MonitorCountOutputType without action
   */
  export type MonitorCountOutputTypeCountChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonitorCheckWhereInput
  }

  /**
   * MonitorCountOutputType without action
   */
  export type MonitorCountOutputTypeCountAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonitorAlertWhereInput
  }


  /**
   * Count Type ComponentGroupCountOutputType
   */

  export type ComponentGroupCountOutputType = {
    components: number
  }

  export type ComponentGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    components?: boolean | ComponentGroupCountOutputTypeCountComponentsArgs
  }

  // Custom InputTypes
  /**
   * ComponentGroupCountOutputType without action
   */
  export type ComponentGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentGroupCountOutputType
     */
    select?: ComponentGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ComponentGroupCountOutputType without action
   */
  export type ComponentGroupCountOutputTypeCountComponentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComponentWhereInput
  }


  /**
   * Count Type ComponentCountOutputType
   */

  export type ComponentCountOutputType = {
    monitors: number
    incidents: number
  }

  export type ComponentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monitors?: boolean | ComponentCountOutputTypeCountMonitorsArgs
    incidents?: boolean | ComponentCountOutputTypeCountIncidentsArgs
  }

  // Custom InputTypes
  /**
   * ComponentCountOutputType without action
   */
  export type ComponentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentCountOutputType
     */
    select?: ComponentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ComponentCountOutputType without action
   */
  export type ComponentCountOutputTypeCountMonitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonitorWhereInput
  }

  /**
   * ComponentCountOutputType without action
   */
  export type ComponentCountOutputTypeCountIncidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentComponentWhereInput
  }


  /**
   * Count Type IncidentCountOutputType
   */

  export type IncidentCountOutputType = {
    updates: number
    components: number
  }

  export type IncidentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    updates?: boolean | IncidentCountOutputTypeCountUpdatesArgs
    components?: boolean | IncidentCountOutputTypeCountComponentsArgs
  }

  // Custom InputTypes
  /**
   * IncidentCountOutputType without action
   */
  export type IncidentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentCountOutputType
     */
    select?: IncidentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IncidentCountOutputType without action
   */
  export type IncidentCountOutputTypeCountUpdatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentUpdateWhereInput
  }

  /**
   * IncidentCountOutputType without action
   */
  export type IncidentCountOutputTypeCountComponentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentComponentWhereInput
  }


  /**
   * Count Type SubscriberCountOutputType
   */

  export type SubscriberCountOutputType = {
    alerts: number
  }

  export type SubscriberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alerts?: boolean | SubscriberCountOutputTypeCountAlertsArgs
  }

  // Custom InputTypes
  /**
   * SubscriberCountOutputType without action
   */
  export type SubscriberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriberCountOutputType
     */
    select?: SubscriberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriberCountOutputType without action
   */
  export type SubscriberCountOutputTypeCountAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    slug: string
    createdAt: Date
    updatedAt: Date
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | Organization$membersArgs<ExtArgs>
    monitors?: boolean | Organization$monitorsArgs<ExtArgs>
    components?: boolean | Organization$componentsArgs<ExtArgs>
    componentGroups?: boolean | Organization$componentGroupsArgs<ExtArgs>
    incidents?: boolean | Organization$incidentsArgs<ExtArgs>
    subscribers?: boolean | Organization$subscribersArgs<ExtArgs>
    notificationChannels?: boolean | Organization$notificationChannelsArgs<ExtArgs>
    apiKeys?: boolean | Organization$apiKeysArgs<ExtArgs>
    statusPageConfig?: boolean | Organization$statusPageConfigArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Organization$membersArgs<ExtArgs>
    monitors?: boolean | Organization$monitorsArgs<ExtArgs>
    components?: boolean | Organization$componentsArgs<ExtArgs>
    componentGroups?: boolean | Organization$componentGroupsArgs<ExtArgs>
    incidents?: boolean | Organization$incidentsArgs<ExtArgs>
    subscribers?: boolean | Organization$subscribersArgs<ExtArgs>
    notificationChannels?: boolean | Organization$notificationChannelsArgs<ExtArgs>
    apiKeys?: boolean | Organization$apiKeysArgs<ExtArgs>
    statusPageConfig?: boolean | Organization$statusPageConfigArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      members: Prisma.$MemberPayload<ExtArgs>[]
      monitors: Prisma.$MonitorPayload<ExtArgs>[]
      components: Prisma.$ComponentPayload<ExtArgs>[]
      componentGroups: Prisma.$ComponentGroupPayload<ExtArgs>[]
      incidents: Prisma.$IncidentPayload<ExtArgs>[]
      subscribers: Prisma.$SubscriberPayload<ExtArgs>[]
      notificationChannels: Prisma.$NotificationChannelPayload<ExtArgs>[]
      apiKeys: Prisma.$ApiKeyPayload<ExtArgs>[]
      statusPageConfig: Prisma.$StatusPageConfigPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Organization$membersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany"> | Null>
    monitors<T extends Organization$monitorsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$monitorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonitorPayload<ExtArgs>, T, "findMany"> | Null>
    components<T extends Organization$componentsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$componentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findMany"> | Null>
    componentGroups<T extends Organization$componentGroupsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$componentGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentGroupPayload<ExtArgs>, T, "findMany"> | Null>
    incidents<T extends Organization$incidentsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$incidentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findMany"> | Null>
    subscribers<T extends Organization$subscribersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$subscribersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "findMany"> | Null>
    notificationChannels<T extends Organization$notificationChannelsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$notificationChannelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationChannelPayload<ExtArgs>, T, "findMany"> | Null>
    apiKeys<T extends Organization$apiKeysArgs<ExtArgs> = {}>(args?: Subset<T, Organization$apiKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany"> | Null>
    statusPageConfig<T extends Organization$statusPageConfigArgs<ExtArgs> = {}>(args?: Subset<T, Organization$statusPageConfigArgs<ExtArgs>>): Prisma__StatusPageConfigClient<$Result.GetResult<Prisma.$StatusPageConfigPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */ 
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly slug: FieldRef<"Organization", 'String'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly updatedAt: FieldRef<"Organization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization.members
   */
  export type Organization$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Organization.monitors
   */
  export type Organization$monitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor
     */
    select?: MonitorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorInclude<ExtArgs> | null
    where?: MonitorWhereInput
    orderBy?: MonitorOrderByWithRelationInput | MonitorOrderByWithRelationInput[]
    cursor?: MonitorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MonitorScalarFieldEnum | MonitorScalarFieldEnum[]
  }

  /**
   * Organization.components
   */
  export type Organization$componentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    where?: ComponentWhereInput
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    cursor?: ComponentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }

  /**
   * Organization.componentGroups
   */
  export type Organization$componentGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentGroup
     */
    select?: ComponentGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentGroupInclude<ExtArgs> | null
    where?: ComponentGroupWhereInput
    orderBy?: ComponentGroupOrderByWithRelationInput | ComponentGroupOrderByWithRelationInput[]
    cursor?: ComponentGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComponentGroupScalarFieldEnum | ComponentGroupScalarFieldEnum[]
  }

  /**
   * Organization.incidents
   */
  export type Organization$incidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    where?: IncidentWhereInput
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    cursor?: IncidentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Organization.subscribers
   */
  export type Organization$subscribersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberInclude<ExtArgs> | null
    where?: SubscriberWhereInput
    orderBy?: SubscriberOrderByWithRelationInput | SubscriberOrderByWithRelationInput[]
    cursor?: SubscriberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriberScalarFieldEnum | SubscriberScalarFieldEnum[]
  }

  /**
   * Organization.notificationChannels
   */
  export type Organization$notificationChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationChannel
     */
    select?: NotificationChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationChannelInclude<ExtArgs> | null
    where?: NotificationChannelWhereInput
    orderBy?: NotificationChannelOrderByWithRelationInput | NotificationChannelOrderByWithRelationInput[]
    cursor?: NotificationChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationChannelScalarFieldEnum | NotificationChannelScalarFieldEnum[]
  }

  /**
   * Organization.apiKeys
   */
  export type Organization$apiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    cursor?: ApiKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * Organization.statusPageConfig
   */
  export type Organization$statusPageConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPageConfig
     */
    select?: StatusPageConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusPageConfigInclude<ExtArgs> | null
    where?: StatusPageConfigWhereInput
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model Member
   */

  export type AggregateMember = {
    _count: MemberCountAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  export type MemberMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.MemberRole | null
    orgId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.MemberRole | null
    orgId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    role: number
    orgId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MemberMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    orgId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    orgId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    orgId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Member to aggregate.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Members
    **/
    _count?: true | MemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberMaxAggregateInputType
  }

  export type GetMemberAggregateType<T extends MemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMember[P]>
      : GetScalarType<T[P], AggregateMember[P]>
  }




  export type MemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithAggregationInput | MemberOrderByWithAggregationInput[]
    by: MemberScalarFieldEnum[] | MemberScalarFieldEnum
    having?: MemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCountAggregateInputType | true
    _min?: MemberMinAggregateInputType
    _max?: MemberMaxAggregateInputType
  }

  export type MemberGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string
    role: $Enums.MemberRole
    orgId: string
    createdAt: Date
    updatedAt: Date
    _count: MemberCountAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  type GetMemberGroupByPayload<T extends MemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberGroupByOutputType[P]>
            : GetScalarType<T[P], MemberGroupByOutputType[P]>
        }
      >
    >


  export type MemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    orgId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    orgId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    orgId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type MemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $MemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Member"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string
      role: $Enums.MemberRole
      orgId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["member"]>
    composites: {}
  }

  type MemberGetPayload<S extends boolean | null | undefined | MemberDefaultArgs> = $Result.GetResult<Prisma.$MemberPayload, S>

  type MemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MemberCountAggregateInputType | true
    }

  export interface MemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Member'], meta: { name: 'Member' } }
    /**
     * Find zero or one Member that matches the filter.
     * @param {MemberFindUniqueArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberFindUniqueArgs>(args: SelectSubset<T, MemberFindUniqueArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Member that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MemberFindUniqueOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberFindFirstArgs>(args?: SelectSubset<T, MemberFindFirstArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Member that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Members
     * const members = await prisma.member.findMany()
     * 
     * // Get first 10 Members
     * const members = await prisma.member.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberWithIdOnly = await prisma.member.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberFindManyArgs>(args?: SelectSubset<T, MemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Member.
     * @param {MemberCreateArgs} args - Arguments to create a Member.
     * @example
     * // Create one Member
     * const Member = await prisma.member.create({
     *   data: {
     *     // ... data to create a Member
     *   }
     * })
     * 
     */
    create<T extends MemberCreateArgs>(args: SelectSubset<T, MemberCreateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Members.
     * @param {MemberCreateManyArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberCreateManyArgs>(args?: SelectSubset<T, MemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Members and returns the data saved in the database.
     * @param {MemberCreateManyAndReturnArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Members and only return the `id`
     * const memberWithIdOnly = await prisma.member.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Member.
     * @param {MemberDeleteArgs} args - Arguments to delete one Member.
     * @example
     * // Delete one Member
     * const Member = await prisma.member.delete({
     *   where: {
     *     // ... filter to delete one Member
     *   }
     * })
     * 
     */
    delete<T extends MemberDeleteArgs>(args: SelectSubset<T, MemberDeleteArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Member.
     * @param {MemberUpdateArgs} args - Arguments to update one Member.
     * @example
     * // Update one Member
     * const member = await prisma.member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberUpdateArgs>(args: SelectSubset<T, MemberUpdateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Members.
     * @param {MemberDeleteManyArgs} args - Arguments to filter Members to delete.
     * @example
     * // Delete a few Members
     * const { count } = await prisma.member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberDeleteManyArgs>(args?: SelectSubset<T, MemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberUpdateManyArgs>(args: SelectSubset<T, MemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Member.
     * @param {MemberUpsertArgs} args - Arguments to update or create a Member.
     * @example
     * // Update or create a Member
     * const member = await prisma.member.upsert({
     *   create: {
     *     // ... data to create a Member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Member we want to update
     *   }
     * })
     */
    upsert<T extends MemberUpsertArgs>(args: SelectSubset<T, MemberUpsertArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCountArgs} args - Arguments to filter Members to count.
     * @example
     * // Count the number of Members
     * const count = await prisma.member.count({
     *   where: {
     *     // ... the filter for the Members we want to count
     *   }
     * })
    **/
    count<T extends MemberCountArgs>(
      args?: Subset<T, MemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberAggregateArgs>(args: Subset<T, MemberAggregateArgs>): Prisma.PrismaPromise<GetMemberAggregateType<T>>

    /**
     * Group by Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberGroupByArgs['orderBy'] }
        : { orderBy?: MemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Member model
   */
  readonly fields: MemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Member model
   */ 
  interface MemberFieldRefs {
    readonly id: FieldRef<"Member", 'String'>
    readonly email: FieldRef<"Member", 'String'>
    readonly password: FieldRef<"Member", 'String'>
    readonly name: FieldRef<"Member", 'String'>
    readonly role: FieldRef<"Member", 'MemberRole'>
    readonly orgId: FieldRef<"Member", 'String'>
    readonly createdAt: FieldRef<"Member", 'DateTime'>
    readonly updatedAt: FieldRef<"Member", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Member findUnique
   */
  export type MemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findUniqueOrThrow
   */
  export type MemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findFirst
   */
  export type MemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findFirstOrThrow
   */
  export type MemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findMany
   */
  export type MemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member create
   */
  export type MemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to create a Member.
     */
    data: XOR<MemberCreateInput, MemberUncheckedCreateInput>
  }

  /**
   * Member createMany
   */
  export type MemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Member createManyAndReturn
   */
  export type MemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Member update
   */
  export type MemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to update a Member.
     */
    data: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
    /**
     * Choose, which Member to update.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member updateMany
   */
  export type MemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
  }

  /**
   * Member upsert
   */
  export type MemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The filter to search for the Member to update in case it exists.
     */
    where: MemberWhereUniqueInput
    /**
     * In case the Member found by the `where` argument doesn't exist, create a new Member with this data.
     */
    create: XOR<MemberCreateInput, MemberUncheckedCreateInput>
    /**
     * In case the Member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
  }

  /**
   * Member delete
   */
  export type MemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter which Member to delete.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member deleteMany
   */
  export type MemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Members to delete
     */
    where?: MemberWhereInput
  }

  /**
   * Member without action
   */
  export type MemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
  }


  /**
   * Model Monitor
   */

  export type AggregateMonitor = {
    _count: MonitorCountAggregateOutputType | null
    _avg: MonitorAvgAggregateOutputType | null
    _sum: MonitorSumAggregateOutputType | null
    _min: MonitorMinAggregateOutputType | null
    _max: MonitorMaxAggregateOutputType | null
  }

  export type MonitorAvgAggregateOutputType = {
    interval: number | null
    timeout: number | null
    expectedStatus: number | null
    heartbeatGrace: number | null
    sslExpiryThreshold: number | null
    alertAfter: number | null
    recoveryAfter: number | null
    uptimeDay: number | null
    uptimeWeek: number | null
    uptimeMonth: number | null
    avgResponseTime: number | null
  }

  export type MonitorSumAggregateOutputType = {
    interval: number | null
    timeout: number | null
    expectedStatus: number | null
    heartbeatGrace: number | null
    sslExpiryThreshold: number | null
    alertAfter: number | null
    recoveryAfter: number | null
    uptimeDay: number | null
    uptimeWeek: number | null
    uptimeMonth: number | null
    avgResponseTime: number | null
  }

  export type MonitorMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.MonitorType | null
    url: string | null
    target: string | null
    method: $Enums.HttpMethod | null
    interval: number | null
    timeout: number | null
    status: $Enums.MonitorStatus | null
    currentStatus: string | null
    enabled: boolean | null
    orgId: string | null
    componentId: string | null
    body: string | null
    expectedStatus: number | null
    keyword: string | null
    keywordType: $Enums.KeywordType | null
    heartbeatToken: string | null
    heartbeatGrace: number | null
    sslExpiryThreshold: number | null
    alertAfter: number | null
    recoveryAfter: number | null
    lastCheckedAt: Date | null
    uptimeDay: number | null
    uptimeWeek: number | null
    uptimeMonth: number | null
    avgResponseTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MonitorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.MonitorType | null
    url: string | null
    target: string | null
    method: $Enums.HttpMethod | null
    interval: number | null
    timeout: number | null
    status: $Enums.MonitorStatus | null
    currentStatus: string | null
    enabled: boolean | null
    orgId: string | null
    componentId: string | null
    body: string | null
    expectedStatus: number | null
    keyword: string | null
    keywordType: $Enums.KeywordType | null
    heartbeatToken: string | null
    heartbeatGrace: number | null
    sslExpiryThreshold: number | null
    alertAfter: number | null
    recoveryAfter: number | null
    lastCheckedAt: Date | null
    uptimeDay: number | null
    uptimeWeek: number | null
    uptimeMonth: number | null
    avgResponseTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MonitorCountAggregateOutputType = {
    id: number
    name: number
    type: number
    url: number
    target: number
    method: number
    interval: number
    timeout: number
    status: number
    currentStatus: number
    enabled: number
    orgId: number
    componentId: number
    headers: number
    body: number
    expectedStatus: number
    keyword: number
    keywordType: number
    heartbeatToken: number
    heartbeatGrace: number
    sslExpiryThreshold: number
    alertAfter: number
    recoveryAfter: number
    lastCheckedAt: number
    uptimeDay: number
    uptimeWeek: number
    uptimeMonth: number
    avgResponseTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MonitorAvgAggregateInputType = {
    interval?: true
    timeout?: true
    expectedStatus?: true
    heartbeatGrace?: true
    sslExpiryThreshold?: true
    alertAfter?: true
    recoveryAfter?: true
    uptimeDay?: true
    uptimeWeek?: true
    uptimeMonth?: true
    avgResponseTime?: true
  }

  export type MonitorSumAggregateInputType = {
    interval?: true
    timeout?: true
    expectedStatus?: true
    heartbeatGrace?: true
    sslExpiryThreshold?: true
    alertAfter?: true
    recoveryAfter?: true
    uptimeDay?: true
    uptimeWeek?: true
    uptimeMonth?: true
    avgResponseTime?: true
  }

  export type MonitorMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    url?: true
    target?: true
    method?: true
    interval?: true
    timeout?: true
    status?: true
    currentStatus?: true
    enabled?: true
    orgId?: true
    componentId?: true
    body?: true
    expectedStatus?: true
    keyword?: true
    keywordType?: true
    heartbeatToken?: true
    heartbeatGrace?: true
    sslExpiryThreshold?: true
    alertAfter?: true
    recoveryAfter?: true
    lastCheckedAt?: true
    uptimeDay?: true
    uptimeWeek?: true
    uptimeMonth?: true
    avgResponseTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MonitorMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    url?: true
    target?: true
    method?: true
    interval?: true
    timeout?: true
    status?: true
    currentStatus?: true
    enabled?: true
    orgId?: true
    componentId?: true
    body?: true
    expectedStatus?: true
    keyword?: true
    keywordType?: true
    heartbeatToken?: true
    heartbeatGrace?: true
    sslExpiryThreshold?: true
    alertAfter?: true
    recoveryAfter?: true
    lastCheckedAt?: true
    uptimeDay?: true
    uptimeWeek?: true
    uptimeMonth?: true
    avgResponseTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MonitorCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    url?: true
    target?: true
    method?: true
    interval?: true
    timeout?: true
    status?: true
    currentStatus?: true
    enabled?: true
    orgId?: true
    componentId?: true
    headers?: true
    body?: true
    expectedStatus?: true
    keyword?: true
    keywordType?: true
    heartbeatToken?: true
    heartbeatGrace?: true
    sslExpiryThreshold?: true
    alertAfter?: true
    recoveryAfter?: true
    lastCheckedAt?: true
    uptimeDay?: true
    uptimeWeek?: true
    uptimeMonth?: true
    avgResponseTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MonitorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Monitor to aggregate.
     */
    where?: MonitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Monitors to fetch.
     */
    orderBy?: MonitorOrderByWithRelationInput | MonitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MonitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Monitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Monitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Monitors
    **/
    _count?: true | MonitorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MonitorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MonitorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MonitorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MonitorMaxAggregateInputType
  }

  export type GetMonitorAggregateType<T extends MonitorAggregateArgs> = {
        [P in keyof T & keyof AggregateMonitor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonitor[P]>
      : GetScalarType<T[P], AggregateMonitor[P]>
  }




  export type MonitorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonitorWhereInput
    orderBy?: MonitorOrderByWithAggregationInput | MonitorOrderByWithAggregationInput[]
    by: MonitorScalarFieldEnum[] | MonitorScalarFieldEnum
    having?: MonitorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MonitorCountAggregateInputType | true
    _avg?: MonitorAvgAggregateInputType
    _sum?: MonitorSumAggregateInputType
    _min?: MonitorMinAggregateInputType
    _max?: MonitorMaxAggregateInputType
  }

  export type MonitorGroupByOutputType = {
    id: string
    name: string
    type: $Enums.MonitorType
    url: string | null
    target: string | null
    method: $Enums.HttpMethod
    interval: number
    timeout: number
    status: $Enums.MonitorStatus
    currentStatus: string
    enabled: boolean
    orgId: string
    componentId: string | null
    headers: JsonValue | null
    body: string | null
    expectedStatus: number | null
    keyword: string | null
    keywordType: $Enums.KeywordType | null
    heartbeatToken: string | null
    heartbeatGrace: number | null
    sslExpiryThreshold: number | null
    alertAfter: number
    recoveryAfter: number
    lastCheckedAt: Date | null
    uptimeDay: number | null
    uptimeWeek: number | null
    uptimeMonth: number | null
    avgResponseTime: number | null
    createdAt: Date
    updatedAt: Date
    _count: MonitorCountAggregateOutputType | null
    _avg: MonitorAvgAggregateOutputType | null
    _sum: MonitorSumAggregateOutputType | null
    _min: MonitorMinAggregateOutputType | null
    _max: MonitorMaxAggregateOutputType | null
  }

  type GetMonitorGroupByPayload<T extends MonitorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MonitorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MonitorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MonitorGroupByOutputType[P]>
            : GetScalarType<T[P], MonitorGroupByOutputType[P]>
        }
      >
    >


  export type MonitorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    target?: boolean
    method?: boolean
    interval?: boolean
    timeout?: boolean
    status?: boolean
    currentStatus?: boolean
    enabled?: boolean
    orgId?: boolean
    componentId?: boolean
    headers?: boolean
    body?: boolean
    expectedStatus?: boolean
    keyword?: boolean
    keywordType?: boolean
    heartbeatToken?: boolean
    heartbeatGrace?: boolean
    sslExpiryThreshold?: boolean
    alertAfter?: boolean
    recoveryAfter?: boolean
    lastCheckedAt?: boolean
    uptimeDay?: boolean
    uptimeWeek?: boolean
    uptimeMonth?: boolean
    avgResponseTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    component?: boolean | Monitor$componentArgs<ExtArgs>
    checks?: boolean | Monitor$checksArgs<ExtArgs>
    alerts?: boolean | Monitor$alertsArgs<ExtArgs>
    _count?: boolean | MonitorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monitor"]>

  export type MonitorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    target?: boolean
    method?: boolean
    interval?: boolean
    timeout?: boolean
    status?: boolean
    currentStatus?: boolean
    enabled?: boolean
    orgId?: boolean
    componentId?: boolean
    headers?: boolean
    body?: boolean
    expectedStatus?: boolean
    keyword?: boolean
    keywordType?: boolean
    heartbeatToken?: boolean
    heartbeatGrace?: boolean
    sslExpiryThreshold?: boolean
    alertAfter?: boolean
    recoveryAfter?: boolean
    lastCheckedAt?: boolean
    uptimeDay?: boolean
    uptimeWeek?: boolean
    uptimeMonth?: boolean
    avgResponseTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    component?: boolean | Monitor$componentArgs<ExtArgs>
  }, ExtArgs["result"]["monitor"]>

  export type MonitorSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    target?: boolean
    method?: boolean
    interval?: boolean
    timeout?: boolean
    status?: boolean
    currentStatus?: boolean
    enabled?: boolean
    orgId?: boolean
    componentId?: boolean
    headers?: boolean
    body?: boolean
    expectedStatus?: boolean
    keyword?: boolean
    keywordType?: boolean
    heartbeatToken?: boolean
    heartbeatGrace?: boolean
    sslExpiryThreshold?: boolean
    alertAfter?: boolean
    recoveryAfter?: boolean
    lastCheckedAt?: boolean
    uptimeDay?: boolean
    uptimeWeek?: boolean
    uptimeMonth?: boolean
    avgResponseTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MonitorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    component?: boolean | Monitor$componentArgs<ExtArgs>
    checks?: boolean | Monitor$checksArgs<ExtArgs>
    alerts?: boolean | Monitor$alertsArgs<ExtArgs>
    _count?: boolean | MonitorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MonitorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    component?: boolean | Monitor$componentArgs<ExtArgs>
  }

  export type $MonitorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Monitor"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      component: Prisma.$ComponentPayload<ExtArgs> | null
      checks: Prisma.$MonitorCheckPayload<ExtArgs>[]
      alerts: Prisma.$MonitorAlertPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.MonitorType
      url: string | null
      target: string | null
      method: $Enums.HttpMethod
      interval: number
      timeout: number
      status: $Enums.MonitorStatus
      currentStatus: string
      enabled: boolean
      orgId: string
      componentId: string | null
      headers: Prisma.JsonValue | null
      body: string | null
      expectedStatus: number | null
      keyword: string | null
      keywordType: $Enums.KeywordType | null
      heartbeatToken: string | null
      heartbeatGrace: number | null
      sslExpiryThreshold: number | null
      alertAfter: number
      recoveryAfter: number
      lastCheckedAt: Date | null
      uptimeDay: number | null
      uptimeWeek: number | null
      uptimeMonth: number | null
      avgResponseTime: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["monitor"]>
    composites: {}
  }

  type MonitorGetPayload<S extends boolean | null | undefined | MonitorDefaultArgs> = $Result.GetResult<Prisma.$MonitorPayload, S>

  type MonitorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MonitorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MonitorCountAggregateInputType | true
    }

  export interface MonitorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Monitor'], meta: { name: 'Monitor' } }
    /**
     * Find zero or one Monitor that matches the filter.
     * @param {MonitorFindUniqueArgs} args - Arguments to find a Monitor
     * @example
     * // Get one Monitor
     * const monitor = await prisma.monitor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MonitorFindUniqueArgs>(args: SelectSubset<T, MonitorFindUniqueArgs<ExtArgs>>): Prisma__MonitorClient<$Result.GetResult<Prisma.$MonitorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Monitor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MonitorFindUniqueOrThrowArgs} args - Arguments to find a Monitor
     * @example
     * // Get one Monitor
     * const monitor = await prisma.monitor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MonitorFindUniqueOrThrowArgs>(args: SelectSubset<T, MonitorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MonitorClient<$Result.GetResult<Prisma.$MonitorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Monitor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitorFindFirstArgs} args - Arguments to find a Monitor
     * @example
     * // Get one Monitor
     * const monitor = await prisma.monitor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MonitorFindFirstArgs>(args?: SelectSubset<T, MonitorFindFirstArgs<ExtArgs>>): Prisma__MonitorClient<$Result.GetResult<Prisma.$MonitorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Monitor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitorFindFirstOrThrowArgs} args - Arguments to find a Monitor
     * @example
     * // Get one Monitor
     * const monitor = await prisma.monitor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MonitorFindFirstOrThrowArgs>(args?: SelectSubset<T, MonitorFindFirstOrThrowArgs<ExtArgs>>): Prisma__MonitorClient<$Result.GetResult<Prisma.$MonitorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Monitors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Monitors
     * const monitors = await prisma.monitor.findMany()
     * 
     * // Get first 10 Monitors
     * const monitors = await prisma.monitor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const monitorWithIdOnly = await prisma.monitor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MonitorFindManyArgs>(args?: SelectSubset<T, MonitorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonitorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Monitor.
     * @param {MonitorCreateArgs} args - Arguments to create a Monitor.
     * @example
     * // Create one Monitor
     * const Monitor = await prisma.monitor.create({
     *   data: {
     *     // ... data to create a Monitor
     *   }
     * })
     * 
     */
    create<T extends MonitorCreateArgs>(args: SelectSubset<T, MonitorCreateArgs<ExtArgs>>): Prisma__MonitorClient<$Result.GetResult<Prisma.$MonitorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Monitors.
     * @param {MonitorCreateManyArgs} args - Arguments to create many Monitors.
     * @example
     * // Create many Monitors
     * const monitor = await prisma.monitor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MonitorCreateManyArgs>(args?: SelectSubset<T, MonitorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Monitors and returns the data saved in the database.
     * @param {MonitorCreateManyAndReturnArgs} args - Arguments to create many Monitors.
     * @example
     * // Create many Monitors
     * const monitor = await prisma.monitor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Monitors and only return the `id`
     * const monitorWithIdOnly = await prisma.monitor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MonitorCreateManyAndReturnArgs>(args?: SelectSubset<T, MonitorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonitorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Monitor.
     * @param {MonitorDeleteArgs} args - Arguments to delete one Monitor.
     * @example
     * // Delete one Monitor
     * const Monitor = await prisma.monitor.delete({
     *   where: {
     *     // ... filter to delete one Monitor
     *   }
     * })
     * 
     */
    delete<T extends MonitorDeleteArgs>(args: SelectSubset<T, MonitorDeleteArgs<ExtArgs>>): Prisma__MonitorClient<$Result.GetResult<Prisma.$MonitorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Monitor.
     * @param {MonitorUpdateArgs} args - Arguments to update one Monitor.
     * @example
     * // Update one Monitor
     * const monitor = await prisma.monitor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MonitorUpdateArgs>(args: SelectSubset<T, MonitorUpdateArgs<ExtArgs>>): Prisma__MonitorClient<$Result.GetResult<Prisma.$MonitorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Monitors.
     * @param {MonitorDeleteManyArgs} args - Arguments to filter Monitors to delete.
     * @example
     * // Delete a few Monitors
     * const { count } = await prisma.monitor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MonitorDeleteManyArgs>(args?: SelectSubset<T, MonitorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Monitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Monitors
     * const monitor = await prisma.monitor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MonitorUpdateManyArgs>(args: SelectSubset<T, MonitorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Monitor.
     * @param {MonitorUpsertArgs} args - Arguments to update or create a Monitor.
     * @example
     * // Update or create a Monitor
     * const monitor = await prisma.monitor.upsert({
     *   create: {
     *     // ... data to create a Monitor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Monitor we want to update
     *   }
     * })
     */
    upsert<T extends MonitorUpsertArgs>(args: SelectSubset<T, MonitorUpsertArgs<ExtArgs>>): Prisma__MonitorClient<$Result.GetResult<Prisma.$MonitorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Monitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitorCountArgs} args - Arguments to filter Monitors to count.
     * @example
     * // Count the number of Monitors
     * const count = await prisma.monitor.count({
     *   where: {
     *     // ... the filter for the Monitors we want to count
     *   }
     * })
    **/
    count<T extends MonitorCountArgs>(
      args?: Subset<T, MonitorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MonitorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Monitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MonitorAggregateArgs>(args: Subset<T, MonitorAggregateArgs>): Prisma.PrismaPromise<GetMonitorAggregateType<T>>

    /**
     * Group by Monitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MonitorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MonitorGroupByArgs['orderBy'] }
        : { orderBy?: MonitorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MonitorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonitorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Monitor model
   */
  readonly fields: MonitorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Monitor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MonitorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    component<T extends Monitor$componentArgs<ExtArgs> = {}>(args?: Subset<T, Monitor$componentArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    checks<T extends Monitor$checksArgs<ExtArgs> = {}>(args?: Subset<T, Monitor$checksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonitorCheckPayload<ExtArgs>, T, "findMany"> | Null>
    alerts<T extends Monitor$alertsArgs<ExtArgs> = {}>(args?: Subset<T, Monitor$alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonitorAlertPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Monitor model
   */ 
  interface MonitorFieldRefs {
    readonly id: FieldRef<"Monitor", 'String'>
    readonly name: FieldRef<"Monitor", 'String'>
    readonly type: FieldRef<"Monitor", 'MonitorType'>
    readonly url: FieldRef<"Monitor", 'String'>
    readonly target: FieldRef<"Monitor", 'String'>
    readonly method: FieldRef<"Monitor", 'HttpMethod'>
    readonly interval: FieldRef<"Monitor", 'Int'>
    readonly timeout: FieldRef<"Monitor", 'Int'>
    readonly status: FieldRef<"Monitor", 'MonitorStatus'>
    readonly currentStatus: FieldRef<"Monitor", 'String'>
    readonly enabled: FieldRef<"Monitor", 'Boolean'>
    readonly orgId: FieldRef<"Monitor", 'String'>
    readonly componentId: FieldRef<"Monitor", 'String'>
    readonly headers: FieldRef<"Monitor", 'Json'>
    readonly body: FieldRef<"Monitor", 'String'>
    readonly expectedStatus: FieldRef<"Monitor", 'Int'>
    readonly keyword: FieldRef<"Monitor", 'String'>
    readonly keywordType: FieldRef<"Monitor", 'KeywordType'>
    readonly heartbeatToken: FieldRef<"Monitor", 'String'>
    readonly heartbeatGrace: FieldRef<"Monitor", 'Int'>
    readonly sslExpiryThreshold: FieldRef<"Monitor", 'Int'>
    readonly alertAfter: FieldRef<"Monitor", 'Int'>
    readonly recoveryAfter: FieldRef<"Monitor", 'Int'>
    readonly lastCheckedAt: FieldRef<"Monitor", 'DateTime'>
    readonly uptimeDay: FieldRef<"Monitor", 'Float'>
    readonly uptimeWeek: FieldRef<"Monitor", 'Float'>
    readonly uptimeMonth: FieldRef<"Monitor", 'Float'>
    readonly avgResponseTime: FieldRef<"Monitor", 'Float'>
    readonly createdAt: FieldRef<"Monitor", 'DateTime'>
    readonly updatedAt: FieldRef<"Monitor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Monitor findUnique
   */
  export type MonitorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor
     */
    select?: MonitorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorInclude<ExtArgs> | null
    /**
     * Filter, which Monitor to fetch.
     */
    where: MonitorWhereUniqueInput
  }

  /**
   * Monitor findUniqueOrThrow
   */
  export type MonitorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor
     */
    select?: MonitorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorInclude<ExtArgs> | null
    /**
     * Filter, which Monitor to fetch.
     */
    where: MonitorWhereUniqueInput
  }

  /**
   * Monitor findFirst
   */
  export type MonitorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor
     */
    select?: MonitorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorInclude<ExtArgs> | null
    /**
     * Filter, which Monitor to fetch.
     */
    where?: MonitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Monitors to fetch.
     */
    orderBy?: MonitorOrderByWithRelationInput | MonitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Monitors.
     */
    cursor?: MonitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Monitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Monitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Monitors.
     */
    distinct?: MonitorScalarFieldEnum | MonitorScalarFieldEnum[]
  }

  /**
   * Monitor findFirstOrThrow
   */
  export type MonitorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor
     */
    select?: MonitorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorInclude<ExtArgs> | null
    /**
     * Filter, which Monitor to fetch.
     */
    where?: MonitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Monitors to fetch.
     */
    orderBy?: MonitorOrderByWithRelationInput | MonitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Monitors.
     */
    cursor?: MonitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Monitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Monitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Monitors.
     */
    distinct?: MonitorScalarFieldEnum | MonitorScalarFieldEnum[]
  }

  /**
   * Monitor findMany
   */
  export type MonitorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor
     */
    select?: MonitorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorInclude<ExtArgs> | null
    /**
     * Filter, which Monitors to fetch.
     */
    where?: MonitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Monitors to fetch.
     */
    orderBy?: MonitorOrderByWithRelationInput | MonitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Monitors.
     */
    cursor?: MonitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Monitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Monitors.
     */
    skip?: number
    distinct?: MonitorScalarFieldEnum | MonitorScalarFieldEnum[]
  }

  /**
   * Monitor create
   */
  export type MonitorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor
     */
    select?: MonitorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorInclude<ExtArgs> | null
    /**
     * The data needed to create a Monitor.
     */
    data: XOR<MonitorCreateInput, MonitorUncheckedCreateInput>
  }

  /**
   * Monitor createMany
   */
  export type MonitorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Monitors.
     */
    data: MonitorCreateManyInput | MonitorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Monitor createManyAndReturn
   */
  export type MonitorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor
     */
    select?: MonitorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Monitors.
     */
    data: MonitorCreateManyInput | MonitorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Monitor update
   */
  export type MonitorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor
     */
    select?: MonitorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorInclude<ExtArgs> | null
    /**
     * The data needed to update a Monitor.
     */
    data: XOR<MonitorUpdateInput, MonitorUncheckedUpdateInput>
    /**
     * Choose, which Monitor to update.
     */
    where: MonitorWhereUniqueInput
  }

  /**
   * Monitor updateMany
   */
  export type MonitorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Monitors.
     */
    data: XOR<MonitorUpdateManyMutationInput, MonitorUncheckedUpdateManyInput>
    /**
     * Filter which Monitors to update
     */
    where?: MonitorWhereInput
  }

  /**
   * Monitor upsert
   */
  export type MonitorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor
     */
    select?: MonitorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorInclude<ExtArgs> | null
    /**
     * The filter to search for the Monitor to update in case it exists.
     */
    where: MonitorWhereUniqueInput
    /**
     * In case the Monitor found by the `where` argument doesn't exist, create a new Monitor with this data.
     */
    create: XOR<MonitorCreateInput, MonitorUncheckedCreateInput>
    /**
     * In case the Monitor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MonitorUpdateInput, MonitorUncheckedUpdateInput>
  }

  /**
   * Monitor delete
   */
  export type MonitorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor
     */
    select?: MonitorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorInclude<ExtArgs> | null
    /**
     * Filter which Monitor to delete.
     */
    where: MonitorWhereUniqueInput
  }

  /**
   * Monitor deleteMany
   */
  export type MonitorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Monitors to delete
     */
    where?: MonitorWhereInput
  }

  /**
   * Monitor.component
   */
  export type Monitor$componentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    where?: ComponentWhereInput
  }

  /**
   * Monitor.checks
   */
  export type Monitor$checksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitorCheck
     */
    select?: MonitorCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorCheckInclude<ExtArgs> | null
    where?: MonitorCheckWhereInput
    orderBy?: MonitorCheckOrderByWithRelationInput | MonitorCheckOrderByWithRelationInput[]
    cursor?: MonitorCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MonitorCheckScalarFieldEnum | MonitorCheckScalarFieldEnum[]
  }

  /**
   * Monitor.alerts
   */
  export type Monitor$alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitorAlert
     */
    select?: MonitorAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorAlertInclude<ExtArgs> | null
    where?: MonitorAlertWhereInput
    orderBy?: MonitorAlertOrderByWithRelationInput | MonitorAlertOrderByWithRelationInput[]
    cursor?: MonitorAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MonitorAlertScalarFieldEnum | MonitorAlertScalarFieldEnum[]
  }

  /**
   * Monitor without action
   */
  export type MonitorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor
     */
    select?: MonitorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorInclude<ExtArgs> | null
  }


  /**
   * Model MonitorCheck
   */

  export type AggregateMonitorCheck = {
    _count: MonitorCheckCountAggregateOutputType | null
    _avg: MonitorCheckAvgAggregateOutputType | null
    _sum: MonitorCheckSumAggregateOutputType | null
    _min: MonitorCheckMinAggregateOutputType | null
    _max: MonitorCheckMaxAggregateOutputType | null
  }

  export type MonitorCheckAvgAggregateOutputType = {
    responseTime: number | null
    statusCode: number | null
  }

  export type MonitorCheckSumAggregateOutputType = {
    responseTime: number | null
    statusCode: number | null
  }

  export type MonitorCheckMinAggregateOutputType = {
    id: string | null
    monitorId: string | null
    status: $Enums.MonitorStatus | null
    responseTime: number | null
    statusCode: number | null
    message: string | null
    error: string | null
    region: string | null
    checkedAt: Date | null
  }

  export type MonitorCheckMaxAggregateOutputType = {
    id: string | null
    monitorId: string | null
    status: $Enums.MonitorStatus | null
    responseTime: number | null
    statusCode: number | null
    message: string | null
    error: string | null
    region: string | null
    checkedAt: Date | null
  }

  export type MonitorCheckCountAggregateOutputType = {
    id: number
    monitorId: number
    status: number
    responseTime: number
    statusCode: number
    message: number
    error: number
    region: number
    checkedAt: number
    _all: number
  }


  export type MonitorCheckAvgAggregateInputType = {
    responseTime?: true
    statusCode?: true
  }

  export type MonitorCheckSumAggregateInputType = {
    responseTime?: true
    statusCode?: true
  }

  export type MonitorCheckMinAggregateInputType = {
    id?: true
    monitorId?: true
    status?: true
    responseTime?: true
    statusCode?: true
    message?: true
    error?: true
    region?: true
    checkedAt?: true
  }

  export type MonitorCheckMaxAggregateInputType = {
    id?: true
    monitorId?: true
    status?: true
    responseTime?: true
    statusCode?: true
    message?: true
    error?: true
    region?: true
    checkedAt?: true
  }

  export type MonitorCheckCountAggregateInputType = {
    id?: true
    monitorId?: true
    status?: true
    responseTime?: true
    statusCode?: true
    message?: true
    error?: true
    region?: true
    checkedAt?: true
    _all?: true
  }

  export type MonitorCheckAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MonitorCheck to aggregate.
     */
    where?: MonitorCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonitorChecks to fetch.
     */
    orderBy?: MonitorCheckOrderByWithRelationInput | MonitorCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MonitorCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonitorChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonitorChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MonitorChecks
    **/
    _count?: true | MonitorCheckCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MonitorCheckAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MonitorCheckSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MonitorCheckMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MonitorCheckMaxAggregateInputType
  }

  export type GetMonitorCheckAggregateType<T extends MonitorCheckAggregateArgs> = {
        [P in keyof T & keyof AggregateMonitorCheck]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonitorCheck[P]>
      : GetScalarType<T[P], AggregateMonitorCheck[P]>
  }




  export type MonitorCheckGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonitorCheckWhereInput
    orderBy?: MonitorCheckOrderByWithAggregationInput | MonitorCheckOrderByWithAggregationInput[]
    by: MonitorCheckScalarFieldEnum[] | MonitorCheckScalarFieldEnum
    having?: MonitorCheckScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MonitorCheckCountAggregateInputType | true
    _avg?: MonitorCheckAvgAggregateInputType
    _sum?: MonitorCheckSumAggregateInputType
    _min?: MonitorCheckMinAggregateInputType
    _max?: MonitorCheckMaxAggregateInputType
  }

  export type MonitorCheckGroupByOutputType = {
    id: string
    monitorId: string
    status: $Enums.MonitorStatus
    responseTime: number | null
    statusCode: number | null
    message: string | null
    error: string | null
    region: string | null
    checkedAt: Date
    _count: MonitorCheckCountAggregateOutputType | null
    _avg: MonitorCheckAvgAggregateOutputType | null
    _sum: MonitorCheckSumAggregateOutputType | null
    _min: MonitorCheckMinAggregateOutputType | null
    _max: MonitorCheckMaxAggregateOutputType | null
  }

  type GetMonitorCheckGroupByPayload<T extends MonitorCheckGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MonitorCheckGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MonitorCheckGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MonitorCheckGroupByOutputType[P]>
            : GetScalarType<T[P], MonitorCheckGroupByOutputType[P]>
        }
      >
    >


  export type MonitorCheckSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    monitorId?: boolean
    status?: boolean
    responseTime?: boolean
    statusCode?: boolean
    message?: boolean
    error?: boolean
    region?: boolean
    checkedAt?: boolean
    monitor?: boolean | MonitorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monitorCheck"]>

  export type MonitorCheckSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    monitorId?: boolean
    status?: boolean
    responseTime?: boolean
    statusCode?: boolean
    message?: boolean
    error?: boolean
    region?: boolean
    checkedAt?: boolean
    monitor?: boolean | MonitorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monitorCheck"]>

  export type MonitorCheckSelectScalar = {
    id?: boolean
    monitorId?: boolean
    status?: boolean
    responseTime?: boolean
    statusCode?: boolean
    message?: boolean
    error?: boolean
    region?: boolean
    checkedAt?: boolean
  }

  export type MonitorCheckInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monitor?: boolean | MonitorDefaultArgs<ExtArgs>
  }
  export type MonitorCheckIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monitor?: boolean | MonitorDefaultArgs<ExtArgs>
  }

  export type $MonitorCheckPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MonitorCheck"
    objects: {
      monitor: Prisma.$MonitorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      monitorId: string
      status: $Enums.MonitorStatus
      responseTime: number | null
      statusCode: number | null
      message: string | null
      error: string | null
      region: string | null
      checkedAt: Date
    }, ExtArgs["result"]["monitorCheck"]>
    composites: {}
  }

  type MonitorCheckGetPayload<S extends boolean | null | undefined | MonitorCheckDefaultArgs> = $Result.GetResult<Prisma.$MonitorCheckPayload, S>

  type MonitorCheckCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MonitorCheckFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MonitorCheckCountAggregateInputType | true
    }

  export interface MonitorCheckDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MonitorCheck'], meta: { name: 'MonitorCheck' } }
    /**
     * Find zero or one MonitorCheck that matches the filter.
     * @param {MonitorCheckFindUniqueArgs} args - Arguments to find a MonitorCheck
     * @example
     * // Get one MonitorCheck
     * const monitorCheck = await prisma.monitorCheck.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MonitorCheckFindUniqueArgs>(args: SelectSubset<T, MonitorCheckFindUniqueArgs<ExtArgs>>): Prisma__MonitorCheckClient<$Result.GetResult<Prisma.$MonitorCheckPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MonitorCheck that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MonitorCheckFindUniqueOrThrowArgs} args - Arguments to find a MonitorCheck
     * @example
     * // Get one MonitorCheck
     * const monitorCheck = await prisma.monitorCheck.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MonitorCheckFindUniqueOrThrowArgs>(args: SelectSubset<T, MonitorCheckFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MonitorCheckClient<$Result.GetResult<Prisma.$MonitorCheckPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MonitorCheck that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitorCheckFindFirstArgs} args - Arguments to find a MonitorCheck
     * @example
     * // Get one MonitorCheck
     * const monitorCheck = await prisma.monitorCheck.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MonitorCheckFindFirstArgs>(args?: SelectSubset<T, MonitorCheckFindFirstArgs<ExtArgs>>): Prisma__MonitorCheckClient<$Result.GetResult<Prisma.$MonitorCheckPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MonitorCheck that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitorCheckFindFirstOrThrowArgs} args - Arguments to find a MonitorCheck
     * @example
     * // Get one MonitorCheck
     * const monitorCheck = await prisma.monitorCheck.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MonitorCheckFindFirstOrThrowArgs>(args?: SelectSubset<T, MonitorCheckFindFirstOrThrowArgs<ExtArgs>>): Prisma__MonitorCheckClient<$Result.GetResult<Prisma.$MonitorCheckPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MonitorChecks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitorCheckFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MonitorChecks
     * const monitorChecks = await prisma.monitorCheck.findMany()
     * 
     * // Get first 10 MonitorChecks
     * const monitorChecks = await prisma.monitorCheck.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const monitorCheckWithIdOnly = await prisma.monitorCheck.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MonitorCheckFindManyArgs>(args?: SelectSubset<T, MonitorCheckFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonitorCheckPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MonitorCheck.
     * @param {MonitorCheckCreateArgs} args - Arguments to create a MonitorCheck.
     * @example
     * // Create one MonitorCheck
     * const MonitorCheck = await prisma.monitorCheck.create({
     *   data: {
     *     // ... data to create a MonitorCheck
     *   }
     * })
     * 
     */
    create<T extends MonitorCheckCreateArgs>(args: SelectSubset<T, MonitorCheckCreateArgs<ExtArgs>>): Prisma__MonitorCheckClient<$Result.GetResult<Prisma.$MonitorCheckPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MonitorChecks.
     * @param {MonitorCheckCreateManyArgs} args - Arguments to create many MonitorChecks.
     * @example
     * // Create many MonitorChecks
     * const monitorCheck = await prisma.monitorCheck.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MonitorCheckCreateManyArgs>(args?: SelectSubset<T, MonitorCheckCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MonitorChecks and returns the data saved in the database.
     * @param {MonitorCheckCreateManyAndReturnArgs} args - Arguments to create many MonitorChecks.
     * @example
     * // Create many MonitorChecks
     * const monitorCheck = await prisma.monitorCheck.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MonitorChecks and only return the `id`
     * const monitorCheckWithIdOnly = await prisma.monitorCheck.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MonitorCheckCreateManyAndReturnArgs>(args?: SelectSubset<T, MonitorCheckCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonitorCheckPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MonitorCheck.
     * @param {MonitorCheckDeleteArgs} args - Arguments to delete one MonitorCheck.
     * @example
     * // Delete one MonitorCheck
     * const MonitorCheck = await prisma.monitorCheck.delete({
     *   where: {
     *     // ... filter to delete one MonitorCheck
     *   }
     * })
     * 
     */
    delete<T extends MonitorCheckDeleteArgs>(args: SelectSubset<T, MonitorCheckDeleteArgs<ExtArgs>>): Prisma__MonitorCheckClient<$Result.GetResult<Prisma.$MonitorCheckPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MonitorCheck.
     * @param {MonitorCheckUpdateArgs} args - Arguments to update one MonitorCheck.
     * @example
     * // Update one MonitorCheck
     * const monitorCheck = await prisma.monitorCheck.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MonitorCheckUpdateArgs>(args: SelectSubset<T, MonitorCheckUpdateArgs<ExtArgs>>): Prisma__MonitorCheckClient<$Result.GetResult<Prisma.$MonitorCheckPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MonitorChecks.
     * @param {MonitorCheckDeleteManyArgs} args - Arguments to filter MonitorChecks to delete.
     * @example
     * // Delete a few MonitorChecks
     * const { count } = await prisma.monitorCheck.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MonitorCheckDeleteManyArgs>(args?: SelectSubset<T, MonitorCheckDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MonitorChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitorCheckUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MonitorChecks
     * const monitorCheck = await prisma.monitorCheck.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MonitorCheckUpdateManyArgs>(args: SelectSubset<T, MonitorCheckUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MonitorCheck.
     * @param {MonitorCheckUpsertArgs} args - Arguments to update or create a MonitorCheck.
     * @example
     * // Update or create a MonitorCheck
     * const monitorCheck = await prisma.monitorCheck.upsert({
     *   create: {
     *     // ... data to create a MonitorCheck
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MonitorCheck we want to update
     *   }
     * })
     */
    upsert<T extends MonitorCheckUpsertArgs>(args: SelectSubset<T, MonitorCheckUpsertArgs<ExtArgs>>): Prisma__MonitorCheckClient<$Result.GetResult<Prisma.$MonitorCheckPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MonitorChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitorCheckCountArgs} args - Arguments to filter MonitorChecks to count.
     * @example
     * // Count the number of MonitorChecks
     * const count = await prisma.monitorCheck.count({
     *   where: {
     *     // ... the filter for the MonitorChecks we want to count
     *   }
     * })
    **/
    count<T extends MonitorCheckCountArgs>(
      args?: Subset<T, MonitorCheckCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MonitorCheckCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MonitorCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitorCheckAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MonitorCheckAggregateArgs>(args: Subset<T, MonitorCheckAggregateArgs>): Prisma.PrismaPromise<GetMonitorCheckAggregateType<T>>

    /**
     * Group by MonitorCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitorCheckGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MonitorCheckGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MonitorCheckGroupByArgs['orderBy'] }
        : { orderBy?: MonitorCheckGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MonitorCheckGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonitorCheckGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MonitorCheck model
   */
  readonly fields: MonitorCheckFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MonitorCheck.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MonitorCheckClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    monitor<T extends MonitorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MonitorDefaultArgs<ExtArgs>>): Prisma__MonitorClient<$Result.GetResult<Prisma.$MonitorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MonitorCheck model
   */ 
  interface MonitorCheckFieldRefs {
    readonly id: FieldRef<"MonitorCheck", 'String'>
    readonly monitorId: FieldRef<"MonitorCheck", 'String'>
    readonly status: FieldRef<"MonitorCheck", 'MonitorStatus'>
    readonly responseTime: FieldRef<"MonitorCheck", 'Int'>
    readonly statusCode: FieldRef<"MonitorCheck", 'Int'>
    readonly message: FieldRef<"MonitorCheck", 'String'>
    readonly error: FieldRef<"MonitorCheck", 'String'>
    readonly region: FieldRef<"MonitorCheck", 'String'>
    readonly checkedAt: FieldRef<"MonitorCheck", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MonitorCheck findUnique
   */
  export type MonitorCheckFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitorCheck
     */
    select?: MonitorCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorCheckInclude<ExtArgs> | null
    /**
     * Filter, which MonitorCheck to fetch.
     */
    where: MonitorCheckWhereUniqueInput
  }

  /**
   * MonitorCheck findUniqueOrThrow
   */
  export type MonitorCheckFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitorCheck
     */
    select?: MonitorCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorCheckInclude<ExtArgs> | null
    /**
     * Filter, which MonitorCheck to fetch.
     */
    where: MonitorCheckWhereUniqueInput
  }

  /**
   * MonitorCheck findFirst
   */
  export type MonitorCheckFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitorCheck
     */
    select?: MonitorCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorCheckInclude<ExtArgs> | null
    /**
     * Filter, which MonitorCheck to fetch.
     */
    where?: MonitorCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonitorChecks to fetch.
     */
    orderBy?: MonitorCheckOrderByWithRelationInput | MonitorCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonitorChecks.
     */
    cursor?: MonitorCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonitorChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonitorChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonitorChecks.
     */
    distinct?: MonitorCheckScalarFieldEnum | MonitorCheckScalarFieldEnum[]
  }

  /**
   * MonitorCheck findFirstOrThrow
   */
  export type MonitorCheckFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitorCheck
     */
    select?: MonitorCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorCheckInclude<ExtArgs> | null
    /**
     * Filter, which MonitorCheck to fetch.
     */
    where?: MonitorCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonitorChecks to fetch.
     */
    orderBy?: MonitorCheckOrderByWithRelationInput | MonitorCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonitorChecks.
     */
    cursor?: MonitorCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonitorChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonitorChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonitorChecks.
     */
    distinct?: MonitorCheckScalarFieldEnum | MonitorCheckScalarFieldEnum[]
  }

  /**
   * MonitorCheck findMany
   */
  export type MonitorCheckFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitorCheck
     */
    select?: MonitorCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorCheckInclude<ExtArgs> | null
    /**
     * Filter, which MonitorChecks to fetch.
     */
    where?: MonitorCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonitorChecks to fetch.
     */
    orderBy?: MonitorCheckOrderByWithRelationInput | MonitorCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MonitorChecks.
     */
    cursor?: MonitorCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonitorChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonitorChecks.
     */
    skip?: number
    distinct?: MonitorCheckScalarFieldEnum | MonitorCheckScalarFieldEnum[]
  }

  /**
   * MonitorCheck create
   */
  export type MonitorCheckCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitorCheck
     */
    select?: MonitorCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorCheckInclude<ExtArgs> | null
    /**
     * The data needed to create a MonitorCheck.
     */
    data: XOR<MonitorCheckCreateInput, MonitorCheckUncheckedCreateInput>
  }

  /**
   * MonitorCheck createMany
   */
  export type MonitorCheckCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MonitorChecks.
     */
    data: MonitorCheckCreateManyInput | MonitorCheckCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MonitorCheck createManyAndReturn
   */
  export type MonitorCheckCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitorCheck
     */
    select?: MonitorCheckSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MonitorChecks.
     */
    data: MonitorCheckCreateManyInput | MonitorCheckCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorCheckIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MonitorCheck update
   */
  export type MonitorCheckUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitorCheck
     */
    select?: MonitorCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorCheckInclude<ExtArgs> | null
    /**
     * The data needed to update a MonitorCheck.
     */
    data: XOR<MonitorCheckUpdateInput, MonitorCheckUncheckedUpdateInput>
    /**
     * Choose, which MonitorCheck to update.
     */
    where: MonitorCheckWhereUniqueInput
  }

  /**
   * MonitorCheck updateMany
   */
  export type MonitorCheckUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MonitorChecks.
     */
    data: XOR<MonitorCheckUpdateManyMutationInput, MonitorCheckUncheckedUpdateManyInput>
    /**
     * Filter which MonitorChecks to update
     */
    where?: MonitorCheckWhereInput
  }

  /**
   * MonitorCheck upsert
   */
  export type MonitorCheckUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitorCheck
     */
    select?: MonitorCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorCheckInclude<ExtArgs> | null
    /**
     * The filter to search for the MonitorCheck to update in case it exists.
     */
    where: MonitorCheckWhereUniqueInput
    /**
     * In case the MonitorCheck found by the `where` argument doesn't exist, create a new MonitorCheck with this data.
     */
    create: XOR<MonitorCheckCreateInput, MonitorCheckUncheckedCreateInput>
    /**
     * In case the MonitorCheck was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MonitorCheckUpdateInput, MonitorCheckUncheckedUpdateInput>
  }

  /**
   * MonitorCheck delete
   */
  export type MonitorCheckDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitorCheck
     */
    select?: MonitorCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorCheckInclude<ExtArgs> | null
    /**
     * Filter which MonitorCheck to delete.
     */
    where: MonitorCheckWhereUniqueInput
  }

  /**
   * MonitorCheck deleteMany
   */
  export type MonitorCheckDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MonitorChecks to delete
     */
    where?: MonitorCheckWhereInput
  }

  /**
   * MonitorCheck without action
   */
  export type MonitorCheckDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitorCheck
     */
    select?: MonitorCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorCheckInclude<ExtArgs> | null
  }


  /**
   * Model MonitorAlert
   */

  export type AggregateMonitorAlert = {
    _count: MonitorAlertCountAggregateOutputType | null
    _min: MonitorAlertMinAggregateOutputType | null
    _max: MonitorAlertMaxAggregateOutputType | null
  }

  export type MonitorAlertMinAggregateOutputType = {
    id: string | null
    monitorId: string | null
    type: string | null
    message: string | null
    createdAt: Date | null
  }

  export type MonitorAlertMaxAggregateOutputType = {
    id: string | null
    monitorId: string | null
    type: string | null
    message: string | null
    createdAt: Date | null
  }

  export type MonitorAlertCountAggregateOutputType = {
    id: number
    monitorId: number
    type: number
    message: number
    createdAt: number
    _all: number
  }


  export type MonitorAlertMinAggregateInputType = {
    id?: true
    monitorId?: true
    type?: true
    message?: true
    createdAt?: true
  }

  export type MonitorAlertMaxAggregateInputType = {
    id?: true
    monitorId?: true
    type?: true
    message?: true
    createdAt?: true
  }

  export type MonitorAlertCountAggregateInputType = {
    id?: true
    monitorId?: true
    type?: true
    message?: true
    createdAt?: true
    _all?: true
  }

  export type MonitorAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MonitorAlert to aggregate.
     */
    where?: MonitorAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonitorAlerts to fetch.
     */
    orderBy?: MonitorAlertOrderByWithRelationInput | MonitorAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MonitorAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonitorAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonitorAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MonitorAlerts
    **/
    _count?: true | MonitorAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MonitorAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MonitorAlertMaxAggregateInputType
  }

  export type GetMonitorAlertAggregateType<T extends MonitorAlertAggregateArgs> = {
        [P in keyof T & keyof AggregateMonitorAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonitorAlert[P]>
      : GetScalarType<T[P], AggregateMonitorAlert[P]>
  }




  export type MonitorAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonitorAlertWhereInput
    orderBy?: MonitorAlertOrderByWithAggregationInput | MonitorAlertOrderByWithAggregationInput[]
    by: MonitorAlertScalarFieldEnum[] | MonitorAlertScalarFieldEnum
    having?: MonitorAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MonitorAlertCountAggregateInputType | true
    _min?: MonitorAlertMinAggregateInputType
    _max?: MonitorAlertMaxAggregateInputType
  }

  export type MonitorAlertGroupByOutputType = {
    id: string
    monitorId: string
    type: string
    message: string
    createdAt: Date
    _count: MonitorAlertCountAggregateOutputType | null
    _min: MonitorAlertMinAggregateOutputType | null
    _max: MonitorAlertMaxAggregateOutputType | null
  }

  type GetMonitorAlertGroupByPayload<T extends MonitorAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MonitorAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MonitorAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MonitorAlertGroupByOutputType[P]>
            : GetScalarType<T[P], MonitorAlertGroupByOutputType[P]>
        }
      >
    >


  export type MonitorAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    monitorId?: boolean
    type?: boolean
    message?: boolean
    createdAt?: boolean
    monitor?: boolean | MonitorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monitorAlert"]>

  export type MonitorAlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    monitorId?: boolean
    type?: boolean
    message?: boolean
    createdAt?: boolean
    monitor?: boolean | MonitorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monitorAlert"]>

  export type MonitorAlertSelectScalar = {
    id?: boolean
    monitorId?: boolean
    type?: boolean
    message?: boolean
    createdAt?: boolean
  }

  export type MonitorAlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monitor?: boolean | MonitorDefaultArgs<ExtArgs>
  }
  export type MonitorAlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monitor?: boolean | MonitorDefaultArgs<ExtArgs>
  }

  export type $MonitorAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MonitorAlert"
    objects: {
      monitor: Prisma.$MonitorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      monitorId: string
      type: string
      message: string
      createdAt: Date
    }, ExtArgs["result"]["monitorAlert"]>
    composites: {}
  }

  type MonitorAlertGetPayload<S extends boolean | null | undefined | MonitorAlertDefaultArgs> = $Result.GetResult<Prisma.$MonitorAlertPayload, S>

  type MonitorAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MonitorAlertFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MonitorAlertCountAggregateInputType | true
    }

  export interface MonitorAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MonitorAlert'], meta: { name: 'MonitorAlert' } }
    /**
     * Find zero or one MonitorAlert that matches the filter.
     * @param {MonitorAlertFindUniqueArgs} args - Arguments to find a MonitorAlert
     * @example
     * // Get one MonitorAlert
     * const monitorAlert = await prisma.monitorAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MonitorAlertFindUniqueArgs>(args: SelectSubset<T, MonitorAlertFindUniqueArgs<ExtArgs>>): Prisma__MonitorAlertClient<$Result.GetResult<Prisma.$MonitorAlertPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MonitorAlert that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MonitorAlertFindUniqueOrThrowArgs} args - Arguments to find a MonitorAlert
     * @example
     * // Get one MonitorAlert
     * const monitorAlert = await prisma.monitorAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MonitorAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, MonitorAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MonitorAlertClient<$Result.GetResult<Prisma.$MonitorAlertPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MonitorAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitorAlertFindFirstArgs} args - Arguments to find a MonitorAlert
     * @example
     * // Get one MonitorAlert
     * const monitorAlert = await prisma.monitorAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MonitorAlertFindFirstArgs>(args?: SelectSubset<T, MonitorAlertFindFirstArgs<ExtArgs>>): Prisma__MonitorAlertClient<$Result.GetResult<Prisma.$MonitorAlertPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MonitorAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitorAlertFindFirstOrThrowArgs} args - Arguments to find a MonitorAlert
     * @example
     * // Get one MonitorAlert
     * const monitorAlert = await prisma.monitorAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MonitorAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, MonitorAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__MonitorAlertClient<$Result.GetResult<Prisma.$MonitorAlertPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MonitorAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitorAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MonitorAlerts
     * const monitorAlerts = await prisma.monitorAlert.findMany()
     * 
     * // Get first 10 MonitorAlerts
     * const monitorAlerts = await prisma.monitorAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const monitorAlertWithIdOnly = await prisma.monitorAlert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MonitorAlertFindManyArgs>(args?: SelectSubset<T, MonitorAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonitorAlertPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MonitorAlert.
     * @param {MonitorAlertCreateArgs} args - Arguments to create a MonitorAlert.
     * @example
     * // Create one MonitorAlert
     * const MonitorAlert = await prisma.monitorAlert.create({
     *   data: {
     *     // ... data to create a MonitorAlert
     *   }
     * })
     * 
     */
    create<T extends MonitorAlertCreateArgs>(args: SelectSubset<T, MonitorAlertCreateArgs<ExtArgs>>): Prisma__MonitorAlertClient<$Result.GetResult<Prisma.$MonitorAlertPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MonitorAlerts.
     * @param {MonitorAlertCreateManyArgs} args - Arguments to create many MonitorAlerts.
     * @example
     * // Create many MonitorAlerts
     * const monitorAlert = await prisma.monitorAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MonitorAlertCreateManyArgs>(args?: SelectSubset<T, MonitorAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MonitorAlerts and returns the data saved in the database.
     * @param {MonitorAlertCreateManyAndReturnArgs} args - Arguments to create many MonitorAlerts.
     * @example
     * // Create many MonitorAlerts
     * const monitorAlert = await prisma.monitorAlert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MonitorAlerts and only return the `id`
     * const monitorAlertWithIdOnly = await prisma.monitorAlert.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MonitorAlertCreateManyAndReturnArgs>(args?: SelectSubset<T, MonitorAlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonitorAlertPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MonitorAlert.
     * @param {MonitorAlertDeleteArgs} args - Arguments to delete one MonitorAlert.
     * @example
     * // Delete one MonitorAlert
     * const MonitorAlert = await prisma.monitorAlert.delete({
     *   where: {
     *     // ... filter to delete one MonitorAlert
     *   }
     * })
     * 
     */
    delete<T extends MonitorAlertDeleteArgs>(args: SelectSubset<T, MonitorAlertDeleteArgs<ExtArgs>>): Prisma__MonitorAlertClient<$Result.GetResult<Prisma.$MonitorAlertPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MonitorAlert.
     * @param {MonitorAlertUpdateArgs} args - Arguments to update one MonitorAlert.
     * @example
     * // Update one MonitorAlert
     * const monitorAlert = await prisma.monitorAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MonitorAlertUpdateArgs>(args: SelectSubset<T, MonitorAlertUpdateArgs<ExtArgs>>): Prisma__MonitorAlertClient<$Result.GetResult<Prisma.$MonitorAlertPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MonitorAlerts.
     * @param {MonitorAlertDeleteManyArgs} args - Arguments to filter MonitorAlerts to delete.
     * @example
     * // Delete a few MonitorAlerts
     * const { count } = await prisma.monitorAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MonitorAlertDeleteManyArgs>(args?: SelectSubset<T, MonitorAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MonitorAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitorAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MonitorAlerts
     * const monitorAlert = await prisma.monitorAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MonitorAlertUpdateManyArgs>(args: SelectSubset<T, MonitorAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MonitorAlert.
     * @param {MonitorAlertUpsertArgs} args - Arguments to update or create a MonitorAlert.
     * @example
     * // Update or create a MonitorAlert
     * const monitorAlert = await prisma.monitorAlert.upsert({
     *   create: {
     *     // ... data to create a MonitorAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MonitorAlert we want to update
     *   }
     * })
     */
    upsert<T extends MonitorAlertUpsertArgs>(args: SelectSubset<T, MonitorAlertUpsertArgs<ExtArgs>>): Prisma__MonitorAlertClient<$Result.GetResult<Prisma.$MonitorAlertPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MonitorAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitorAlertCountArgs} args - Arguments to filter MonitorAlerts to count.
     * @example
     * // Count the number of MonitorAlerts
     * const count = await prisma.monitorAlert.count({
     *   where: {
     *     // ... the filter for the MonitorAlerts we want to count
     *   }
     * })
    **/
    count<T extends MonitorAlertCountArgs>(
      args?: Subset<T, MonitorAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MonitorAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MonitorAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitorAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MonitorAlertAggregateArgs>(args: Subset<T, MonitorAlertAggregateArgs>): Prisma.PrismaPromise<GetMonitorAlertAggregateType<T>>

    /**
     * Group by MonitorAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitorAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MonitorAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MonitorAlertGroupByArgs['orderBy'] }
        : { orderBy?: MonitorAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MonitorAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonitorAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MonitorAlert model
   */
  readonly fields: MonitorAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MonitorAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MonitorAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    monitor<T extends MonitorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MonitorDefaultArgs<ExtArgs>>): Prisma__MonitorClient<$Result.GetResult<Prisma.$MonitorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MonitorAlert model
   */ 
  interface MonitorAlertFieldRefs {
    readonly id: FieldRef<"MonitorAlert", 'String'>
    readonly monitorId: FieldRef<"MonitorAlert", 'String'>
    readonly type: FieldRef<"MonitorAlert", 'String'>
    readonly message: FieldRef<"MonitorAlert", 'String'>
    readonly createdAt: FieldRef<"MonitorAlert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MonitorAlert findUnique
   */
  export type MonitorAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitorAlert
     */
    select?: MonitorAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorAlertInclude<ExtArgs> | null
    /**
     * Filter, which MonitorAlert to fetch.
     */
    where: MonitorAlertWhereUniqueInput
  }

  /**
   * MonitorAlert findUniqueOrThrow
   */
  export type MonitorAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitorAlert
     */
    select?: MonitorAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorAlertInclude<ExtArgs> | null
    /**
     * Filter, which MonitorAlert to fetch.
     */
    where: MonitorAlertWhereUniqueInput
  }

  /**
   * MonitorAlert findFirst
   */
  export type MonitorAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitorAlert
     */
    select?: MonitorAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorAlertInclude<ExtArgs> | null
    /**
     * Filter, which MonitorAlert to fetch.
     */
    where?: MonitorAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonitorAlerts to fetch.
     */
    orderBy?: MonitorAlertOrderByWithRelationInput | MonitorAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonitorAlerts.
     */
    cursor?: MonitorAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonitorAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonitorAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonitorAlerts.
     */
    distinct?: MonitorAlertScalarFieldEnum | MonitorAlertScalarFieldEnum[]
  }

  /**
   * MonitorAlert findFirstOrThrow
   */
  export type MonitorAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitorAlert
     */
    select?: MonitorAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorAlertInclude<ExtArgs> | null
    /**
     * Filter, which MonitorAlert to fetch.
     */
    where?: MonitorAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonitorAlerts to fetch.
     */
    orderBy?: MonitorAlertOrderByWithRelationInput | MonitorAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonitorAlerts.
     */
    cursor?: MonitorAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonitorAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonitorAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonitorAlerts.
     */
    distinct?: MonitorAlertScalarFieldEnum | MonitorAlertScalarFieldEnum[]
  }

  /**
   * MonitorAlert findMany
   */
  export type MonitorAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitorAlert
     */
    select?: MonitorAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorAlertInclude<ExtArgs> | null
    /**
     * Filter, which MonitorAlerts to fetch.
     */
    where?: MonitorAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonitorAlerts to fetch.
     */
    orderBy?: MonitorAlertOrderByWithRelationInput | MonitorAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MonitorAlerts.
     */
    cursor?: MonitorAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonitorAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonitorAlerts.
     */
    skip?: number
    distinct?: MonitorAlertScalarFieldEnum | MonitorAlertScalarFieldEnum[]
  }

  /**
   * MonitorAlert create
   */
  export type MonitorAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitorAlert
     */
    select?: MonitorAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorAlertInclude<ExtArgs> | null
    /**
     * The data needed to create a MonitorAlert.
     */
    data: XOR<MonitorAlertCreateInput, MonitorAlertUncheckedCreateInput>
  }

  /**
   * MonitorAlert createMany
   */
  export type MonitorAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MonitorAlerts.
     */
    data: MonitorAlertCreateManyInput | MonitorAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MonitorAlert createManyAndReturn
   */
  export type MonitorAlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitorAlert
     */
    select?: MonitorAlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MonitorAlerts.
     */
    data: MonitorAlertCreateManyInput | MonitorAlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorAlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MonitorAlert update
   */
  export type MonitorAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitorAlert
     */
    select?: MonitorAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorAlertInclude<ExtArgs> | null
    /**
     * The data needed to update a MonitorAlert.
     */
    data: XOR<MonitorAlertUpdateInput, MonitorAlertUncheckedUpdateInput>
    /**
     * Choose, which MonitorAlert to update.
     */
    where: MonitorAlertWhereUniqueInput
  }

  /**
   * MonitorAlert updateMany
   */
  export type MonitorAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MonitorAlerts.
     */
    data: XOR<MonitorAlertUpdateManyMutationInput, MonitorAlertUncheckedUpdateManyInput>
    /**
     * Filter which MonitorAlerts to update
     */
    where?: MonitorAlertWhereInput
  }

  /**
   * MonitorAlert upsert
   */
  export type MonitorAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitorAlert
     */
    select?: MonitorAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorAlertInclude<ExtArgs> | null
    /**
     * The filter to search for the MonitorAlert to update in case it exists.
     */
    where: MonitorAlertWhereUniqueInput
    /**
     * In case the MonitorAlert found by the `where` argument doesn't exist, create a new MonitorAlert with this data.
     */
    create: XOR<MonitorAlertCreateInput, MonitorAlertUncheckedCreateInput>
    /**
     * In case the MonitorAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MonitorAlertUpdateInput, MonitorAlertUncheckedUpdateInput>
  }

  /**
   * MonitorAlert delete
   */
  export type MonitorAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitorAlert
     */
    select?: MonitorAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorAlertInclude<ExtArgs> | null
    /**
     * Filter which MonitorAlert to delete.
     */
    where: MonitorAlertWhereUniqueInput
  }

  /**
   * MonitorAlert deleteMany
   */
  export type MonitorAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MonitorAlerts to delete
     */
    where?: MonitorAlertWhereInput
  }

  /**
   * MonitorAlert without action
   */
  export type MonitorAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitorAlert
     */
    select?: MonitorAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorAlertInclude<ExtArgs> | null
  }


  /**
   * Model ComponentGroup
   */

  export type AggregateComponentGroup = {
    _count: ComponentGroupCountAggregateOutputType | null
    _avg: ComponentGroupAvgAggregateOutputType | null
    _sum: ComponentGroupSumAggregateOutputType | null
    _min: ComponentGroupMinAggregateOutputType | null
    _max: ComponentGroupMaxAggregateOutputType | null
  }

  export type ComponentGroupAvgAggregateOutputType = {
    order: number | null
  }

  export type ComponentGroupSumAggregateOutputType = {
    order: number | null
  }

  export type ComponentGroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    orgId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComponentGroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    orgId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComponentGroupCountAggregateOutputType = {
    id: number
    name: number
    order: number
    orgId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComponentGroupAvgAggregateInputType = {
    order?: true
  }

  export type ComponentGroupSumAggregateInputType = {
    order?: true
  }

  export type ComponentGroupMinAggregateInputType = {
    id?: true
    name?: true
    order?: true
    orgId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComponentGroupMaxAggregateInputType = {
    id?: true
    name?: true
    order?: true
    orgId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComponentGroupCountAggregateInputType = {
    id?: true
    name?: true
    order?: true
    orgId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComponentGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComponentGroup to aggregate.
     */
    where?: ComponentGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComponentGroups to fetch.
     */
    orderBy?: ComponentGroupOrderByWithRelationInput | ComponentGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComponentGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComponentGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComponentGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComponentGroups
    **/
    _count?: true | ComponentGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComponentGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComponentGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComponentGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComponentGroupMaxAggregateInputType
  }

  export type GetComponentGroupAggregateType<T extends ComponentGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateComponentGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComponentGroup[P]>
      : GetScalarType<T[P], AggregateComponentGroup[P]>
  }




  export type ComponentGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComponentGroupWhereInput
    orderBy?: ComponentGroupOrderByWithAggregationInput | ComponentGroupOrderByWithAggregationInput[]
    by: ComponentGroupScalarFieldEnum[] | ComponentGroupScalarFieldEnum
    having?: ComponentGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComponentGroupCountAggregateInputType | true
    _avg?: ComponentGroupAvgAggregateInputType
    _sum?: ComponentGroupSumAggregateInputType
    _min?: ComponentGroupMinAggregateInputType
    _max?: ComponentGroupMaxAggregateInputType
  }

  export type ComponentGroupGroupByOutputType = {
    id: string
    name: string
    order: number
    orgId: string
    createdAt: Date
    updatedAt: Date
    _count: ComponentGroupCountAggregateOutputType | null
    _avg: ComponentGroupAvgAggregateOutputType | null
    _sum: ComponentGroupSumAggregateOutputType | null
    _min: ComponentGroupMinAggregateOutputType | null
    _max: ComponentGroupMaxAggregateOutputType | null
  }

  type GetComponentGroupGroupByPayload<T extends ComponentGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComponentGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComponentGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComponentGroupGroupByOutputType[P]>
            : GetScalarType<T[P], ComponentGroupGroupByOutputType[P]>
        }
      >
    >


  export type ComponentGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    orgId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    components?: boolean | ComponentGroup$componentsArgs<ExtArgs>
    _count?: boolean | ComponentGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["componentGroup"]>

  export type ComponentGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    orgId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["componentGroup"]>

  export type ComponentGroupSelectScalar = {
    id?: boolean
    name?: boolean
    order?: boolean
    orgId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ComponentGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    components?: boolean | ComponentGroup$componentsArgs<ExtArgs>
    _count?: boolean | ComponentGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ComponentGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $ComponentGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComponentGroup"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      components: Prisma.$ComponentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      order: number
      orgId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["componentGroup"]>
    composites: {}
  }

  type ComponentGroupGetPayload<S extends boolean | null | undefined | ComponentGroupDefaultArgs> = $Result.GetResult<Prisma.$ComponentGroupPayload, S>

  type ComponentGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComponentGroupFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComponentGroupCountAggregateInputType | true
    }

  export interface ComponentGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComponentGroup'], meta: { name: 'ComponentGroup' } }
    /**
     * Find zero or one ComponentGroup that matches the filter.
     * @param {ComponentGroupFindUniqueArgs} args - Arguments to find a ComponentGroup
     * @example
     * // Get one ComponentGroup
     * const componentGroup = await prisma.componentGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComponentGroupFindUniqueArgs>(args: SelectSubset<T, ComponentGroupFindUniqueArgs<ExtArgs>>): Prisma__ComponentGroupClient<$Result.GetResult<Prisma.$ComponentGroupPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ComponentGroup that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ComponentGroupFindUniqueOrThrowArgs} args - Arguments to find a ComponentGroup
     * @example
     * // Get one ComponentGroup
     * const componentGroup = await prisma.componentGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComponentGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, ComponentGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComponentGroupClient<$Result.GetResult<Prisma.$ComponentGroupPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ComponentGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentGroupFindFirstArgs} args - Arguments to find a ComponentGroup
     * @example
     * // Get one ComponentGroup
     * const componentGroup = await prisma.componentGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComponentGroupFindFirstArgs>(args?: SelectSubset<T, ComponentGroupFindFirstArgs<ExtArgs>>): Prisma__ComponentGroupClient<$Result.GetResult<Prisma.$ComponentGroupPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ComponentGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentGroupFindFirstOrThrowArgs} args - Arguments to find a ComponentGroup
     * @example
     * // Get one ComponentGroup
     * const componentGroup = await prisma.componentGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComponentGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, ComponentGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComponentGroupClient<$Result.GetResult<Prisma.$ComponentGroupPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ComponentGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComponentGroups
     * const componentGroups = await prisma.componentGroup.findMany()
     * 
     * // Get first 10 ComponentGroups
     * const componentGroups = await prisma.componentGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const componentGroupWithIdOnly = await prisma.componentGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComponentGroupFindManyArgs>(args?: SelectSubset<T, ComponentGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentGroupPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ComponentGroup.
     * @param {ComponentGroupCreateArgs} args - Arguments to create a ComponentGroup.
     * @example
     * // Create one ComponentGroup
     * const ComponentGroup = await prisma.componentGroup.create({
     *   data: {
     *     // ... data to create a ComponentGroup
     *   }
     * })
     * 
     */
    create<T extends ComponentGroupCreateArgs>(args: SelectSubset<T, ComponentGroupCreateArgs<ExtArgs>>): Prisma__ComponentGroupClient<$Result.GetResult<Prisma.$ComponentGroupPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ComponentGroups.
     * @param {ComponentGroupCreateManyArgs} args - Arguments to create many ComponentGroups.
     * @example
     * // Create many ComponentGroups
     * const componentGroup = await prisma.componentGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComponentGroupCreateManyArgs>(args?: SelectSubset<T, ComponentGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComponentGroups and returns the data saved in the database.
     * @param {ComponentGroupCreateManyAndReturnArgs} args - Arguments to create many ComponentGroups.
     * @example
     * // Create many ComponentGroups
     * const componentGroup = await prisma.componentGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComponentGroups and only return the `id`
     * const componentGroupWithIdOnly = await prisma.componentGroup.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComponentGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, ComponentGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentGroupPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ComponentGroup.
     * @param {ComponentGroupDeleteArgs} args - Arguments to delete one ComponentGroup.
     * @example
     * // Delete one ComponentGroup
     * const ComponentGroup = await prisma.componentGroup.delete({
     *   where: {
     *     // ... filter to delete one ComponentGroup
     *   }
     * })
     * 
     */
    delete<T extends ComponentGroupDeleteArgs>(args: SelectSubset<T, ComponentGroupDeleteArgs<ExtArgs>>): Prisma__ComponentGroupClient<$Result.GetResult<Prisma.$ComponentGroupPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ComponentGroup.
     * @param {ComponentGroupUpdateArgs} args - Arguments to update one ComponentGroup.
     * @example
     * // Update one ComponentGroup
     * const componentGroup = await prisma.componentGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComponentGroupUpdateArgs>(args: SelectSubset<T, ComponentGroupUpdateArgs<ExtArgs>>): Prisma__ComponentGroupClient<$Result.GetResult<Prisma.$ComponentGroupPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ComponentGroups.
     * @param {ComponentGroupDeleteManyArgs} args - Arguments to filter ComponentGroups to delete.
     * @example
     * // Delete a few ComponentGroups
     * const { count } = await prisma.componentGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComponentGroupDeleteManyArgs>(args?: SelectSubset<T, ComponentGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComponentGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComponentGroups
     * const componentGroup = await prisma.componentGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComponentGroupUpdateManyArgs>(args: SelectSubset<T, ComponentGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ComponentGroup.
     * @param {ComponentGroupUpsertArgs} args - Arguments to update or create a ComponentGroup.
     * @example
     * // Update or create a ComponentGroup
     * const componentGroup = await prisma.componentGroup.upsert({
     *   create: {
     *     // ... data to create a ComponentGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComponentGroup we want to update
     *   }
     * })
     */
    upsert<T extends ComponentGroupUpsertArgs>(args: SelectSubset<T, ComponentGroupUpsertArgs<ExtArgs>>): Prisma__ComponentGroupClient<$Result.GetResult<Prisma.$ComponentGroupPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ComponentGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentGroupCountArgs} args - Arguments to filter ComponentGroups to count.
     * @example
     * // Count the number of ComponentGroups
     * const count = await prisma.componentGroup.count({
     *   where: {
     *     // ... the filter for the ComponentGroups we want to count
     *   }
     * })
    **/
    count<T extends ComponentGroupCountArgs>(
      args?: Subset<T, ComponentGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComponentGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComponentGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComponentGroupAggregateArgs>(args: Subset<T, ComponentGroupAggregateArgs>): Prisma.PrismaPromise<GetComponentGroupAggregateType<T>>

    /**
     * Group by ComponentGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComponentGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComponentGroupGroupByArgs['orderBy'] }
        : { orderBy?: ComponentGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComponentGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComponentGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComponentGroup model
   */
  readonly fields: ComponentGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComponentGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComponentGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    components<T extends ComponentGroup$componentsArgs<ExtArgs> = {}>(args?: Subset<T, ComponentGroup$componentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComponentGroup model
   */ 
  interface ComponentGroupFieldRefs {
    readonly id: FieldRef<"ComponentGroup", 'String'>
    readonly name: FieldRef<"ComponentGroup", 'String'>
    readonly order: FieldRef<"ComponentGroup", 'Int'>
    readonly orgId: FieldRef<"ComponentGroup", 'String'>
    readonly createdAt: FieldRef<"ComponentGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"ComponentGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ComponentGroup findUnique
   */
  export type ComponentGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentGroup
     */
    select?: ComponentGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentGroupInclude<ExtArgs> | null
    /**
     * Filter, which ComponentGroup to fetch.
     */
    where: ComponentGroupWhereUniqueInput
  }

  /**
   * ComponentGroup findUniqueOrThrow
   */
  export type ComponentGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentGroup
     */
    select?: ComponentGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentGroupInclude<ExtArgs> | null
    /**
     * Filter, which ComponentGroup to fetch.
     */
    where: ComponentGroupWhereUniqueInput
  }

  /**
   * ComponentGroup findFirst
   */
  export type ComponentGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentGroup
     */
    select?: ComponentGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentGroupInclude<ExtArgs> | null
    /**
     * Filter, which ComponentGroup to fetch.
     */
    where?: ComponentGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComponentGroups to fetch.
     */
    orderBy?: ComponentGroupOrderByWithRelationInput | ComponentGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComponentGroups.
     */
    cursor?: ComponentGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComponentGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComponentGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComponentGroups.
     */
    distinct?: ComponentGroupScalarFieldEnum | ComponentGroupScalarFieldEnum[]
  }

  /**
   * ComponentGroup findFirstOrThrow
   */
  export type ComponentGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentGroup
     */
    select?: ComponentGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentGroupInclude<ExtArgs> | null
    /**
     * Filter, which ComponentGroup to fetch.
     */
    where?: ComponentGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComponentGroups to fetch.
     */
    orderBy?: ComponentGroupOrderByWithRelationInput | ComponentGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComponentGroups.
     */
    cursor?: ComponentGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComponentGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComponentGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComponentGroups.
     */
    distinct?: ComponentGroupScalarFieldEnum | ComponentGroupScalarFieldEnum[]
  }

  /**
   * ComponentGroup findMany
   */
  export type ComponentGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentGroup
     */
    select?: ComponentGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentGroupInclude<ExtArgs> | null
    /**
     * Filter, which ComponentGroups to fetch.
     */
    where?: ComponentGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComponentGroups to fetch.
     */
    orderBy?: ComponentGroupOrderByWithRelationInput | ComponentGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComponentGroups.
     */
    cursor?: ComponentGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComponentGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComponentGroups.
     */
    skip?: number
    distinct?: ComponentGroupScalarFieldEnum | ComponentGroupScalarFieldEnum[]
  }

  /**
   * ComponentGroup create
   */
  export type ComponentGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentGroup
     */
    select?: ComponentGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a ComponentGroup.
     */
    data: XOR<ComponentGroupCreateInput, ComponentGroupUncheckedCreateInput>
  }

  /**
   * ComponentGroup createMany
   */
  export type ComponentGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComponentGroups.
     */
    data: ComponentGroupCreateManyInput | ComponentGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComponentGroup createManyAndReturn
   */
  export type ComponentGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentGroup
     */
    select?: ComponentGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ComponentGroups.
     */
    data: ComponentGroupCreateManyInput | ComponentGroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComponentGroup update
   */
  export type ComponentGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentGroup
     */
    select?: ComponentGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a ComponentGroup.
     */
    data: XOR<ComponentGroupUpdateInput, ComponentGroupUncheckedUpdateInput>
    /**
     * Choose, which ComponentGroup to update.
     */
    where: ComponentGroupWhereUniqueInput
  }

  /**
   * ComponentGroup updateMany
   */
  export type ComponentGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComponentGroups.
     */
    data: XOR<ComponentGroupUpdateManyMutationInput, ComponentGroupUncheckedUpdateManyInput>
    /**
     * Filter which ComponentGroups to update
     */
    where?: ComponentGroupWhereInput
  }

  /**
   * ComponentGroup upsert
   */
  export type ComponentGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentGroup
     */
    select?: ComponentGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the ComponentGroup to update in case it exists.
     */
    where: ComponentGroupWhereUniqueInput
    /**
     * In case the ComponentGroup found by the `where` argument doesn't exist, create a new ComponentGroup with this data.
     */
    create: XOR<ComponentGroupCreateInput, ComponentGroupUncheckedCreateInput>
    /**
     * In case the ComponentGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComponentGroupUpdateInput, ComponentGroupUncheckedUpdateInput>
  }

  /**
   * ComponentGroup delete
   */
  export type ComponentGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentGroup
     */
    select?: ComponentGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentGroupInclude<ExtArgs> | null
    /**
     * Filter which ComponentGroup to delete.
     */
    where: ComponentGroupWhereUniqueInput
  }

  /**
   * ComponentGroup deleteMany
   */
  export type ComponentGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComponentGroups to delete
     */
    where?: ComponentGroupWhereInput
  }

  /**
   * ComponentGroup.components
   */
  export type ComponentGroup$componentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    where?: ComponentWhereInput
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    cursor?: ComponentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }

  /**
   * ComponentGroup without action
   */
  export type ComponentGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentGroup
     */
    select?: ComponentGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentGroupInclude<ExtArgs> | null
  }


  /**
   * Model Component
   */

  export type AggregateComponent = {
    _count: ComponentCountAggregateOutputType | null
    _avg: ComponentAvgAggregateOutputType | null
    _sum: ComponentSumAggregateOutputType | null
    _min: ComponentMinAggregateOutputType | null
    _max: ComponentMaxAggregateOutputType | null
  }

  export type ComponentAvgAggregateOutputType = {
    order: number | null
  }

  export type ComponentSumAggregateOutputType = {
    order: number | null
  }

  export type ComponentMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: $Enums.ComponentStatus | null
    order: number | null
    orgId: string | null
    groupId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComponentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: $Enums.ComponentStatus | null
    order: number | null
    orgId: string | null
    groupId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComponentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    order: number
    orgId: number
    groupId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComponentAvgAggregateInputType = {
    order?: true
  }

  export type ComponentSumAggregateInputType = {
    order?: true
  }

  export type ComponentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    order?: true
    orgId?: true
    groupId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComponentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    order?: true
    orgId?: true
    groupId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComponentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    order?: true
    orgId?: true
    groupId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComponentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Component to aggregate.
     */
    where?: ComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Components to fetch.
     */
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Components.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Components
    **/
    _count?: true | ComponentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComponentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComponentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComponentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComponentMaxAggregateInputType
  }

  export type GetComponentAggregateType<T extends ComponentAggregateArgs> = {
        [P in keyof T & keyof AggregateComponent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComponent[P]>
      : GetScalarType<T[P], AggregateComponent[P]>
  }




  export type ComponentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComponentWhereInput
    orderBy?: ComponentOrderByWithAggregationInput | ComponentOrderByWithAggregationInput[]
    by: ComponentScalarFieldEnum[] | ComponentScalarFieldEnum
    having?: ComponentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComponentCountAggregateInputType | true
    _avg?: ComponentAvgAggregateInputType
    _sum?: ComponentSumAggregateInputType
    _min?: ComponentMinAggregateInputType
    _max?: ComponentMaxAggregateInputType
  }

  export type ComponentGroupByOutputType = {
    id: string
    name: string
    description: string | null
    status: $Enums.ComponentStatus
    order: number
    orgId: string
    groupId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ComponentCountAggregateOutputType | null
    _avg: ComponentAvgAggregateOutputType | null
    _sum: ComponentSumAggregateOutputType | null
    _min: ComponentMinAggregateOutputType | null
    _max: ComponentMaxAggregateOutputType | null
  }

  type GetComponentGroupByPayload<T extends ComponentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComponentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComponentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComponentGroupByOutputType[P]>
            : GetScalarType<T[P], ComponentGroupByOutputType[P]>
        }
      >
    >


  export type ComponentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    order?: boolean
    orgId?: boolean
    groupId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    group?: boolean | Component$groupArgs<ExtArgs>
    monitors?: boolean | Component$monitorsArgs<ExtArgs>
    incidents?: boolean | Component$incidentsArgs<ExtArgs>
    _count?: boolean | ComponentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["component"]>

  export type ComponentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    order?: boolean
    orgId?: boolean
    groupId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    group?: boolean | Component$groupArgs<ExtArgs>
  }, ExtArgs["result"]["component"]>

  export type ComponentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    order?: boolean
    orgId?: boolean
    groupId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ComponentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    group?: boolean | Component$groupArgs<ExtArgs>
    monitors?: boolean | Component$monitorsArgs<ExtArgs>
    incidents?: boolean | Component$incidentsArgs<ExtArgs>
    _count?: boolean | ComponentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ComponentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    group?: boolean | Component$groupArgs<ExtArgs>
  }

  export type $ComponentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Component"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      group: Prisma.$ComponentGroupPayload<ExtArgs> | null
      monitors: Prisma.$MonitorPayload<ExtArgs>[]
      incidents: Prisma.$IncidentComponentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      status: $Enums.ComponentStatus
      order: number
      orgId: string
      groupId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["component"]>
    composites: {}
  }

  type ComponentGetPayload<S extends boolean | null | undefined | ComponentDefaultArgs> = $Result.GetResult<Prisma.$ComponentPayload, S>

  type ComponentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComponentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComponentCountAggregateInputType | true
    }

  export interface ComponentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Component'], meta: { name: 'Component' } }
    /**
     * Find zero or one Component that matches the filter.
     * @param {ComponentFindUniqueArgs} args - Arguments to find a Component
     * @example
     * // Get one Component
     * const component = await prisma.component.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComponentFindUniqueArgs>(args: SelectSubset<T, ComponentFindUniqueArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Component that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ComponentFindUniqueOrThrowArgs} args - Arguments to find a Component
     * @example
     * // Get one Component
     * const component = await prisma.component.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComponentFindUniqueOrThrowArgs>(args: SelectSubset<T, ComponentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Component that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentFindFirstArgs} args - Arguments to find a Component
     * @example
     * // Get one Component
     * const component = await prisma.component.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComponentFindFirstArgs>(args?: SelectSubset<T, ComponentFindFirstArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Component that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentFindFirstOrThrowArgs} args - Arguments to find a Component
     * @example
     * // Get one Component
     * const component = await prisma.component.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComponentFindFirstOrThrowArgs>(args?: SelectSubset<T, ComponentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Components that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Components
     * const components = await prisma.component.findMany()
     * 
     * // Get first 10 Components
     * const components = await prisma.component.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const componentWithIdOnly = await prisma.component.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComponentFindManyArgs>(args?: SelectSubset<T, ComponentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Component.
     * @param {ComponentCreateArgs} args - Arguments to create a Component.
     * @example
     * // Create one Component
     * const Component = await prisma.component.create({
     *   data: {
     *     // ... data to create a Component
     *   }
     * })
     * 
     */
    create<T extends ComponentCreateArgs>(args: SelectSubset<T, ComponentCreateArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Components.
     * @param {ComponentCreateManyArgs} args - Arguments to create many Components.
     * @example
     * // Create many Components
     * const component = await prisma.component.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComponentCreateManyArgs>(args?: SelectSubset<T, ComponentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Components and returns the data saved in the database.
     * @param {ComponentCreateManyAndReturnArgs} args - Arguments to create many Components.
     * @example
     * // Create many Components
     * const component = await prisma.component.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Components and only return the `id`
     * const componentWithIdOnly = await prisma.component.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComponentCreateManyAndReturnArgs>(args?: SelectSubset<T, ComponentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Component.
     * @param {ComponentDeleteArgs} args - Arguments to delete one Component.
     * @example
     * // Delete one Component
     * const Component = await prisma.component.delete({
     *   where: {
     *     // ... filter to delete one Component
     *   }
     * })
     * 
     */
    delete<T extends ComponentDeleteArgs>(args: SelectSubset<T, ComponentDeleteArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Component.
     * @param {ComponentUpdateArgs} args - Arguments to update one Component.
     * @example
     * // Update one Component
     * const component = await prisma.component.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComponentUpdateArgs>(args: SelectSubset<T, ComponentUpdateArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Components.
     * @param {ComponentDeleteManyArgs} args - Arguments to filter Components to delete.
     * @example
     * // Delete a few Components
     * const { count } = await prisma.component.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComponentDeleteManyArgs>(args?: SelectSubset<T, ComponentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Components.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Components
     * const component = await prisma.component.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComponentUpdateManyArgs>(args: SelectSubset<T, ComponentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Component.
     * @param {ComponentUpsertArgs} args - Arguments to update or create a Component.
     * @example
     * // Update or create a Component
     * const component = await prisma.component.upsert({
     *   create: {
     *     // ... data to create a Component
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Component we want to update
     *   }
     * })
     */
    upsert<T extends ComponentUpsertArgs>(args: SelectSubset<T, ComponentUpsertArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Components.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentCountArgs} args - Arguments to filter Components to count.
     * @example
     * // Count the number of Components
     * const count = await prisma.component.count({
     *   where: {
     *     // ... the filter for the Components we want to count
     *   }
     * })
    **/
    count<T extends ComponentCountArgs>(
      args?: Subset<T, ComponentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComponentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Component.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComponentAggregateArgs>(args: Subset<T, ComponentAggregateArgs>): Prisma.PrismaPromise<GetComponentAggregateType<T>>

    /**
     * Group by Component.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComponentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComponentGroupByArgs['orderBy'] }
        : { orderBy?: ComponentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComponentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComponentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Component model
   */
  readonly fields: ComponentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Component.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComponentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    group<T extends Component$groupArgs<ExtArgs> = {}>(args?: Subset<T, Component$groupArgs<ExtArgs>>): Prisma__ComponentGroupClient<$Result.GetResult<Prisma.$ComponentGroupPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    monitors<T extends Component$monitorsArgs<ExtArgs> = {}>(args?: Subset<T, Component$monitorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonitorPayload<ExtArgs>, T, "findMany"> | Null>
    incidents<T extends Component$incidentsArgs<ExtArgs> = {}>(args?: Subset<T, Component$incidentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentComponentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Component model
   */ 
  interface ComponentFieldRefs {
    readonly id: FieldRef<"Component", 'String'>
    readonly name: FieldRef<"Component", 'String'>
    readonly description: FieldRef<"Component", 'String'>
    readonly status: FieldRef<"Component", 'ComponentStatus'>
    readonly order: FieldRef<"Component", 'Int'>
    readonly orgId: FieldRef<"Component", 'String'>
    readonly groupId: FieldRef<"Component", 'String'>
    readonly createdAt: FieldRef<"Component", 'DateTime'>
    readonly updatedAt: FieldRef<"Component", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Component findUnique
   */
  export type ComponentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Component to fetch.
     */
    where: ComponentWhereUniqueInput
  }

  /**
   * Component findUniqueOrThrow
   */
  export type ComponentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Component to fetch.
     */
    where: ComponentWhereUniqueInput
  }

  /**
   * Component findFirst
   */
  export type ComponentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Component to fetch.
     */
    where?: ComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Components to fetch.
     */
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Components.
     */
    cursor?: ComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Components.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Components.
     */
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }

  /**
   * Component findFirstOrThrow
   */
  export type ComponentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Component to fetch.
     */
    where?: ComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Components to fetch.
     */
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Components.
     */
    cursor?: ComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Components.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Components.
     */
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }

  /**
   * Component findMany
   */
  export type ComponentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Components to fetch.
     */
    where?: ComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Components to fetch.
     */
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Components.
     */
    cursor?: ComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Components.
     */
    skip?: number
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }

  /**
   * Component create
   */
  export type ComponentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * The data needed to create a Component.
     */
    data: XOR<ComponentCreateInput, ComponentUncheckedCreateInput>
  }

  /**
   * Component createMany
   */
  export type ComponentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Components.
     */
    data: ComponentCreateManyInput | ComponentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Component createManyAndReturn
   */
  export type ComponentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Components.
     */
    data: ComponentCreateManyInput | ComponentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Component update
   */
  export type ComponentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * The data needed to update a Component.
     */
    data: XOR<ComponentUpdateInput, ComponentUncheckedUpdateInput>
    /**
     * Choose, which Component to update.
     */
    where: ComponentWhereUniqueInput
  }

  /**
   * Component updateMany
   */
  export type ComponentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Components.
     */
    data: XOR<ComponentUpdateManyMutationInput, ComponentUncheckedUpdateManyInput>
    /**
     * Filter which Components to update
     */
    where?: ComponentWhereInput
  }

  /**
   * Component upsert
   */
  export type ComponentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * The filter to search for the Component to update in case it exists.
     */
    where: ComponentWhereUniqueInput
    /**
     * In case the Component found by the `where` argument doesn't exist, create a new Component with this data.
     */
    create: XOR<ComponentCreateInput, ComponentUncheckedCreateInput>
    /**
     * In case the Component was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComponentUpdateInput, ComponentUncheckedUpdateInput>
  }

  /**
   * Component delete
   */
  export type ComponentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter which Component to delete.
     */
    where: ComponentWhereUniqueInput
  }

  /**
   * Component deleteMany
   */
  export type ComponentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Components to delete
     */
    where?: ComponentWhereInput
  }

  /**
   * Component.group
   */
  export type Component$groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentGroup
     */
    select?: ComponentGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentGroupInclude<ExtArgs> | null
    where?: ComponentGroupWhereInput
  }

  /**
   * Component.monitors
   */
  export type Component$monitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor
     */
    select?: MonitorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorInclude<ExtArgs> | null
    where?: MonitorWhereInput
    orderBy?: MonitorOrderByWithRelationInput | MonitorOrderByWithRelationInput[]
    cursor?: MonitorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MonitorScalarFieldEnum | MonitorScalarFieldEnum[]
  }

  /**
   * Component.incidents
   */
  export type Component$incidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentComponent
     */
    select?: IncidentComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentComponentInclude<ExtArgs> | null
    where?: IncidentComponentWhereInput
    orderBy?: IncidentComponentOrderByWithRelationInput | IncidentComponentOrderByWithRelationInput[]
    cursor?: IncidentComponentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentComponentScalarFieldEnum | IncidentComponentScalarFieldEnum[]
  }

  /**
   * Component without action
   */
  export type ComponentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
  }


  /**
   * Model Incident
   */

  export type AggregateIncident = {
    _count: IncidentCountAggregateOutputType | null
    _min: IncidentMinAggregateOutputType | null
    _max: IncidentMaxAggregateOutputType | null
  }

  export type IncidentMinAggregateOutputType = {
    id: string | null
    title: string | null
    status: $Enums.IncidentStatus | null
    severity: $Enums.IncidentSeverity | null
    orgId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    resolvedAt: Date | null
  }

  export type IncidentMaxAggregateOutputType = {
    id: string | null
    title: string | null
    status: $Enums.IncidentStatus | null
    severity: $Enums.IncidentSeverity | null
    orgId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    resolvedAt: Date | null
  }

  export type IncidentCountAggregateOutputType = {
    id: number
    title: number
    status: number
    severity: number
    orgId: number
    createdAt: number
    updatedAt: number
    resolvedAt: number
    _all: number
  }


  export type IncidentMinAggregateInputType = {
    id?: true
    title?: true
    status?: true
    severity?: true
    orgId?: true
    createdAt?: true
    updatedAt?: true
    resolvedAt?: true
  }

  export type IncidentMaxAggregateInputType = {
    id?: true
    title?: true
    status?: true
    severity?: true
    orgId?: true
    createdAt?: true
    updatedAt?: true
    resolvedAt?: true
  }

  export type IncidentCountAggregateInputType = {
    id?: true
    title?: true
    status?: true
    severity?: true
    orgId?: true
    createdAt?: true
    updatedAt?: true
    resolvedAt?: true
    _all?: true
  }

  export type IncidentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incident to aggregate.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Incidents
    **/
    _count?: true | IncidentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncidentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncidentMaxAggregateInputType
  }

  export type GetIncidentAggregateType<T extends IncidentAggregateArgs> = {
        [P in keyof T & keyof AggregateIncident]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncident[P]>
      : GetScalarType<T[P], AggregateIncident[P]>
  }




  export type IncidentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentWhereInput
    orderBy?: IncidentOrderByWithAggregationInput | IncidentOrderByWithAggregationInput[]
    by: IncidentScalarFieldEnum[] | IncidentScalarFieldEnum
    having?: IncidentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncidentCountAggregateInputType | true
    _min?: IncidentMinAggregateInputType
    _max?: IncidentMaxAggregateInputType
  }

  export type IncidentGroupByOutputType = {
    id: string
    title: string
    status: $Enums.IncidentStatus
    severity: $Enums.IncidentSeverity
    orgId: string
    createdAt: Date
    updatedAt: Date
    resolvedAt: Date | null
    _count: IncidentCountAggregateOutputType | null
    _min: IncidentMinAggregateOutputType | null
    _max: IncidentMaxAggregateOutputType | null
  }

  type GetIncidentGroupByPayload<T extends IncidentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncidentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncidentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncidentGroupByOutputType[P]>
            : GetScalarType<T[P], IncidentGroupByOutputType[P]>
        }
      >
    >


  export type IncidentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    status?: boolean
    severity?: boolean
    orgId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    updates?: boolean | Incident$updatesArgs<ExtArgs>
    components?: boolean | Incident$componentsArgs<ExtArgs>
    _count?: boolean | IncidentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incident"]>

  export type IncidentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    status?: boolean
    severity?: boolean
    orgId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incident"]>

  export type IncidentSelectScalar = {
    id?: boolean
    title?: boolean
    status?: boolean
    severity?: boolean
    orgId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
  }

  export type IncidentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    updates?: boolean | Incident$updatesArgs<ExtArgs>
    components?: boolean | Incident$componentsArgs<ExtArgs>
    _count?: boolean | IncidentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IncidentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $IncidentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Incident"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      updates: Prisma.$IncidentUpdatePayload<ExtArgs>[]
      components: Prisma.$IncidentComponentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      status: $Enums.IncidentStatus
      severity: $Enums.IncidentSeverity
      orgId: string
      createdAt: Date
      updatedAt: Date
      resolvedAt: Date | null
    }, ExtArgs["result"]["incident"]>
    composites: {}
  }

  type IncidentGetPayload<S extends boolean | null | undefined | IncidentDefaultArgs> = $Result.GetResult<Prisma.$IncidentPayload, S>

  type IncidentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IncidentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IncidentCountAggregateInputType | true
    }

  export interface IncidentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Incident'], meta: { name: 'Incident' } }
    /**
     * Find zero or one Incident that matches the filter.
     * @param {IncidentFindUniqueArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncidentFindUniqueArgs>(args: SelectSubset<T, IncidentFindUniqueArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Incident that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IncidentFindUniqueOrThrowArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncidentFindUniqueOrThrowArgs>(args: SelectSubset<T, IncidentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Incident that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindFirstArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncidentFindFirstArgs>(args?: SelectSubset<T, IncidentFindFirstArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Incident that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindFirstOrThrowArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncidentFindFirstOrThrowArgs>(args?: SelectSubset<T, IncidentFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Incidents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Incidents
     * const incidents = await prisma.incident.findMany()
     * 
     * // Get first 10 Incidents
     * const incidents = await prisma.incident.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incidentWithIdOnly = await prisma.incident.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncidentFindManyArgs>(args?: SelectSubset<T, IncidentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Incident.
     * @param {IncidentCreateArgs} args - Arguments to create a Incident.
     * @example
     * // Create one Incident
     * const Incident = await prisma.incident.create({
     *   data: {
     *     // ... data to create a Incident
     *   }
     * })
     * 
     */
    create<T extends IncidentCreateArgs>(args: SelectSubset<T, IncidentCreateArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Incidents.
     * @param {IncidentCreateManyArgs} args - Arguments to create many Incidents.
     * @example
     * // Create many Incidents
     * const incident = await prisma.incident.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncidentCreateManyArgs>(args?: SelectSubset<T, IncidentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Incidents and returns the data saved in the database.
     * @param {IncidentCreateManyAndReturnArgs} args - Arguments to create many Incidents.
     * @example
     * // Create many Incidents
     * const incident = await prisma.incident.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Incidents and only return the `id`
     * const incidentWithIdOnly = await prisma.incident.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IncidentCreateManyAndReturnArgs>(args?: SelectSubset<T, IncidentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Incident.
     * @param {IncidentDeleteArgs} args - Arguments to delete one Incident.
     * @example
     * // Delete one Incident
     * const Incident = await prisma.incident.delete({
     *   where: {
     *     // ... filter to delete one Incident
     *   }
     * })
     * 
     */
    delete<T extends IncidentDeleteArgs>(args: SelectSubset<T, IncidentDeleteArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Incident.
     * @param {IncidentUpdateArgs} args - Arguments to update one Incident.
     * @example
     * // Update one Incident
     * const incident = await prisma.incident.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncidentUpdateArgs>(args: SelectSubset<T, IncidentUpdateArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Incidents.
     * @param {IncidentDeleteManyArgs} args - Arguments to filter Incidents to delete.
     * @example
     * // Delete a few Incidents
     * const { count } = await prisma.incident.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncidentDeleteManyArgs>(args?: SelectSubset<T, IncidentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Incidents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Incidents
     * const incident = await prisma.incident.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncidentUpdateManyArgs>(args: SelectSubset<T, IncidentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Incident.
     * @param {IncidentUpsertArgs} args - Arguments to update or create a Incident.
     * @example
     * // Update or create a Incident
     * const incident = await prisma.incident.upsert({
     *   create: {
     *     // ... data to create a Incident
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Incident we want to update
     *   }
     * })
     */
    upsert<T extends IncidentUpsertArgs>(args: SelectSubset<T, IncidentUpsertArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Incidents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentCountArgs} args - Arguments to filter Incidents to count.
     * @example
     * // Count the number of Incidents
     * const count = await prisma.incident.count({
     *   where: {
     *     // ... the filter for the Incidents we want to count
     *   }
     * })
    **/
    count<T extends IncidentCountArgs>(
      args?: Subset<T, IncidentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncidentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Incident.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncidentAggregateArgs>(args: Subset<T, IncidentAggregateArgs>): Prisma.PrismaPromise<GetIncidentAggregateType<T>>

    /**
     * Group by Incident.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncidentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncidentGroupByArgs['orderBy'] }
        : { orderBy?: IncidentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncidentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncidentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Incident model
   */
  readonly fields: IncidentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Incident.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncidentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    updates<T extends Incident$updatesArgs<ExtArgs> = {}>(args?: Subset<T, Incident$updatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentUpdatePayload<ExtArgs>, T, "findMany"> | Null>
    components<T extends Incident$componentsArgs<ExtArgs> = {}>(args?: Subset<T, Incident$componentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentComponentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Incident model
   */ 
  interface IncidentFieldRefs {
    readonly id: FieldRef<"Incident", 'String'>
    readonly title: FieldRef<"Incident", 'String'>
    readonly status: FieldRef<"Incident", 'IncidentStatus'>
    readonly severity: FieldRef<"Incident", 'IncidentSeverity'>
    readonly orgId: FieldRef<"Incident", 'String'>
    readonly createdAt: FieldRef<"Incident", 'DateTime'>
    readonly updatedAt: FieldRef<"Incident", 'DateTime'>
    readonly resolvedAt: FieldRef<"Incident", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Incident findUnique
   */
  export type IncidentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident findUniqueOrThrow
   */
  export type IncidentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident findFirst
   */
  export type IncidentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incidents.
     */
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident findFirstOrThrow
   */
  export type IncidentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incidents.
     */
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident findMany
   */
  export type IncidentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incidents to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident create
   */
  export type IncidentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The data needed to create a Incident.
     */
    data: XOR<IncidentCreateInput, IncidentUncheckedCreateInput>
  }

  /**
   * Incident createMany
   */
  export type IncidentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Incidents.
     */
    data: IncidentCreateManyInput | IncidentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Incident createManyAndReturn
   */
  export type IncidentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Incidents.
     */
    data: IncidentCreateManyInput | IncidentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Incident update
   */
  export type IncidentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The data needed to update a Incident.
     */
    data: XOR<IncidentUpdateInput, IncidentUncheckedUpdateInput>
    /**
     * Choose, which Incident to update.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident updateMany
   */
  export type IncidentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Incidents.
     */
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyInput>
    /**
     * Filter which Incidents to update
     */
    where?: IncidentWhereInput
  }

  /**
   * Incident upsert
   */
  export type IncidentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The filter to search for the Incident to update in case it exists.
     */
    where: IncidentWhereUniqueInput
    /**
     * In case the Incident found by the `where` argument doesn't exist, create a new Incident with this data.
     */
    create: XOR<IncidentCreateInput, IncidentUncheckedCreateInput>
    /**
     * In case the Incident was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncidentUpdateInput, IncidentUncheckedUpdateInput>
  }

  /**
   * Incident delete
   */
  export type IncidentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter which Incident to delete.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident deleteMany
   */
  export type IncidentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incidents to delete
     */
    where?: IncidentWhereInput
  }

  /**
   * Incident.updates
   */
  export type Incident$updatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentUpdate
     */
    select?: IncidentUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentUpdateInclude<ExtArgs> | null
    where?: IncidentUpdateWhereInput
    orderBy?: IncidentUpdateOrderByWithRelationInput | IncidentUpdateOrderByWithRelationInput[]
    cursor?: IncidentUpdateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentUpdateScalarFieldEnum | IncidentUpdateScalarFieldEnum[]
  }

  /**
   * Incident.components
   */
  export type Incident$componentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentComponent
     */
    select?: IncidentComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentComponentInclude<ExtArgs> | null
    where?: IncidentComponentWhereInput
    orderBy?: IncidentComponentOrderByWithRelationInput | IncidentComponentOrderByWithRelationInput[]
    cursor?: IncidentComponentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentComponentScalarFieldEnum | IncidentComponentScalarFieldEnum[]
  }

  /**
   * Incident without action
   */
  export type IncidentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
  }


  /**
   * Model IncidentUpdate
   */

  export type AggregateIncidentUpdate = {
    _count: IncidentUpdateCountAggregateOutputType | null
    _min: IncidentUpdateMinAggregateOutputType | null
    _max: IncidentUpdateMaxAggregateOutputType | null
  }

  export type IncidentUpdateMinAggregateOutputType = {
    id: string | null
    incidentId: string | null
    status: $Enums.IncidentStatus | null
    message: string | null
    createdAt: Date | null
  }

  export type IncidentUpdateMaxAggregateOutputType = {
    id: string | null
    incidentId: string | null
    status: $Enums.IncidentStatus | null
    message: string | null
    createdAt: Date | null
  }

  export type IncidentUpdateCountAggregateOutputType = {
    id: number
    incidentId: number
    status: number
    message: number
    createdAt: number
    _all: number
  }


  export type IncidentUpdateMinAggregateInputType = {
    id?: true
    incidentId?: true
    status?: true
    message?: true
    createdAt?: true
  }

  export type IncidentUpdateMaxAggregateInputType = {
    id?: true
    incidentId?: true
    status?: true
    message?: true
    createdAt?: true
  }

  export type IncidentUpdateCountAggregateInputType = {
    id?: true
    incidentId?: true
    status?: true
    message?: true
    createdAt?: true
    _all?: true
  }

  export type IncidentUpdateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncidentUpdate to aggregate.
     */
    where?: IncidentUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentUpdates to fetch.
     */
    orderBy?: IncidentUpdateOrderByWithRelationInput | IncidentUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncidentUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IncidentUpdates
    **/
    _count?: true | IncidentUpdateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncidentUpdateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncidentUpdateMaxAggregateInputType
  }

  export type GetIncidentUpdateAggregateType<T extends IncidentUpdateAggregateArgs> = {
        [P in keyof T & keyof AggregateIncidentUpdate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncidentUpdate[P]>
      : GetScalarType<T[P], AggregateIncidentUpdate[P]>
  }




  export type IncidentUpdateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentUpdateWhereInput
    orderBy?: IncidentUpdateOrderByWithAggregationInput | IncidentUpdateOrderByWithAggregationInput[]
    by: IncidentUpdateScalarFieldEnum[] | IncidentUpdateScalarFieldEnum
    having?: IncidentUpdateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncidentUpdateCountAggregateInputType | true
    _min?: IncidentUpdateMinAggregateInputType
    _max?: IncidentUpdateMaxAggregateInputType
  }

  export type IncidentUpdateGroupByOutputType = {
    id: string
    incidentId: string
    status: $Enums.IncidentStatus
    message: string
    createdAt: Date
    _count: IncidentUpdateCountAggregateOutputType | null
    _min: IncidentUpdateMinAggregateOutputType | null
    _max: IncidentUpdateMaxAggregateOutputType | null
  }

  type GetIncidentUpdateGroupByPayload<T extends IncidentUpdateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncidentUpdateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncidentUpdateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncidentUpdateGroupByOutputType[P]>
            : GetScalarType<T[P], IncidentUpdateGroupByOutputType[P]>
        }
      >
    >


  export type IncidentUpdateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    incidentId?: boolean
    status?: boolean
    message?: boolean
    createdAt?: boolean
    incident?: boolean | IncidentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incidentUpdate"]>

  export type IncidentUpdateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    incidentId?: boolean
    status?: boolean
    message?: boolean
    createdAt?: boolean
    incident?: boolean | IncidentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incidentUpdate"]>

  export type IncidentUpdateSelectScalar = {
    id?: boolean
    incidentId?: boolean
    status?: boolean
    message?: boolean
    createdAt?: boolean
  }

  export type IncidentUpdateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incident?: boolean | IncidentDefaultArgs<ExtArgs>
  }
  export type IncidentUpdateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incident?: boolean | IncidentDefaultArgs<ExtArgs>
  }

  export type $IncidentUpdatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IncidentUpdate"
    objects: {
      incident: Prisma.$IncidentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      incidentId: string
      status: $Enums.IncidentStatus
      message: string
      createdAt: Date
    }, ExtArgs["result"]["incidentUpdate"]>
    composites: {}
  }

  type IncidentUpdateGetPayload<S extends boolean | null | undefined | IncidentUpdateDefaultArgs> = $Result.GetResult<Prisma.$IncidentUpdatePayload, S>

  type IncidentUpdateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IncidentUpdateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IncidentUpdateCountAggregateInputType | true
    }

  export interface IncidentUpdateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IncidentUpdate'], meta: { name: 'IncidentUpdate' } }
    /**
     * Find zero or one IncidentUpdate that matches the filter.
     * @param {IncidentUpdateFindUniqueArgs} args - Arguments to find a IncidentUpdate
     * @example
     * // Get one IncidentUpdate
     * const incidentUpdate = await prisma.incidentUpdate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncidentUpdateFindUniqueArgs>(args: SelectSubset<T, IncidentUpdateFindUniqueArgs<ExtArgs>>): Prisma__IncidentUpdateClient<$Result.GetResult<Prisma.$IncidentUpdatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IncidentUpdate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IncidentUpdateFindUniqueOrThrowArgs} args - Arguments to find a IncidentUpdate
     * @example
     * // Get one IncidentUpdate
     * const incidentUpdate = await prisma.incidentUpdate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncidentUpdateFindUniqueOrThrowArgs>(args: SelectSubset<T, IncidentUpdateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncidentUpdateClient<$Result.GetResult<Prisma.$IncidentUpdatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IncidentUpdate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentUpdateFindFirstArgs} args - Arguments to find a IncidentUpdate
     * @example
     * // Get one IncidentUpdate
     * const incidentUpdate = await prisma.incidentUpdate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncidentUpdateFindFirstArgs>(args?: SelectSubset<T, IncidentUpdateFindFirstArgs<ExtArgs>>): Prisma__IncidentUpdateClient<$Result.GetResult<Prisma.$IncidentUpdatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IncidentUpdate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentUpdateFindFirstOrThrowArgs} args - Arguments to find a IncidentUpdate
     * @example
     * // Get one IncidentUpdate
     * const incidentUpdate = await prisma.incidentUpdate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncidentUpdateFindFirstOrThrowArgs>(args?: SelectSubset<T, IncidentUpdateFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncidentUpdateClient<$Result.GetResult<Prisma.$IncidentUpdatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IncidentUpdates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentUpdateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IncidentUpdates
     * const incidentUpdates = await prisma.incidentUpdate.findMany()
     * 
     * // Get first 10 IncidentUpdates
     * const incidentUpdates = await prisma.incidentUpdate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incidentUpdateWithIdOnly = await prisma.incidentUpdate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncidentUpdateFindManyArgs>(args?: SelectSubset<T, IncidentUpdateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentUpdatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IncidentUpdate.
     * @param {IncidentUpdateCreateArgs} args - Arguments to create a IncidentUpdate.
     * @example
     * // Create one IncidentUpdate
     * const IncidentUpdate = await prisma.incidentUpdate.create({
     *   data: {
     *     // ... data to create a IncidentUpdate
     *   }
     * })
     * 
     */
    create<T extends IncidentUpdateCreateArgs>(args: SelectSubset<T, IncidentUpdateCreateArgs<ExtArgs>>): Prisma__IncidentUpdateClient<$Result.GetResult<Prisma.$IncidentUpdatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IncidentUpdates.
     * @param {IncidentUpdateCreateManyArgs} args - Arguments to create many IncidentUpdates.
     * @example
     * // Create many IncidentUpdates
     * const incidentUpdate = await prisma.incidentUpdate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncidentUpdateCreateManyArgs>(args?: SelectSubset<T, IncidentUpdateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IncidentUpdates and returns the data saved in the database.
     * @param {IncidentUpdateCreateManyAndReturnArgs} args - Arguments to create many IncidentUpdates.
     * @example
     * // Create many IncidentUpdates
     * const incidentUpdate = await prisma.incidentUpdate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IncidentUpdates and only return the `id`
     * const incidentUpdateWithIdOnly = await prisma.incidentUpdate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IncidentUpdateCreateManyAndReturnArgs>(args?: SelectSubset<T, IncidentUpdateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentUpdatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IncidentUpdate.
     * @param {IncidentUpdateDeleteArgs} args - Arguments to delete one IncidentUpdate.
     * @example
     * // Delete one IncidentUpdate
     * const IncidentUpdate = await prisma.incidentUpdate.delete({
     *   where: {
     *     // ... filter to delete one IncidentUpdate
     *   }
     * })
     * 
     */
    delete<T extends IncidentUpdateDeleteArgs>(args: SelectSubset<T, IncidentUpdateDeleteArgs<ExtArgs>>): Prisma__IncidentUpdateClient<$Result.GetResult<Prisma.$IncidentUpdatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IncidentUpdate.
     * @param {IncidentUpdateUpdateArgs} args - Arguments to update one IncidentUpdate.
     * @example
     * // Update one IncidentUpdate
     * const incidentUpdate = await prisma.incidentUpdate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncidentUpdateUpdateArgs>(args: SelectSubset<T, IncidentUpdateUpdateArgs<ExtArgs>>): Prisma__IncidentUpdateClient<$Result.GetResult<Prisma.$IncidentUpdatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IncidentUpdates.
     * @param {IncidentUpdateDeleteManyArgs} args - Arguments to filter IncidentUpdates to delete.
     * @example
     * // Delete a few IncidentUpdates
     * const { count } = await prisma.incidentUpdate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncidentUpdateDeleteManyArgs>(args?: SelectSubset<T, IncidentUpdateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IncidentUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentUpdateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IncidentUpdates
     * const incidentUpdate = await prisma.incidentUpdate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncidentUpdateUpdateManyArgs>(args: SelectSubset<T, IncidentUpdateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IncidentUpdate.
     * @param {IncidentUpdateUpsertArgs} args - Arguments to update or create a IncidentUpdate.
     * @example
     * // Update or create a IncidentUpdate
     * const incidentUpdate = await prisma.incidentUpdate.upsert({
     *   create: {
     *     // ... data to create a IncidentUpdate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IncidentUpdate we want to update
     *   }
     * })
     */
    upsert<T extends IncidentUpdateUpsertArgs>(args: SelectSubset<T, IncidentUpdateUpsertArgs<ExtArgs>>): Prisma__IncidentUpdateClient<$Result.GetResult<Prisma.$IncidentUpdatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IncidentUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentUpdateCountArgs} args - Arguments to filter IncidentUpdates to count.
     * @example
     * // Count the number of IncidentUpdates
     * const count = await prisma.incidentUpdate.count({
     *   where: {
     *     // ... the filter for the IncidentUpdates we want to count
     *   }
     * })
    **/
    count<T extends IncidentUpdateCountArgs>(
      args?: Subset<T, IncidentUpdateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncidentUpdateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IncidentUpdate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentUpdateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncidentUpdateAggregateArgs>(args: Subset<T, IncidentUpdateAggregateArgs>): Prisma.PrismaPromise<GetIncidentUpdateAggregateType<T>>

    /**
     * Group by IncidentUpdate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentUpdateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncidentUpdateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncidentUpdateGroupByArgs['orderBy'] }
        : { orderBy?: IncidentUpdateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncidentUpdateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncidentUpdateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IncidentUpdate model
   */
  readonly fields: IncidentUpdateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IncidentUpdate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncidentUpdateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    incident<T extends IncidentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IncidentDefaultArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IncidentUpdate model
   */ 
  interface IncidentUpdateFieldRefs {
    readonly id: FieldRef<"IncidentUpdate", 'String'>
    readonly incidentId: FieldRef<"IncidentUpdate", 'String'>
    readonly status: FieldRef<"IncidentUpdate", 'IncidentStatus'>
    readonly message: FieldRef<"IncidentUpdate", 'String'>
    readonly createdAt: FieldRef<"IncidentUpdate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IncidentUpdate findUnique
   */
  export type IncidentUpdateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentUpdate
     */
    select?: IncidentUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentUpdateInclude<ExtArgs> | null
    /**
     * Filter, which IncidentUpdate to fetch.
     */
    where: IncidentUpdateWhereUniqueInput
  }

  /**
   * IncidentUpdate findUniqueOrThrow
   */
  export type IncidentUpdateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentUpdate
     */
    select?: IncidentUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentUpdateInclude<ExtArgs> | null
    /**
     * Filter, which IncidentUpdate to fetch.
     */
    where: IncidentUpdateWhereUniqueInput
  }

  /**
   * IncidentUpdate findFirst
   */
  export type IncidentUpdateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentUpdate
     */
    select?: IncidentUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentUpdateInclude<ExtArgs> | null
    /**
     * Filter, which IncidentUpdate to fetch.
     */
    where?: IncidentUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentUpdates to fetch.
     */
    orderBy?: IncidentUpdateOrderByWithRelationInput | IncidentUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncidentUpdates.
     */
    cursor?: IncidentUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncidentUpdates.
     */
    distinct?: IncidentUpdateScalarFieldEnum | IncidentUpdateScalarFieldEnum[]
  }

  /**
   * IncidentUpdate findFirstOrThrow
   */
  export type IncidentUpdateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentUpdate
     */
    select?: IncidentUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentUpdateInclude<ExtArgs> | null
    /**
     * Filter, which IncidentUpdate to fetch.
     */
    where?: IncidentUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentUpdates to fetch.
     */
    orderBy?: IncidentUpdateOrderByWithRelationInput | IncidentUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncidentUpdates.
     */
    cursor?: IncidentUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncidentUpdates.
     */
    distinct?: IncidentUpdateScalarFieldEnum | IncidentUpdateScalarFieldEnum[]
  }

  /**
   * IncidentUpdate findMany
   */
  export type IncidentUpdateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentUpdate
     */
    select?: IncidentUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentUpdateInclude<ExtArgs> | null
    /**
     * Filter, which IncidentUpdates to fetch.
     */
    where?: IncidentUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentUpdates to fetch.
     */
    orderBy?: IncidentUpdateOrderByWithRelationInput | IncidentUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IncidentUpdates.
     */
    cursor?: IncidentUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentUpdates.
     */
    skip?: number
    distinct?: IncidentUpdateScalarFieldEnum | IncidentUpdateScalarFieldEnum[]
  }

  /**
   * IncidentUpdate create
   */
  export type IncidentUpdateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentUpdate
     */
    select?: IncidentUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentUpdateInclude<ExtArgs> | null
    /**
     * The data needed to create a IncidentUpdate.
     */
    data: XOR<IncidentUpdateCreateInput, IncidentUpdateUncheckedCreateInput>
  }

  /**
   * IncidentUpdate createMany
   */
  export type IncidentUpdateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IncidentUpdates.
     */
    data: IncidentUpdateCreateManyInput | IncidentUpdateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IncidentUpdate createManyAndReturn
   */
  export type IncidentUpdateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentUpdate
     */
    select?: IncidentUpdateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IncidentUpdates.
     */
    data: IncidentUpdateCreateManyInput | IncidentUpdateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentUpdateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IncidentUpdate update
   */
  export type IncidentUpdateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentUpdate
     */
    select?: IncidentUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentUpdateInclude<ExtArgs> | null
    /**
     * The data needed to update a IncidentUpdate.
     */
    data: XOR<IncidentUpdateUpdateInput, IncidentUpdateUncheckedUpdateInput>
    /**
     * Choose, which IncidentUpdate to update.
     */
    where: IncidentUpdateWhereUniqueInput
  }

  /**
   * IncidentUpdate updateMany
   */
  export type IncidentUpdateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IncidentUpdates.
     */
    data: XOR<IncidentUpdateUpdateManyMutationInput, IncidentUpdateUncheckedUpdateManyInput>
    /**
     * Filter which IncidentUpdates to update
     */
    where?: IncidentUpdateWhereInput
  }

  /**
   * IncidentUpdate upsert
   */
  export type IncidentUpdateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentUpdate
     */
    select?: IncidentUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentUpdateInclude<ExtArgs> | null
    /**
     * The filter to search for the IncidentUpdate to update in case it exists.
     */
    where: IncidentUpdateWhereUniqueInput
    /**
     * In case the IncidentUpdate found by the `where` argument doesn't exist, create a new IncidentUpdate with this data.
     */
    create: XOR<IncidentUpdateCreateInput, IncidentUpdateUncheckedCreateInput>
    /**
     * In case the IncidentUpdate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncidentUpdateUpdateInput, IncidentUpdateUncheckedUpdateInput>
  }

  /**
   * IncidentUpdate delete
   */
  export type IncidentUpdateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentUpdate
     */
    select?: IncidentUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentUpdateInclude<ExtArgs> | null
    /**
     * Filter which IncidentUpdate to delete.
     */
    where: IncidentUpdateWhereUniqueInput
  }

  /**
   * IncidentUpdate deleteMany
   */
  export type IncidentUpdateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncidentUpdates to delete
     */
    where?: IncidentUpdateWhereInput
  }

  /**
   * IncidentUpdate without action
   */
  export type IncidentUpdateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentUpdate
     */
    select?: IncidentUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentUpdateInclude<ExtArgs> | null
  }


  /**
   * Model IncidentComponent
   */

  export type AggregateIncidentComponent = {
    _count: IncidentComponentCountAggregateOutputType | null
    _min: IncidentComponentMinAggregateOutputType | null
    _max: IncidentComponentMaxAggregateOutputType | null
  }

  export type IncidentComponentMinAggregateOutputType = {
    id: string | null
    incidentId: string | null
    componentId: string | null
    status: $Enums.ComponentStatus | null
  }

  export type IncidentComponentMaxAggregateOutputType = {
    id: string | null
    incidentId: string | null
    componentId: string | null
    status: $Enums.ComponentStatus | null
  }

  export type IncidentComponentCountAggregateOutputType = {
    id: number
    incidentId: number
    componentId: number
    status: number
    _all: number
  }


  export type IncidentComponentMinAggregateInputType = {
    id?: true
    incidentId?: true
    componentId?: true
    status?: true
  }

  export type IncidentComponentMaxAggregateInputType = {
    id?: true
    incidentId?: true
    componentId?: true
    status?: true
  }

  export type IncidentComponentCountAggregateInputType = {
    id?: true
    incidentId?: true
    componentId?: true
    status?: true
    _all?: true
  }

  export type IncidentComponentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncidentComponent to aggregate.
     */
    where?: IncidentComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentComponents to fetch.
     */
    orderBy?: IncidentComponentOrderByWithRelationInput | IncidentComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncidentComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IncidentComponents
    **/
    _count?: true | IncidentComponentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncidentComponentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncidentComponentMaxAggregateInputType
  }

  export type GetIncidentComponentAggregateType<T extends IncidentComponentAggregateArgs> = {
        [P in keyof T & keyof AggregateIncidentComponent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncidentComponent[P]>
      : GetScalarType<T[P], AggregateIncidentComponent[P]>
  }




  export type IncidentComponentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentComponentWhereInput
    orderBy?: IncidentComponentOrderByWithAggregationInput | IncidentComponentOrderByWithAggregationInput[]
    by: IncidentComponentScalarFieldEnum[] | IncidentComponentScalarFieldEnum
    having?: IncidentComponentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncidentComponentCountAggregateInputType | true
    _min?: IncidentComponentMinAggregateInputType
    _max?: IncidentComponentMaxAggregateInputType
  }

  export type IncidentComponentGroupByOutputType = {
    id: string
    incidentId: string
    componentId: string
    status: $Enums.ComponentStatus
    _count: IncidentComponentCountAggregateOutputType | null
    _min: IncidentComponentMinAggregateOutputType | null
    _max: IncidentComponentMaxAggregateOutputType | null
  }

  type GetIncidentComponentGroupByPayload<T extends IncidentComponentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncidentComponentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncidentComponentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncidentComponentGroupByOutputType[P]>
            : GetScalarType<T[P], IncidentComponentGroupByOutputType[P]>
        }
      >
    >


  export type IncidentComponentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    incidentId?: boolean
    componentId?: boolean
    status?: boolean
    incident?: boolean | IncidentDefaultArgs<ExtArgs>
    component?: boolean | ComponentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incidentComponent"]>

  export type IncidentComponentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    incidentId?: boolean
    componentId?: boolean
    status?: boolean
    incident?: boolean | IncidentDefaultArgs<ExtArgs>
    component?: boolean | ComponentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incidentComponent"]>

  export type IncidentComponentSelectScalar = {
    id?: boolean
    incidentId?: boolean
    componentId?: boolean
    status?: boolean
  }

  export type IncidentComponentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incident?: boolean | IncidentDefaultArgs<ExtArgs>
    component?: boolean | ComponentDefaultArgs<ExtArgs>
  }
  export type IncidentComponentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incident?: boolean | IncidentDefaultArgs<ExtArgs>
    component?: boolean | ComponentDefaultArgs<ExtArgs>
  }

  export type $IncidentComponentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IncidentComponent"
    objects: {
      incident: Prisma.$IncidentPayload<ExtArgs>
      component: Prisma.$ComponentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      incidentId: string
      componentId: string
      status: $Enums.ComponentStatus
    }, ExtArgs["result"]["incidentComponent"]>
    composites: {}
  }

  type IncidentComponentGetPayload<S extends boolean | null | undefined | IncidentComponentDefaultArgs> = $Result.GetResult<Prisma.$IncidentComponentPayload, S>

  type IncidentComponentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IncidentComponentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IncidentComponentCountAggregateInputType | true
    }

  export interface IncidentComponentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IncidentComponent'], meta: { name: 'IncidentComponent' } }
    /**
     * Find zero or one IncidentComponent that matches the filter.
     * @param {IncidentComponentFindUniqueArgs} args - Arguments to find a IncidentComponent
     * @example
     * // Get one IncidentComponent
     * const incidentComponent = await prisma.incidentComponent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncidentComponentFindUniqueArgs>(args: SelectSubset<T, IncidentComponentFindUniqueArgs<ExtArgs>>): Prisma__IncidentComponentClient<$Result.GetResult<Prisma.$IncidentComponentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IncidentComponent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IncidentComponentFindUniqueOrThrowArgs} args - Arguments to find a IncidentComponent
     * @example
     * // Get one IncidentComponent
     * const incidentComponent = await prisma.incidentComponent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncidentComponentFindUniqueOrThrowArgs>(args: SelectSubset<T, IncidentComponentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncidentComponentClient<$Result.GetResult<Prisma.$IncidentComponentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IncidentComponent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentComponentFindFirstArgs} args - Arguments to find a IncidentComponent
     * @example
     * // Get one IncidentComponent
     * const incidentComponent = await prisma.incidentComponent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncidentComponentFindFirstArgs>(args?: SelectSubset<T, IncidentComponentFindFirstArgs<ExtArgs>>): Prisma__IncidentComponentClient<$Result.GetResult<Prisma.$IncidentComponentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IncidentComponent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentComponentFindFirstOrThrowArgs} args - Arguments to find a IncidentComponent
     * @example
     * // Get one IncidentComponent
     * const incidentComponent = await prisma.incidentComponent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncidentComponentFindFirstOrThrowArgs>(args?: SelectSubset<T, IncidentComponentFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncidentComponentClient<$Result.GetResult<Prisma.$IncidentComponentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IncidentComponents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentComponentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IncidentComponents
     * const incidentComponents = await prisma.incidentComponent.findMany()
     * 
     * // Get first 10 IncidentComponents
     * const incidentComponents = await prisma.incidentComponent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incidentComponentWithIdOnly = await prisma.incidentComponent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncidentComponentFindManyArgs>(args?: SelectSubset<T, IncidentComponentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentComponentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IncidentComponent.
     * @param {IncidentComponentCreateArgs} args - Arguments to create a IncidentComponent.
     * @example
     * // Create one IncidentComponent
     * const IncidentComponent = await prisma.incidentComponent.create({
     *   data: {
     *     // ... data to create a IncidentComponent
     *   }
     * })
     * 
     */
    create<T extends IncidentComponentCreateArgs>(args: SelectSubset<T, IncidentComponentCreateArgs<ExtArgs>>): Prisma__IncidentComponentClient<$Result.GetResult<Prisma.$IncidentComponentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IncidentComponents.
     * @param {IncidentComponentCreateManyArgs} args - Arguments to create many IncidentComponents.
     * @example
     * // Create many IncidentComponents
     * const incidentComponent = await prisma.incidentComponent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncidentComponentCreateManyArgs>(args?: SelectSubset<T, IncidentComponentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IncidentComponents and returns the data saved in the database.
     * @param {IncidentComponentCreateManyAndReturnArgs} args - Arguments to create many IncidentComponents.
     * @example
     * // Create many IncidentComponents
     * const incidentComponent = await prisma.incidentComponent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IncidentComponents and only return the `id`
     * const incidentComponentWithIdOnly = await prisma.incidentComponent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IncidentComponentCreateManyAndReturnArgs>(args?: SelectSubset<T, IncidentComponentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentComponentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IncidentComponent.
     * @param {IncidentComponentDeleteArgs} args - Arguments to delete one IncidentComponent.
     * @example
     * // Delete one IncidentComponent
     * const IncidentComponent = await prisma.incidentComponent.delete({
     *   where: {
     *     // ... filter to delete one IncidentComponent
     *   }
     * })
     * 
     */
    delete<T extends IncidentComponentDeleteArgs>(args: SelectSubset<T, IncidentComponentDeleteArgs<ExtArgs>>): Prisma__IncidentComponentClient<$Result.GetResult<Prisma.$IncidentComponentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IncidentComponent.
     * @param {IncidentComponentUpdateArgs} args - Arguments to update one IncidentComponent.
     * @example
     * // Update one IncidentComponent
     * const incidentComponent = await prisma.incidentComponent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncidentComponentUpdateArgs>(args: SelectSubset<T, IncidentComponentUpdateArgs<ExtArgs>>): Prisma__IncidentComponentClient<$Result.GetResult<Prisma.$IncidentComponentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IncidentComponents.
     * @param {IncidentComponentDeleteManyArgs} args - Arguments to filter IncidentComponents to delete.
     * @example
     * // Delete a few IncidentComponents
     * const { count } = await prisma.incidentComponent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncidentComponentDeleteManyArgs>(args?: SelectSubset<T, IncidentComponentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IncidentComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentComponentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IncidentComponents
     * const incidentComponent = await prisma.incidentComponent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncidentComponentUpdateManyArgs>(args: SelectSubset<T, IncidentComponentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IncidentComponent.
     * @param {IncidentComponentUpsertArgs} args - Arguments to update or create a IncidentComponent.
     * @example
     * // Update or create a IncidentComponent
     * const incidentComponent = await prisma.incidentComponent.upsert({
     *   create: {
     *     // ... data to create a IncidentComponent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IncidentComponent we want to update
     *   }
     * })
     */
    upsert<T extends IncidentComponentUpsertArgs>(args: SelectSubset<T, IncidentComponentUpsertArgs<ExtArgs>>): Prisma__IncidentComponentClient<$Result.GetResult<Prisma.$IncidentComponentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IncidentComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentComponentCountArgs} args - Arguments to filter IncidentComponents to count.
     * @example
     * // Count the number of IncidentComponents
     * const count = await prisma.incidentComponent.count({
     *   where: {
     *     // ... the filter for the IncidentComponents we want to count
     *   }
     * })
    **/
    count<T extends IncidentComponentCountArgs>(
      args?: Subset<T, IncidentComponentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncidentComponentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IncidentComponent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentComponentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncidentComponentAggregateArgs>(args: Subset<T, IncidentComponentAggregateArgs>): Prisma.PrismaPromise<GetIncidentComponentAggregateType<T>>

    /**
     * Group by IncidentComponent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentComponentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncidentComponentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncidentComponentGroupByArgs['orderBy'] }
        : { orderBy?: IncidentComponentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncidentComponentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncidentComponentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IncidentComponent model
   */
  readonly fields: IncidentComponentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IncidentComponent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncidentComponentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    incident<T extends IncidentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IncidentDefaultArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    component<T extends ComponentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComponentDefaultArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IncidentComponent model
   */ 
  interface IncidentComponentFieldRefs {
    readonly id: FieldRef<"IncidentComponent", 'String'>
    readonly incidentId: FieldRef<"IncidentComponent", 'String'>
    readonly componentId: FieldRef<"IncidentComponent", 'String'>
    readonly status: FieldRef<"IncidentComponent", 'ComponentStatus'>
  }
    

  // Custom InputTypes
  /**
   * IncidentComponent findUnique
   */
  export type IncidentComponentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentComponent
     */
    select?: IncidentComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentComponentInclude<ExtArgs> | null
    /**
     * Filter, which IncidentComponent to fetch.
     */
    where: IncidentComponentWhereUniqueInput
  }

  /**
   * IncidentComponent findUniqueOrThrow
   */
  export type IncidentComponentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentComponent
     */
    select?: IncidentComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentComponentInclude<ExtArgs> | null
    /**
     * Filter, which IncidentComponent to fetch.
     */
    where: IncidentComponentWhereUniqueInput
  }

  /**
   * IncidentComponent findFirst
   */
  export type IncidentComponentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentComponent
     */
    select?: IncidentComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentComponentInclude<ExtArgs> | null
    /**
     * Filter, which IncidentComponent to fetch.
     */
    where?: IncidentComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentComponents to fetch.
     */
    orderBy?: IncidentComponentOrderByWithRelationInput | IncidentComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncidentComponents.
     */
    cursor?: IncidentComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncidentComponents.
     */
    distinct?: IncidentComponentScalarFieldEnum | IncidentComponentScalarFieldEnum[]
  }

  /**
   * IncidentComponent findFirstOrThrow
   */
  export type IncidentComponentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentComponent
     */
    select?: IncidentComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentComponentInclude<ExtArgs> | null
    /**
     * Filter, which IncidentComponent to fetch.
     */
    where?: IncidentComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentComponents to fetch.
     */
    orderBy?: IncidentComponentOrderByWithRelationInput | IncidentComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncidentComponents.
     */
    cursor?: IncidentComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncidentComponents.
     */
    distinct?: IncidentComponentScalarFieldEnum | IncidentComponentScalarFieldEnum[]
  }

  /**
   * IncidentComponent findMany
   */
  export type IncidentComponentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentComponent
     */
    select?: IncidentComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentComponentInclude<ExtArgs> | null
    /**
     * Filter, which IncidentComponents to fetch.
     */
    where?: IncidentComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentComponents to fetch.
     */
    orderBy?: IncidentComponentOrderByWithRelationInput | IncidentComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IncidentComponents.
     */
    cursor?: IncidentComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentComponents.
     */
    skip?: number
    distinct?: IncidentComponentScalarFieldEnum | IncidentComponentScalarFieldEnum[]
  }

  /**
   * IncidentComponent create
   */
  export type IncidentComponentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentComponent
     */
    select?: IncidentComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentComponentInclude<ExtArgs> | null
    /**
     * The data needed to create a IncidentComponent.
     */
    data: XOR<IncidentComponentCreateInput, IncidentComponentUncheckedCreateInput>
  }

  /**
   * IncidentComponent createMany
   */
  export type IncidentComponentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IncidentComponents.
     */
    data: IncidentComponentCreateManyInput | IncidentComponentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IncidentComponent createManyAndReturn
   */
  export type IncidentComponentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentComponent
     */
    select?: IncidentComponentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IncidentComponents.
     */
    data: IncidentComponentCreateManyInput | IncidentComponentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentComponentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IncidentComponent update
   */
  export type IncidentComponentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentComponent
     */
    select?: IncidentComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentComponentInclude<ExtArgs> | null
    /**
     * The data needed to update a IncidentComponent.
     */
    data: XOR<IncidentComponentUpdateInput, IncidentComponentUncheckedUpdateInput>
    /**
     * Choose, which IncidentComponent to update.
     */
    where: IncidentComponentWhereUniqueInput
  }

  /**
   * IncidentComponent updateMany
   */
  export type IncidentComponentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IncidentComponents.
     */
    data: XOR<IncidentComponentUpdateManyMutationInput, IncidentComponentUncheckedUpdateManyInput>
    /**
     * Filter which IncidentComponents to update
     */
    where?: IncidentComponentWhereInput
  }

  /**
   * IncidentComponent upsert
   */
  export type IncidentComponentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentComponent
     */
    select?: IncidentComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentComponentInclude<ExtArgs> | null
    /**
     * The filter to search for the IncidentComponent to update in case it exists.
     */
    where: IncidentComponentWhereUniqueInput
    /**
     * In case the IncidentComponent found by the `where` argument doesn't exist, create a new IncidentComponent with this data.
     */
    create: XOR<IncidentComponentCreateInput, IncidentComponentUncheckedCreateInput>
    /**
     * In case the IncidentComponent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncidentComponentUpdateInput, IncidentComponentUncheckedUpdateInput>
  }

  /**
   * IncidentComponent delete
   */
  export type IncidentComponentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentComponent
     */
    select?: IncidentComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentComponentInclude<ExtArgs> | null
    /**
     * Filter which IncidentComponent to delete.
     */
    where: IncidentComponentWhereUniqueInput
  }

  /**
   * IncidentComponent deleteMany
   */
  export type IncidentComponentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncidentComponents to delete
     */
    where?: IncidentComponentWhereInput
  }

  /**
   * IncidentComponent without action
   */
  export type IncidentComponentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentComponent
     */
    select?: IncidentComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentComponentInclude<ExtArgs> | null
  }


  /**
   * Model Subscriber
   */

  export type AggregateSubscriber = {
    _count: SubscriberCountAggregateOutputType | null
    _min: SubscriberMinAggregateOutputType | null
    _max: SubscriberMaxAggregateOutputType | null
  }

  export type SubscriberMinAggregateOutputType = {
    id: string | null
    type: $Enums.SubscriberType | null
    email: string | null
    webhookUrl: string | null
    confirmed: boolean | null
    token: string | null
    orgId: string | null
    createdAt: Date | null
  }

  export type SubscriberMaxAggregateOutputType = {
    id: string | null
    type: $Enums.SubscriberType | null
    email: string | null
    webhookUrl: string | null
    confirmed: boolean | null
    token: string | null
    orgId: string | null
    createdAt: Date | null
  }

  export type SubscriberCountAggregateOutputType = {
    id: number
    type: number
    email: number
    webhookUrl: number
    confirmed: number
    token: number
    orgId: number
    createdAt: number
    _all: number
  }


  export type SubscriberMinAggregateInputType = {
    id?: true
    type?: true
    email?: true
    webhookUrl?: true
    confirmed?: true
    token?: true
    orgId?: true
    createdAt?: true
  }

  export type SubscriberMaxAggregateInputType = {
    id?: true
    type?: true
    email?: true
    webhookUrl?: true
    confirmed?: true
    token?: true
    orgId?: true
    createdAt?: true
  }

  export type SubscriberCountAggregateInputType = {
    id?: true
    type?: true
    email?: true
    webhookUrl?: true
    confirmed?: true
    token?: true
    orgId?: true
    createdAt?: true
    _all?: true
  }

  export type SubscriberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriber to aggregate.
     */
    where?: SubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscribers to fetch.
     */
    orderBy?: SubscriberOrderByWithRelationInput | SubscriberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscribers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscribers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscribers
    **/
    _count?: true | SubscriberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriberMaxAggregateInputType
  }

  export type GetSubscriberAggregateType<T extends SubscriberAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriber]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriber[P]>
      : GetScalarType<T[P], AggregateSubscriber[P]>
  }




  export type SubscriberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriberWhereInput
    orderBy?: SubscriberOrderByWithAggregationInput | SubscriberOrderByWithAggregationInput[]
    by: SubscriberScalarFieldEnum[] | SubscriberScalarFieldEnum
    having?: SubscriberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriberCountAggregateInputType | true
    _min?: SubscriberMinAggregateInputType
    _max?: SubscriberMaxAggregateInputType
  }

  export type SubscriberGroupByOutputType = {
    id: string
    type: $Enums.SubscriberType
    email: string | null
    webhookUrl: string | null
    confirmed: boolean
    token: string
    orgId: string
    createdAt: Date
    _count: SubscriberCountAggregateOutputType | null
    _min: SubscriberMinAggregateOutputType | null
    _max: SubscriberMaxAggregateOutputType | null
  }

  type GetSubscriberGroupByPayload<T extends SubscriberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriberGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriberGroupByOutputType[P]>
        }
      >
    >


  export type SubscriberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    email?: boolean
    webhookUrl?: boolean
    confirmed?: boolean
    token?: boolean
    orgId?: boolean
    createdAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    alerts?: boolean | Subscriber$alertsArgs<ExtArgs>
    _count?: boolean | SubscriberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriber"]>

  export type SubscriberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    email?: boolean
    webhookUrl?: boolean
    confirmed?: boolean
    token?: boolean
    orgId?: boolean
    createdAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriber"]>

  export type SubscriberSelectScalar = {
    id?: boolean
    type?: boolean
    email?: boolean
    webhookUrl?: boolean
    confirmed?: boolean
    token?: boolean
    orgId?: boolean
    createdAt?: boolean
  }

  export type SubscriberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    alerts?: boolean | Subscriber$alertsArgs<ExtArgs>
    _count?: boolean | SubscriberCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $SubscriberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscriber"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      alerts: Prisma.$AlertPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.SubscriberType
      email: string | null
      webhookUrl: string | null
      confirmed: boolean
      token: string
      orgId: string
      createdAt: Date
    }, ExtArgs["result"]["subscriber"]>
    composites: {}
  }

  type SubscriberGetPayload<S extends boolean | null | undefined | SubscriberDefaultArgs> = $Result.GetResult<Prisma.$SubscriberPayload, S>

  type SubscriberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriberCountAggregateInputType | true
    }

  export interface SubscriberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscriber'], meta: { name: 'Subscriber' } }
    /**
     * Find zero or one Subscriber that matches the filter.
     * @param {SubscriberFindUniqueArgs} args - Arguments to find a Subscriber
     * @example
     * // Get one Subscriber
     * const subscriber = await prisma.subscriber.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriberFindUniqueArgs>(args: SelectSubset<T, SubscriberFindUniqueArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subscriber that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriberFindUniqueOrThrowArgs} args - Arguments to find a Subscriber
     * @example
     * // Get one Subscriber
     * const subscriber = await prisma.subscriber.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriberFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subscriber that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberFindFirstArgs} args - Arguments to find a Subscriber
     * @example
     * // Get one Subscriber
     * const subscriber = await prisma.subscriber.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriberFindFirstArgs>(args?: SelectSubset<T, SubscriberFindFirstArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subscriber that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberFindFirstOrThrowArgs} args - Arguments to find a Subscriber
     * @example
     * // Get one Subscriber
     * const subscriber = await prisma.subscriber.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriberFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriberFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subscribers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscribers
     * const subscribers = await prisma.subscriber.findMany()
     * 
     * // Get first 10 Subscribers
     * const subscribers = await prisma.subscriber.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriberWithIdOnly = await prisma.subscriber.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriberFindManyArgs>(args?: SelectSubset<T, SubscriberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subscriber.
     * @param {SubscriberCreateArgs} args - Arguments to create a Subscriber.
     * @example
     * // Create one Subscriber
     * const Subscriber = await prisma.subscriber.create({
     *   data: {
     *     // ... data to create a Subscriber
     *   }
     * })
     * 
     */
    create<T extends SubscriberCreateArgs>(args: SelectSubset<T, SubscriberCreateArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subscribers.
     * @param {SubscriberCreateManyArgs} args - Arguments to create many Subscribers.
     * @example
     * // Create many Subscribers
     * const subscriber = await prisma.subscriber.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriberCreateManyArgs>(args?: SelectSubset<T, SubscriberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscribers and returns the data saved in the database.
     * @param {SubscriberCreateManyAndReturnArgs} args - Arguments to create many Subscribers.
     * @example
     * // Create many Subscribers
     * const subscriber = await prisma.subscriber.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscribers and only return the `id`
     * const subscriberWithIdOnly = await prisma.subscriber.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriberCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Subscriber.
     * @param {SubscriberDeleteArgs} args - Arguments to delete one Subscriber.
     * @example
     * // Delete one Subscriber
     * const Subscriber = await prisma.subscriber.delete({
     *   where: {
     *     // ... filter to delete one Subscriber
     *   }
     * })
     * 
     */
    delete<T extends SubscriberDeleteArgs>(args: SelectSubset<T, SubscriberDeleteArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subscriber.
     * @param {SubscriberUpdateArgs} args - Arguments to update one Subscriber.
     * @example
     * // Update one Subscriber
     * const subscriber = await prisma.subscriber.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriberUpdateArgs>(args: SelectSubset<T, SubscriberUpdateArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subscribers.
     * @param {SubscriberDeleteManyArgs} args - Arguments to filter Subscribers to delete.
     * @example
     * // Delete a few Subscribers
     * const { count } = await prisma.subscriber.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriberDeleteManyArgs>(args?: SelectSubset<T, SubscriberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscribers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscribers
     * const subscriber = await prisma.subscriber.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriberUpdateManyArgs>(args: SelectSubset<T, SubscriberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscriber.
     * @param {SubscriberUpsertArgs} args - Arguments to update or create a Subscriber.
     * @example
     * // Update or create a Subscriber
     * const subscriber = await prisma.subscriber.upsert({
     *   create: {
     *     // ... data to create a Subscriber
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscriber we want to update
     *   }
     * })
     */
    upsert<T extends SubscriberUpsertArgs>(args: SelectSubset<T, SubscriberUpsertArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subscribers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberCountArgs} args - Arguments to filter Subscribers to count.
     * @example
     * // Count the number of Subscribers
     * const count = await prisma.subscriber.count({
     *   where: {
     *     // ... the filter for the Subscribers we want to count
     *   }
     * })
    **/
    count<T extends SubscriberCountArgs>(
      args?: Subset<T, SubscriberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscriber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriberAggregateArgs>(args: Subset<T, SubscriberAggregateArgs>): Prisma.PrismaPromise<GetSubscriberAggregateType<T>>

    /**
     * Group by Subscriber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriberGroupByArgs['orderBy'] }
        : { orderBy?: SubscriberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscriber model
   */
  readonly fields: SubscriberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscriber.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    alerts<T extends Subscriber$alertsArgs<ExtArgs> = {}>(args?: Subset<T, Subscriber$alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscriber model
   */ 
  interface SubscriberFieldRefs {
    readonly id: FieldRef<"Subscriber", 'String'>
    readonly type: FieldRef<"Subscriber", 'SubscriberType'>
    readonly email: FieldRef<"Subscriber", 'String'>
    readonly webhookUrl: FieldRef<"Subscriber", 'String'>
    readonly confirmed: FieldRef<"Subscriber", 'Boolean'>
    readonly token: FieldRef<"Subscriber", 'String'>
    readonly orgId: FieldRef<"Subscriber", 'String'>
    readonly createdAt: FieldRef<"Subscriber", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscriber findUnique
   */
  export type SubscriberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberInclude<ExtArgs> | null
    /**
     * Filter, which Subscriber to fetch.
     */
    where: SubscriberWhereUniqueInput
  }

  /**
   * Subscriber findUniqueOrThrow
   */
  export type SubscriberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberInclude<ExtArgs> | null
    /**
     * Filter, which Subscriber to fetch.
     */
    where: SubscriberWhereUniqueInput
  }

  /**
   * Subscriber findFirst
   */
  export type SubscriberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberInclude<ExtArgs> | null
    /**
     * Filter, which Subscriber to fetch.
     */
    where?: SubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscribers to fetch.
     */
    orderBy?: SubscriberOrderByWithRelationInput | SubscriberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscribers.
     */
    cursor?: SubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscribers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscribers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscribers.
     */
    distinct?: SubscriberScalarFieldEnum | SubscriberScalarFieldEnum[]
  }

  /**
   * Subscriber findFirstOrThrow
   */
  export type SubscriberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberInclude<ExtArgs> | null
    /**
     * Filter, which Subscriber to fetch.
     */
    where?: SubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscribers to fetch.
     */
    orderBy?: SubscriberOrderByWithRelationInput | SubscriberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscribers.
     */
    cursor?: SubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscribers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscribers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscribers.
     */
    distinct?: SubscriberScalarFieldEnum | SubscriberScalarFieldEnum[]
  }

  /**
   * Subscriber findMany
   */
  export type SubscriberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberInclude<ExtArgs> | null
    /**
     * Filter, which Subscribers to fetch.
     */
    where?: SubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscribers to fetch.
     */
    orderBy?: SubscriberOrderByWithRelationInput | SubscriberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscribers.
     */
    cursor?: SubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscribers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscribers.
     */
    skip?: number
    distinct?: SubscriberScalarFieldEnum | SubscriberScalarFieldEnum[]
  }

  /**
   * Subscriber create
   */
  export type SubscriberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscriber.
     */
    data: XOR<SubscriberCreateInput, SubscriberUncheckedCreateInput>
  }

  /**
   * Subscriber createMany
   */
  export type SubscriberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscribers.
     */
    data: SubscriberCreateManyInput | SubscriberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscriber createManyAndReturn
   */
  export type SubscriberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Subscribers.
     */
    data: SubscriberCreateManyInput | SubscriberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscriber update
   */
  export type SubscriberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscriber.
     */
    data: XOR<SubscriberUpdateInput, SubscriberUncheckedUpdateInput>
    /**
     * Choose, which Subscriber to update.
     */
    where: SubscriberWhereUniqueInput
  }

  /**
   * Subscriber updateMany
   */
  export type SubscriberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscribers.
     */
    data: XOR<SubscriberUpdateManyMutationInput, SubscriberUncheckedUpdateManyInput>
    /**
     * Filter which Subscribers to update
     */
    where?: SubscriberWhereInput
  }

  /**
   * Subscriber upsert
   */
  export type SubscriberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscriber to update in case it exists.
     */
    where: SubscriberWhereUniqueInput
    /**
     * In case the Subscriber found by the `where` argument doesn't exist, create a new Subscriber with this data.
     */
    create: XOR<SubscriberCreateInput, SubscriberUncheckedCreateInput>
    /**
     * In case the Subscriber was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriberUpdateInput, SubscriberUncheckedUpdateInput>
  }

  /**
   * Subscriber delete
   */
  export type SubscriberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberInclude<ExtArgs> | null
    /**
     * Filter which Subscriber to delete.
     */
    where: SubscriberWhereUniqueInput
  }

  /**
   * Subscriber deleteMany
   */
  export type SubscriberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscribers to delete
     */
    where?: SubscriberWhereInput
  }

  /**
   * Subscriber.alerts
   */
  export type Subscriber$alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Subscriber without action
   */
  export type SubscriberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriber
     */
    select?: SubscriberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriberInclude<ExtArgs> | null
  }


  /**
   * Model Alert
   */

  export type AggregateAlert = {
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  export type AlertMinAggregateOutputType = {
    id: string | null
    subscriberId: string | null
    incidentId: string | null
    subject: string | null
    body: string | null
    status: $Enums.AlertStatus | null
    sentAt: Date | null
    createdAt: Date | null
  }

  export type AlertMaxAggregateOutputType = {
    id: string | null
    subscriberId: string | null
    incidentId: string | null
    subject: string | null
    body: string | null
    status: $Enums.AlertStatus | null
    sentAt: Date | null
    createdAt: Date | null
  }

  export type AlertCountAggregateOutputType = {
    id: number
    subscriberId: number
    incidentId: number
    subject: number
    body: number
    status: number
    sentAt: number
    createdAt: number
    _all: number
  }


  export type AlertMinAggregateInputType = {
    id?: true
    subscriberId?: true
    incidentId?: true
    subject?: true
    body?: true
    status?: true
    sentAt?: true
    createdAt?: true
  }

  export type AlertMaxAggregateInputType = {
    id?: true
    subscriberId?: true
    incidentId?: true
    subject?: true
    body?: true
    status?: true
    sentAt?: true
    createdAt?: true
  }

  export type AlertCountAggregateInputType = {
    id?: true
    subscriberId?: true
    incidentId?: true
    subject?: true
    body?: true
    status?: true
    sentAt?: true
    createdAt?: true
    _all?: true
  }

  export type AlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alert to aggregate.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alerts
    **/
    _count?: true | AlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertMaxAggregateInputType
  }

  export type GetAlertAggregateType<T extends AlertAggregateArgs> = {
        [P in keyof T & keyof AggregateAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlert[P]>
      : GetScalarType<T[P], AggregateAlert[P]>
  }




  export type AlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithAggregationInput | AlertOrderByWithAggregationInput[]
    by: AlertScalarFieldEnum[] | AlertScalarFieldEnum
    having?: AlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertCountAggregateInputType | true
    _min?: AlertMinAggregateInputType
    _max?: AlertMaxAggregateInputType
  }

  export type AlertGroupByOutputType = {
    id: string
    subscriberId: string
    incidentId: string | null
    subject: string
    body: string
    status: $Enums.AlertStatus
    sentAt: Date | null
    createdAt: Date
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  type GetAlertGroupByPayload<T extends AlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertGroupByOutputType[P]>
            : GetScalarType<T[P], AlertGroupByOutputType[P]>
        }
      >
    >


  export type AlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriberId?: boolean
    incidentId?: boolean
    subject?: boolean
    body?: boolean
    status?: boolean
    sentAt?: boolean
    createdAt?: boolean
    subscriber?: boolean | SubscriberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriberId?: boolean
    incidentId?: boolean
    subject?: boolean
    body?: boolean
    status?: boolean
    sentAt?: boolean
    createdAt?: boolean
    subscriber?: boolean | SubscriberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectScalar = {
    id?: boolean
    subscriberId?: boolean
    incidentId?: boolean
    subject?: boolean
    body?: boolean
    status?: boolean
    sentAt?: boolean
    createdAt?: boolean
  }

  export type AlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriber?: boolean | SubscriberDefaultArgs<ExtArgs>
  }
  export type AlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriber?: boolean | SubscriberDefaultArgs<ExtArgs>
  }

  export type $AlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alert"
    objects: {
      subscriber: Prisma.$SubscriberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriberId: string
      incidentId: string | null
      subject: string
      body: string
      status: $Enums.AlertStatus
      sentAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["alert"]>
    composites: {}
  }

  type AlertGetPayload<S extends boolean | null | undefined | AlertDefaultArgs> = $Result.GetResult<Prisma.$AlertPayload, S>

  type AlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AlertFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlertCountAggregateInputType | true
    }

  export interface AlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alert'], meta: { name: 'Alert' } }
    /**
     * Find zero or one Alert that matches the filter.
     * @param {AlertFindUniqueArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertFindUniqueArgs>(args: SelectSubset<T, AlertFindUniqueArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Alert that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AlertFindUniqueOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Alert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertFindFirstArgs>(args?: SelectSubset<T, AlertFindFirstArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Alert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alerts
     * const alerts = await prisma.alert.findMany()
     * 
     * // Get first 10 Alerts
     * const alerts = await prisma.alert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertWithIdOnly = await prisma.alert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlertFindManyArgs>(args?: SelectSubset<T, AlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Alert.
     * @param {AlertCreateArgs} args - Arguments to create a Alert.
     * @example
     * // Create one Alert
     * const Alert = await prisma.alert.create({
     *   data: {
     *     // ... data to create a Alert
     *   }
     * })
     * 
     */
    create<T extends AlertCreateArgs>(args: SelectSubset<T, AlertCreateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Alerts.
     * @param {AlertCreateManyArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertCreateManyArgs>(args?: SelectSubset<T, AlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alerts and returns the data saved in the database.
     * @param {AlertCreateManyAndReturnArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alerts and only return the `id`
     * const alertWithIdOnly = await prisma.alert.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlertCreateManyAndReturnArgs>(args?: SelectSubset<T, AlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Alert.
     * @param {AlertDeleteArgs} args - Arguments to delete one Alert.
     * @example
     * // Delete one Alert
     * const Alert = await prisma.alert.delete({
     *   where: {
     *     // ... filter to delete one Alert
     *   }
     * })
     * 
     */
    delete<T extends AlertDeleteArgs>(args: SelectSubset<T, AlertDeleteArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Alert.
     * @param {AlertUpdateArgs} args - Arguments to update one Alert.
     * @example
     * // Update one Alert
     * const alert = await prisma.alert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertUpdateArgs>(args: SelectSubset<T, AlertUpdateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Alerts.
     * @param {AlertDeleteManyArgs} args - Arguments to filter Alerts to delete.
     * @example
     * // Delete a few Alerts
     * const { count } = await prisma.alert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertDeleteManyArgs>(args?: SelectSubset<T, AlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertUpdateManyArgs>(args: SelectSubset<T, AlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alert.
     * @param {AlertUpsertArgs} args - Arguments to update or create a Alert.
     * @example
     * // Update or create a Alert
     * const alert = await prisma.alert.upsert({
     *   create: {
     *     // ... data to create a Alert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alert we want to update
     *   }
     * })
     */
    upsert<T extends AlertUpsertArgs>(args: SelectSubset<T, AlertUpsertArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertCountArgs} args - Arguments to filter Alerts to count.
     * @example
     * // Count the number of Alerts
     * const count = await prisma.alert.count({
     *   where: {
     *     // ... the filter for the Alerts we want to count
     *   }
     * })
    **/
    count<T extends AlertCountArgs>(
      args?: Subset<T, AlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertAggregateArgs>(args: Subset<T, AlertAggregateArgs>): Prisma.PrismaPromise<GetAlertAggregateType<T>>

    /**
     * Group by Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertGroupByArgs['orderBy'] }
        : { orderBy?: AlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alert model
   */
  readonly fields: AlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriber<T extends SubscriberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriberDefaultArgs<ExtArgs>>): Prisma__SubscriberClient<$Result.GetResult<Prisma.$SubscriberPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Alert model
   */ 
  interface AlertFieldRefs {
    readonly id: FieldRef<"Alert", 'String'>
    readonly subscriberId: FieldRef<"Alert", 'String'>
    readonly incidentId: FieldRef<"Alert", 'String'>
    readonly subject: FieldRef<"Alert", 'String'>
    readonly body: FieldRef<"Alert", 'String'>
    readonly status: FieldRef<"Alert", 'AlertStatus'>
    readonly sentAt: FieldRef<"Alert", 'DateTime'>
    readonly createdAt: FieldRef<"Alert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Alert findUnique
   */
  export type AlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findUniqueOrThrow
   */
  export type AlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findFirst
   */
  export type AlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findFirstOrThrow
   */
  export type AlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findMany
   */
  export type AlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alerts to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert create
   */
  export type AlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to create a Alert.
     */
    data: XOR<AlertCreateInput, AlertUncheckedCreateInput>
  }

  /**
   * Alert createMany
   */
  export type AlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alert createManyAndReturn
   */
  export type AlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Alert update
   */
  export type AlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to update a Alert.
     */
    data: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
    /**
     * Choose, which Alert to update.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert updateMany
   */
  export type AlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alerts.
     */
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyInput>
    /**
     * Filter which Alerts to update
     */
    where?: AlertWhereInput
  }

  /**
   * Alert upsert
   */
  export type AlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The filter to search for the Alert to update in case it exists.
     */
    where: AlertWhereUniqueInput
    /**
     * In case the Alert found by the `where` argument doesn't exist, create a new Alert with this data.
     */
    create: XOR<AlertCreateInput, AlertUncheckedCreateInput>
    /**
     * In case the Alert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
  }

  /**
   * Alert delete
   */
  export type AlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter which Alert to delete.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert deleteMany
   */
  export type AlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alerts to delete
     */
    where?: AlertWhereInput
  }

  /**
   * Alert without action
   */
  export type AlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
  }


  /**
   * Model NotificationChannel
   */

  export type AggregateNotificationChannel = {
    _count: NotificationChannelCountAggregateOutputType | null
    _min: NotificationChannelMinAggregateOutputType | null
    _max: NotificationChannelMaxAggregateOutputType | null
  }

  export type NotificationChannelMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.NotificationChannelType | null
    enabled: boolean | null
    orgId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationChannelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.NotificationChannelType | null
    enabled: boolean | null
    orgId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationChannelCountAggregateOutputType = {
    id: number
    name: number
    type: number
    config: number
    enabled: number
    orgId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationChannelMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    enabled?: true
    orgId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationChannelMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    enabled?: true
    orgId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationChannelCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    config?: true
    enabled?: true
    orgId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationChannelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationChannel to aggregate.
     */
    where?: NotificationChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationChannels to fetch.
     */
    orderBy?: NotificationChannelOrderByWithRelationInput | NotificationChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationChannels
    **/
    _count?: true | NotificationChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationChannelMaxAggregateInputType
  }

  export type GetNotificationChannelAggregateType<T extends NotificationChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationChannel[P]>
      : GetScalarType<T[P], AggregateNotificationChannel[P]>
  }




  export type NotificationChannelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationChannelWhereInput
    orderBy?: NotificationChannelOrderByWithAggregationInput | NotificationChannelOrderByWithAggregationInput[]
    by: NotificationChannelScalarFieldEnum[] | NotificationChannelScalarFieldEnum
    having?: NotificationChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationChannelCountAggregateInputType | true
    _min?: NotificationChannelMinAggregateInputType
    _max?: NotificationChannelMaxAggregateInputType
  }

  export type NotificationChannelGroupByOutputType = {
    id: string
    name: string
    type: $Enums.NotificationChannelType
    config: JsonValue
    enabled: boolean
    orgId: string
    createdAt: Date
    updatedAt: Date
    _count: NotificationChannelCountAggregateOutputType | null
    _min: NotificationChannelMinAggregateOutputType | null
    _max: NotificationChannelMaxAggregateOutputType | null
  }

  type GetNotificationChannelGroupByPayload<T extends NotificationChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationChannelGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationChannelGroupByOutputType[P]>
        }
      >
    >


  export type NotificationChannelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    config?: boolean
    enabled?: boolean
    orgId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationChannel"]>

  export type NotificationChannelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    config?: boolean
    enabled?: boolean
    orgId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationChannel"]>

  export type NotificationChannelSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    config?: boolean
    enabled?: boolean
    orgId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationChannelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type NotificationChannelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $NotificationChannelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationChannel"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.NotificationChannelType
      config: Prisma.JsonValue
      enabled: boolean
      orgId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationChannel"]>
    composites: {}
  }

  type NotificationChannelGetPayload<S extends boolean | null | undefined | NotificationChannelDefaultArgs> = $Result.GetResult<Prisma.$NotificationChannelPayload, S>

  type NotificationChannelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationChannelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationChannelCountAggregateInputType | true
    }

  export interface NotificationChannelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationChannel'], meta: { name: 'NotificationChannel' } }
    /**
     * Find zero or one NotificationChannel that matches the filter.
     * @param {NotificationChannelFindUniqueArgs} args - Arguments to find a NotificationChannel
     * @example
     * // Get one NotificationChannel
     * const notificationChannel = await prisma.notificationChannel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationChannelFindUniqueArgs>(args: SelectSubset<T, NotificationChannelFindUniqueArgs<ExtArgs>>): Prisma__NotificationChannelClient<$Result.GetResult<Prisma.$NotificationChannelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NotificationChannel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationChannelFindUniqueOrThrowArgs} args - Arguments to find a NotificationChannel
     * @example
     * // Get one NotificationChannel
     * const notificationChannel = await prisma.notificationChannel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationChannelFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationChannelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationChannelClient<$Result.GetResult<Prisma.$NotificationChannelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NotificationChannel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationChannelFindFirstArgs} args - Arguments to find a NotificationChannel
     * @example
     * // Get one NotificationChannel
     * const notificationChannel = await prisma.notificationChannel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationChannelFindFirstArgs>(args?: SelectSubset<T, NotificationChannelFindFirstArgs<ExtArgs>>): Prisma__NotificationChannelClient<$Result.GetResult<Prisma.$NotificationChannelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NotificationChannel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationChannelFindFirstOrThrowArgs} args - Arguments to find a NotificationChannel
     * @example
     * // Get one NotificationChannel
     * const notificationChannel = await prisma.notificationChannel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationChannelFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationChannelFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationChannelClient<$Result.GetResult<Prisma.$NotificationChannelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NotificationChannels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationChannelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationChannels
     * const notificationChannels = await prisma.notificationChannel.findMany()
     * 
     * // Get first 10 NotificationChannels
     * const notificationChannels = await prisma.notificationChannel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationChannelWithIdOnly = await prisma.notificationChannel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationChannelFindManyArgs>(args?: SelectSubset<T, NotificationChannelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationChannelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NotificationChannel.
     * @param {NotificationChannelCreateArgs} args - Arguments to create a NotificationChannel.
     * @example
     * // Create one NotificationChannel
     * const NotificationChannel = await prisma.notificationChannel.create({
     *   data: {
     *     // ... data to create a NotificationChannel
     *   }
     * })
     * 
     */
    create<T extends NotificationChannelCreateArgs>(args: SelectSubset<T, NotificationChannelCreateArgs<ExtArgs>>): Prisma__NotificationChannelClient<$Result.GetResult<Prisma.$NotificationChannelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NotificationChannels.
     * @param {NotificationChannelCreateManyArgs} args - Arguments to create many NotificationChannels.
     * @example
     * // Create many NotificationChannels
     * const notificationChannel = await prisma.notificationChannel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationChannelCreateManyArgs>(args?: SelectSubset<T, NotificationChannelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationChannels and returns the data saved in the database.
     * @param {NotificationChannelCreateManyAndReturnArgs} args - Arguments to create many NotificationChannels.
     * @example
     * // Create many NotificationChannels
     * const notificationChannel = await prisma.notificationChannel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationChannels and only return the `id`
     * const notificationChannelWithIdOnly = await prisma.notificationChannel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationChannelCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationChannelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationChannelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NotificationChannel.
     * @param {NotificationChannelDeleteArgs} args - Arguments to delete one NotificationChannel.
     * @example
     * // Delete one NotificationChannel
     * const NotificationChannel = await prisma.notificationChannel.delete({
     *   where: {
     *     // ... filter to delete one NotificationChannel
     *   }
     * })
     * 
     */
    delete<T extends NotificationChannelDeleteArgs>(args: SelectSubset<T, NotificationChannelDeleteArgs<ExtArgs>>): Prisma__NotificationChannelClient<$Result.GetResult<Prisma.$NotificationChannelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NotificationChannel.
     * @param {NotificationChannelUpdateArgs} args - Arguments to update one NotificationChannel.
     * @example
     * // Update one NotificationChannel
     * const notificationChannel = await prisma.notificationChannel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationChannelUpdateArgs>(args: SelectSubset<T, NotificationChannelUpdateArgs<ExtArgs>>): Prisma__NotificationChannelClient<$Result.GetResult<Prisma.$NotificationChannelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NotificationChannels.
     * @param {NotificationChannelDeleteManyArgs} args - Arguments to filter NotificationChannels to delete.
     * @example
     * // Delete a few NotificationChannels
     * const { count } = await prisma.notificationChannel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationChannelDeleteManyArgs>(args?: SelectSubset<T, NotificationChannelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationChannels
     * const notificationChannel = await prisma.notificationChannel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationChannelUpdateManyArgs>(args: SelectSubset<T, NotificationChannelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationChannel.
     * @param {NotificationChannelUpsertArgs} args - Arguments to update or create a NotificationChannel.
     * @example
     * // Update or create a NotificationChannel
     * const notificationChannel = await prisma.notificationChannel.upsert({
     *   create: {
     *     // ... data to create a NotificationChannel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationChannel we want to update
     *   }
     * })
     */
    upsert<T extends NotificationChannelUpsertArgs>(args: SelectSubset<T, NotificationChannelUpsertArgs<ExtArgs>>): Prisma__NotificationChannelClient<$Result.GetResult<Prisma.$NotificationChannelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NotificationChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationChannelCountArgs} args - Arguments to filter NotificationChannels to count.
     * @example
     * // Count the number of NotificationChannels
     * const count = await prisma.notificationChannel.count({
     *   where: {
     *     // ... the filter for the NotificationChannels we want to count
     *   }
     * })
    **/
    count<T extends NotificationChannelCountArgs>(
      args?: Subset<T, NotificationChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationChannelAggregateArgs>(args: Subset<T, NotificationChannelAggregateArgs>): Prisma.PrismaPromise<GetNotificationChannelAggregateType<T>>

    /**
     * Group by NotificationChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationChannelGroupByArgs['orderBy'] }
        : { orderBy?: NotificationChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationChannel model
   */
  readonly fields: NotificationChannelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationChannel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationChannelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationChannel model
   */ 
  interface NotificationChannelFieldRefs {
    readonly id: FieldRef<"NotificationChannel", 'String'>
    readonly name: FieldRef<"NotificationChannel", 'String'>
    readonly type: FieldRef<"NotificationChannel", 'NotificationChannelType'>
    readonly config: FieldRef<"NotificationChannel", 'Json'>
    readonly enabled: FieldRef<"NotificationChannel", 'Boolean'>
    readonly orgId: FieldRef<"NotificationChannel", 'String'>
    readonly createdAt: FieldRef<"NotificationChannel", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationChannel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationChannel findUnique
   */
  export type NotificationChannelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationChannel
     */
    select?: NotificationChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationChannelInclude<ExtArgs> | null
    /**
     * Filter, which NotificationChannel to fetch.
     */
    where: NotificationChannelWhereUniqueInput
  }

  /**
   * NotificationChannel findUniqueOrThrow
   */
  export type NotificationChannelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationChannel
     */
    select?: NotificationChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationChannelInclude<ExtArgs> | null
    /**
     * Filter, which NotificationChannel to fetch.
     */
    where: NotificationChannelWhereUniqueInput
  }

  /**
   * NotificationChannel findFirst
   */
  export type NotificationChannelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationChannel
     */
    select?: NotificationChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationChannelInclude<ExtArgs> | null
    /**
     * Filter, which NotificationChannel to fetch.
     */
    where?: NotificationChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationChannels to fetch.
     */
    orderBy?: NotificationChannelOrderByWithRelationInput | NotificationChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationChannels.
     */
    cursor?: NotificationChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationChannels.
     */
    distinct?: NotificationChannelScalarFieldEnum | NotificationChannelScalarFieldEnum[]
  }

  /**
   * NotificationChannel findFirstOrThrow
   */
  export type NotificationChannelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationChannel
     */
    select?: NotificationChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationChannelInclude<ExtArgs> | null
    /**
     * Filter, which NotificationChannel to fetch.
     */
    where?: NotificationChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationChannels to fetch.
     */
    orderBy?: NotificationChannelOrderByWithRelationInput | NotificationChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationChannels.
     */
    cursor?: NotificationChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationChannels.
     */
    distinct?: NotificationChannelScalarFieldEnum | NotificationChannelScalarFieldEnum[]
  }

  /**
   * NotificationChannel findMany
   */
  export type NotificationChannelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationChannel
     */
    select?: NotificationChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationChannelInclude<ExtArgs> | null
    /**
     * Filter, which NotificationChannels to fetch.
     */
    where?: NotificationChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationChannels to fetch.
     */
    orderBy?: NotificationChannelOrderByWithRelationInput | NotificationChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationChannels.
     */
    cursor?: NotificationChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationChannels.
     */
    skip?: number
    distinct?: NotificationChannelScalarFieldEnum | NotificationChannelScalarFieldEnum[]
  }

  /**
   * NotificationChannel create
   */
  export type NotificationChannelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationChannel
     */
    select?: NotificationChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationChannelInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationChannel.
     */
    data: XOR<NotificationChannelCreateInput, NotificationChannelUncheckedCreateInput>
  }

  /**
   * NotificationChannel createMany
   */
  export type NotificationChannelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationChannels.
     */
    data: NotificationChannelCreateManyInput | NotificationChannelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationChannel createManyAndReturn
   */
  export type NotificationChannelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationChannel
     */
    select?: NotificationChannelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NotificationChannels.
     */
    data: NotificationChannelCreateManyInput | NotificationChannelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationChannelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationChannel update
   */
  export type NotificationChannelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationChannel
     */
    select?: NotificationChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationChannelInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationChannel.
     */
    data: XOR<NotificationChannelUpdateInput, NotificationChannelUncheckedUpdateInput>
    /**
     * Choose, which NotificationChannel to update.
     */
    where: NotificationChannelWhereUniqueInput
  }

  /**
   * NotificationChannel updateMany
   */
  export type NotificationChannelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationChannels.
     */
    data: XOR<NotificationChannelUpdateManyMutationInput, NotificationChannelUncheckedUpdateManyInput>
    /**
     * Filter which NotificationChannels to update
     */
    where?: NotificationChannelWhereInput
  }

  /**
   * NotificationChannel upsert
   */
  export type NotificationChannelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationChannel
     */
    select?: NotificationChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationChannelInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationChannel to update in case it exists.
     */
    where: NotificationChannelWhereUniqueInput
    /**
     * In case the NotificationChannel found by the `where` argument doesn't exist, create a new NotificationChannel with this data.
     */
    create: XOR<NotificationChannelCreateInput, NotificationChannelUncheckedCreateInput>
    /**
     * In case the NotificationChannel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationChannelUpdateInput, NotificationChannelUncheckedUpdateInput>
  }

  /**
   * NotificationChannel delete
   */
  export type NotificationChannelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationChannel
     */
    select?: NotificationChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationChannelInclude<ExtArgs> | null
    /**
     * Filter which NotificationChannel to delete.
     */
    where: NotificationChannelWhereUniqueInput
  }

  /**
   * NotificationChannel deleteMany
   */
  export type NotificationChannelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationChannels to delete
     */
    where?: NotificationChannelWhereInput
  }

  /**
   * NotificationChannel without action
   */
  export type NotificationChannelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationChannel
     */
    select?: NotificationChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationChannelInclude<ExtArgs> | null
  }


  /**
   * Model ApiKey
   */

  export type AggregateApiKey = {
    _count: ApiKeyCountAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  export type ApiKeyMinAggregateOutputType = {
    id: string | null
    name: string | null
    key: string | null
    orgId: string | null
    expiresAt: Date | null
    lastUsedAt: Date | null
    createdAt: Date | null
  }

  export type ApiKeyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    key: string | null
    orgId: string | null
    expiresAt: Date | null
    lastUsedAt: Date | null
    createdAt: Date | null
  }

  export type ApiKeyCountAggregateOutputType = {
    id: number
    name: number
    key: number
    orgId: number
    expiresAt: number
    lastUsedAt: number
    createdAt: number
    _all: number
  }


  export type ApiKeyMinAggregateInputType = {
    id?: true
    name?: true
    key?: true
    orgId?: true
    expiresAt?: true
    lastUsedAt?: true
    createdAt?: true
  }

  export type ApiKeyMaxAggregateInputType = {
    id?: true
    name?: true
    key?: true
    orgId?: true
    expiresAt?: true
    lastUsedAt?: true
    createdAt?: true
  }

  export type ApiKeyCountAggregateInputType = {
    id?: true
    name?: true
    key?: true
    orgId?: true
    expiresAt?: true
    lastUsedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ApiKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKey to aggregate.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeys
    **/
    _count?: true | ApiKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeyMaxAggregateInputType
  }

  export type GetApiKeyAggregateType<T extends ApiKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKey[P]>
      : GetScalarType<T[P], AggregateApiKey[P]>
  }




  export type ApiKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithAggregationInput | ApiKeyOrderByWithAggregationInput[]
    by: ApiKeyScalarFieldEnum[] | ApiKeyScalarFieldEnum
    having?: ApiKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeyCountAggregateInputType | true
    _min?: ApiKeyMinAggregateInputType
    _max?: ApiKeyMaxAggregateInputType
  }

  export type ApiKeyGroupByOutputType = {
    id: string
    name: string
    key: string
    orgId: string
    expiresAt: Date | null
    lastUsedAt: Date | null
    createdAt: Date
    _count: ApiKeyCountAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  type GetApiKeyGroupByPayload<T extends ApiKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    key?: boolean
    orgId?: boolean
    expiresAt?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    key?: boolean
    orgId?: boolean
    expiresAt?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectScalar = {
    id?: boolean
    name?: boolean
    key?: boolean
    orgId?: boolean
    expiresAt?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
  }

  export type ApiKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type ApiKeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $ApiKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiKey"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      key: string
      orgId: string
      expiresAt: Date | null
      lastUsedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["apiKey"]>
    composites: {}
  }

  type ApiKeyGetPayload<S extends boolean | null | undefined | ApiKeyDefaultArgs> = $Result.GetResult<Prisma.$ApiKeyPayload, S>

  type ApiKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApiKeyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApiKeyCountAggregateInputType | true
    }

  export interface ApiKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKey'], meta: { name: 'ApiKey' } }
    /**
     * Find zero or one ApiKey that matches the filter.
     * @param {ApiKeyFindUniqueArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiKeyFindUniqueArgs>(args: SelectSubset<T, ApiKeyFindUniqueArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApiKey that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApiKeyFindUniqueOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApiKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiKeyFindFirstArgs>(args?: SelectSubset<T, ApiKeyFindFirstArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApiKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApiKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeys
     * const apiKeys = await prisma.apiKey.findMany()
     * 
     * // Get first 10 ApiKeys
     * const apiKeys = await prisma.apiKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiKeyFindManyArgs>(args?: SelectSubset<T, ApiKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApiKey.
     * @param {ApiKeyCreateArgs} args - Arguments to create a ApiKey.
     * @example
     * // Create one ApiKey
     * const ApiKey = await prisma.apiKey.create({
     *   data: {
     *     // ... data to create a ApiKey
     *   }
     * })
     * 
     */
    create<T extends ApiKeyCreateArgs>(args: SelectSubset<T, ApiKeyCreateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApiKeys.
     * @param {ApiKeyCreateManyArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiKeyCreateManyArgs>(args?: SelectSubset<T, ApiKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiKeys and returns the data saved in the database.
     * @param {ApiKeyCreateManyAndReturnArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApiKey.
     * @param {ApiKeyDeleteArgs} args - Arguments to delete one ApiKey.
     * @example
     * // Delete one ApiKey
     * const ApiKey = await prisma.apiKey.delete({
     *   where: {
     *     // ... filter to delete one ApiKey
     *   }
     * })
     * 
     */
    delete<T extends ApiKeyDeleteArgs>(args: SelectSubset<T, ApiKeyDeleteArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApiKey.
     * @param {ApiKeyUpdateArgs} args - Arguments to update one ApiKey.
     * @example
     * // Update one ApiKey
     * const apiKey = await prisma.apiKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiKeyUpdateArgs>(args: SelectSubset<T, ApiKeyUpdateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApiKeys.
     * @param {ApiKeyDeleteManyArgs} args - Arguments to filter ApiKeys to delete.
     * @example
     * // Delete a few ApiKeys
     * const { count } = await prisma.apiKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiKeyDeleteManyArgs>(args?: SelectSubset<T, ApiKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiKeyUpdateManyArgs>(args: SelectSubset<T, ApiKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApiKey.
     * @param {ApiKeyUpsertArgs} args - Arguments to update or create a ApiKey.
     * @example
     * // Update or create a ApiKey
     * const apiKey = await prisma.apiKey.upsert({
     *   create: {
     *     // ... data to create a ApiKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKey we want to update
     *   }
     * })
     */
    upsert<T extends ApiKeyUpsertArgs>(args: SelectSubset<T, ApiKeyUpsertArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyCountArgs} args - Arguments to filter ApiKeys to count.
     * @example
     * // Count the number of ApiKeys
     * const count = await prisma.apiKey.count({
     *   where: {
     *     // ... the filter for the ApiKeys we want to count
     *   }
     * })
    **/
    count<T extends ApiKeyCountArgs>(
      args?: Subset<T, ApiKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeyAggregateArgs>(args: Subset<T, ApiKeyAggregateArgs>): Prisma.PrismaPromise<GetApiKeyAggregateType<T>>

    /**
     * Group by ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKey model
   */
  readonly fields: ApiKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiKey model
   */ 
  interface ApiKeyFieldRefs {
    readonly id: FieldRef<"ApiKey", 'String'>
    readonly name: FieldRef<"ApiKey", 'String'>
    readonly key: FieldRef<"ApiKey", 'String'>
    readonly orgId: FieldRef<"ApiKey", 'String'>
    readonly expiresAt: FieldRef<"ApiKey", 'DateTime'>
    readonly lastUsedAt: FieldRef<"ApiKey", 'DateTime'>
    readonly createdAt: FieldRef<"ApiKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiKey findUnique
   */
  export type ApiKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findUniqueOrThrow
   */
  export type ApiKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findFirst
   */
  export type ApiKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findFirstOrThrow
   */
  export type ApiKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findMany
   */
  export type ApiKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeys to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey create
   */
  export type ApiKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiKey.
     */
    data: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
  }

  /**
   * ApiKey createMany
   */
  export type ApiKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiKey createManyAndReturn
   */
  export type ApiKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKey update
   */
  export type ApiKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiKey.
     */
    data: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
    /**
     * Choose, which ApiKey to update.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey updateMany
   */
  export type ApiKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
  }

  /**
   * ApiKey upsert
   */
  export type ApiKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiKey to update in case it exists.
     */
    where: ApiKeyWhereUniqueInput
    /**
     * In case the ApiKey found by the `where` argument doesn't exist, create a new ApiKey with this data.
     */
    create: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
    /**
     * In case the ApiKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
  }

  /**
   * ApiKey delete
   */
  export type ApiKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter which ApiKey to delete.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey deleteMany
   */
  export type ApiKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeys to delete
     */
    where?: ApiKeyWhereInput
  }

  /**
   * ApiKey without action
   */
  export type ApiKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
  }


  /**
   * Model StatusPageConfig
   */

  export type AggregateStatusPageConfig = {
    _count: StatusPageConfigCountAggregateOutputType | null
    _min: StatusPageConfigMinAggregateOutputType | null
    _max: StatusPageConfigMaxAggregateOutputType | null
  }

  export type StatusPageConfigMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    title: string | null
    description: string | null
    logoUrl: string | null
    faviconUrl: string | null
    customDomain: string | null
    customCss: string | null
    showUptime: boolean | null
    showResponseTime: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StatusPageConfigMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    title: string | null
    description: string | null
    logoUrl: string | null
    faviconUrl: string | null
    customDomain: string | null
    customCss: string | null
    showUptime: boolean | null
    showResponseTime: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StatusPageConfigCountAggregateOutputType = {
    id: number
    orgId: number
    title: number
    description: number
    logoUrl: number
    faviconUrl: number
    customDomain: number
    customCss: number
    showUptime: number
    showResponseTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StatusPageConfigMinAggregateInputType = {
    id?: true
    orgId?: true
    title?: true
    description?: true
    logoUrl?: true
    faviconUrl?: true
    customDomain?: true
    customCss?: true
    showUptime?: true
    showResponseTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StatusPageConfigMaxAggregateInputType = {
    id?: true
    orgId?: true
    title?: true
    description?: true
    logoUrl?: true
    faviconUrl?: true
    customDomain?: true
    customCss?: true
    showUptime?: true
    showResponseTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StatusPageConfigCountAggregateInputType = {
    id?: true
    orgId?: true
    title?: true
    description?: true
    logoUrl?: true
    faviconUrl?: true
    customDomain?: true
    customCss?: true
    showUptime?: true
    showResponseTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StatusPageConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatusPageConfig to aggregate.
     */
    where?: StatusPageConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusPageConfigs to fetch.
     */
    orderBy?: StatusPageConfigOrderByWithRelationInput | StatusPageConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StatusPageConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusPageConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusPageConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StatusPageConfigs
    **/
    _count?: true | StatusPageConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatusPageConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatusPageConfigMaxAggregateInputType
  }

  export type GetStatusPageConfigAggregateType<T extends StatusPageConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateStatusPageConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatusPageConfig[P]>
      : GetScalarType<T[P], AggregateStatusPageConfig[P]>
  }




  export type StatusPageConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatusPageConfigWhereInput
    orderBy?: StatusPageConfigOrderByWithAggregationInput | StatusPageConfigOrderByWithAggregationInput[]
    by: StatusPageConfigScalarFieldEnum[] | StatusPageConfigScalarFieldEnum
    having?: StatusPageConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatusPageConfigCountAggregateInputType | true
    _min?: StatusPageConfigMinAggregateInputType
    _max?: StatusPageConfigMaxAggregateInputType
  }

  export type StatusPageConfigGroupByOutputType = {
    id: string
    orgId: string
    title: string
    description: string | null
    logoUrl: string | null
    faviconUrl: string | null
    customDomain: string | null
    customCss: string | null
    showUptime: boolean
    showResponseTime: boolean
    createdAt: Date
    updatedAt: Date
    _count: StatusPageConfigCountAggregateOutputType | null
    _min: StatusPageConfigMinAggregateOutputType | null
    _max: StatusPageConfigMaxAggregateOutputType | null
  }

  type GetStatusPageConfigGroupByPayload<T extends StatusPageConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatusPageConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatusPageConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatusPageConfigGroupByOutputType[P]>
            : GetScalarType<T[P], StatusPageConfigGroupByOutputType[P]>
        }
      >
    >


  export type StatusPageConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    title?: boolean
    description?: boolean
    logoUrl?: boolean
    faviconUrl?: boolean
    customDomain?: boolean
    customCss?: boolean
    showUptime?: boolean
    showResponseTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statusPageConfig"]>

  export type StatusPageConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    title?: boolean
    description?: boolean
    logoUrl?: boolean
    faviconUrl?: boolean
    customDomain?: boolean
    customCss?: boolean
    showUptime?: boolean
    showResponseTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statusPageConfig"]>

  export type StatusPageConfigSelectScalar = {
    id?: boolean
    orgId?: boolean
    title?: boolean
    description?: boolean
    logoUrl?: boolean
    faviconUrl?: boolean
    customDomain?: boolean
    customCss?: boolean
    showUptime?: boolean
    showResponseTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StatusPageConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type StatusPageConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $StatusPageConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StatusPageConfig"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      title: string
      description: string | null
      logoUrl: string | null
      faviconUrl: string | null
      customDomain: string | null
      customCss: string | null
      showUptime: boolean
      showResponseTime: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["statusPageConfig"]>
    composites: {}
  }

  type StatusPageConfigGetPayload<S extends boolean | null | undefined | StatusPageConfigDefaultArgs> = $Result.GetResult<Prisma.$StatusPageConfigPayload, S>

  type StatusPageConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StatusPageConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StatusPageConfigCountAggregateInputType | true
    }

  export interface StatusPageConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StatusPageConfig'], meta: { name: 'StatusPageConfig' } }
    /**
     * Find zero or one StatusPageConfig that matches the filter.
     * @param {StatusPageConfigFindUniqueArgs} args - Arguments to find a StatusPageConfig
     * @example
     * // Get one StatusPageConfig
     * const statusPageConfig = await prisma.statusPageConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StatusPageConfigFindUniqueArgs>(args: SelectSubset<T, StatusPageConfigFindUniqueArgs<ExtArgs>>): Prisma__StatusPageConfigClient<$Result.GetResult<Prisma.$StatusPageConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StatusPageConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StatusPageConfigFindUniqueOrThrowArgs} args - Arguments to find a StatusPageConfig
     * @example
     * // Get one StatusPageConfig
     * const statusPageConfig = await prisma.statusPageConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StatusPageConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, StatusPageConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StatusPageConfigClient<$Result.GetResult<Prisma.$StatusPageConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StatusPageConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusPageConfigFindFirstArgs} args - Arguments to find a StatusPageConfig
     * @example
     * // Get one StatusPageConfig
     * const statusPageConfig = await prisma.statusPageConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StatusPageConfigFindFirstArgs>(args?: SelectSubset<T, StatusPageConfigFindFirstArgs<ExtArgs>>): Prisma__StatusPageConfigClient<$Result.GetResult<Prisma.$StatusPageConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StatusPageConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusPageConfigFindFirstOrThrowArgs} args - Arguments to find a StatusPageConfig
     * @example
     * // Get one StatusPageConfig
     * const statusPageConfig = await prisma.statusPageConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StatusPageConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, StatusPageConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__StatusPageConfigClient<$Result.GetResult<Prisma.$StatusPageConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StatusPageConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusPageConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StatusPageConfigs
     * const statusPageConfigs = await prisma.statusPageConfig.findMany()
     * 
     * // Get first 10 StatusPageConfigs
     * const statusPageConfigs = await prisma.statusPageConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statusPageConfigWithIdOnly = await prisma.statusPageConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StatusPageConfigFindManyArgs>(args?: SelectSubset<T, StatusPageConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatusPageConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StatusPageConfig.
     * @param {StatusPageConfigCreateArgs} args - Arguments to create a StatusPageConfig.
     * @example
     * // Create one StatusPageConfig
     * const StatusPageConfig = await prisma.statusPageConfig.create({
     *   data: {
     *     // ... data to create a StatusPageConfig
     *   }
     * })
     * 
     */
    create<T extends StatusPageConfigCreateArgs>(args: SelectSubset<T, StatusPageConfigCreateArgs<ExtArgs>>): Prisma__StatusPageConfigClient<$Result.GetResult<Prisma.$StatusPageConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StatusPageConfigs.
     * @param {StatusPageConfigCreateManyArgs} args - Arguments to create many StatusPageConfigs.
     * @example
     * // Create many StatusPageConfigs
     * const statusPageConfig = await prisma.statusPageConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StatusPageConfigCreateManyArgs>(args?: SelectSubset<T, StatusPageConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StatusPageConfigs and returns the data saved in the database.
     * @param {StatusPageConfigCreateManyAndReturnArgs} args - Arguments to create many StatusPageConfigs.
     * @example
     * // Create many StatusPageConfigs
     * const statusPageConfig = await prisma.statusPageConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StatusPageConfigs and only return the `id`
     * const statusPageConfigWithIdOnly = await prisma.statusPageConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StatusPageConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, StatusPageConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatusPageConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StatusPageConfig.
     * @param {StatusPageConfigDeleteArgs} args - Arguments to delete one StatusPageConfig.
     * @example
     * // Delete one StatusPageConfig
     * const StatusPageConfig = await prisma.statusPageConfig.delete({
     *   where: {
     *     // ... filter to delete one StatusPageConfig
     *   }
     * })
     * 
     */
    delete<T extends StatusPageConfigDeleteArgs>(args: SelectSubset<T, StatusPageConfigDeleteArgs<ExtArgs>>): Prisma__StatusPageConfigClient<$Result.GetResult<Prisma.$StatusPageConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StatusPageConfig.
     * @param {StatusPageConfigUpdateArgs} args - Arguments to update one StatusPageConfig.
     * @example
     * // Update one StatusPageConfig
     * const statusPageConfig = await prisma.statusPageConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StatusPageConfigUpdateArgs>(args: SelectSubset<T, StatusPageConfigUpdateArgs<ExtArgs>>): Prisma__StatusPageConfigClient<$Result.GetResult<Prisma.$StatusPageConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StatusPageConfigs.
     * @param {StatusPageConfigDeleteManyArgs} args - Arguments to filter StatusPageConfigs to delete.
     * @example
     * // Delete a few StatusPageConfigs
     * const { count } = await prisma.statusPageConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StatusPageConfigDeleteManyArgs>(args?: SelectSubset<T, StatusPageConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StatusPageConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusPageConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StatusPageConfigs
     * const statusPageConfig = await prisma.statusPageConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StatusPageConfigUpdateManyArgs>(args: SelectSubset<T, StatusPageConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StatusPageConfig.
     * @param {StatusPageConfigUpsertArgs} args - Arguments to update or create a StatusPageConfig.
     * @example
     * // Update or create a StatusPageConfig
     * const statusPageConfig = await prisma.statusPageConfig.upsert({
     *   create: {
     *     // ... data to create a StatusPageConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StatusPageConfig we want to update
     *   }
     * })
     */
    upsert<T extends StatusPageConfigUpsertArgs>(args: SelectSubset<T, StatusPageConfigUpsertArgs<ExtArgs>>): Prisma__StatusPageConfigClient<$Result.GetResult<Prisma.$StatusPageConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StatusPageConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusPageConfigCountArgs} args - Arguments to filter StatusPageConfigs to count.
     * @example
     * // Count the number of StatusPageConfigs
     * const count = await prisma.statusPageConfig.count({
     *   where: {
     *     // ... the filter for the StatusPageConfigs we want to count
     *   }
     * })
    **/
    count<T extends StatusPageConfigCountArgs>(
      args?: Subset<T, StatusPageConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatusPageConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StatusPageConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusPageConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatusPageConfigAggregateArgs>(args: Subset<T, StatusPageConfigAggregateArgs>): Prisma.PrismaPromise<GetStatusPageConfigAggregateType<T>>

    /**
     * Group by StatusPageConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusPageConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatusPageConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatusPageConfigGroupByArgs['orderBy'] }
        : { orderBy?: StatusPageConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatusPageConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatusPageConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StatusPageConfig model
   */
  readonly fields: StatusPageConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StatusPageConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StatusPageConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StatusPageConfig model
   */ 
  interface StatusPageConfigFieldRefs {
    readonly id: FieldRef<"StatusPageConfig", 'String'>
    readonly orgId: FieldRef<"StatusPageConfig", 'String'>
    readonly title: FieldRef<"StatusPageConfig", 'String'>
    readonly description: FieldRef<"StatusPageConfig", 'String'>
    readonly logoUrl: FieldRef<"StatusPageConfig", 'String'>
    readonly faviconUrl: FieldRef<"StatusPageConfig", 'String'>
    readonly customDomain: FieldRef<"StatusPageConfig", 'String'>
    readonly customCss: FieldRef<"StatusPageConfig", 'String'>
    readonly showUptime: FieldRef<"StatusPageConfig", 'Boolean'>
    readonly showResponseTime: FieldRef<"StatusPageConfig", 'Boolean'>
    readonly createdAt: FieldRef<"StatusPageConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"StatusPageConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StatusPageConfig findUnique
   */
  export type StatusPageConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPageConfig
     */
    select?: StatusPageConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusPageConfigInclude<ExtArgs> | null
    /**
     * Filter, which StatusPageConfig to fetch.
     */
    where: StatusPageConfigWhereUniqueInput
  }

  /**
   * StatusPageConfig findUniqueOrThrow
   */
  export type StatusPageConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPageConfig
     */
    select?: StatusPageConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusPageConfigInclude<ExtArgs> | null
    /**
     * Filter, which StatusPageConfig to fetch.
     */
    where: StatusPageConfigWhereUniqueInput
  }

  /**
   * StatusPageConfig findFirst
   */
  export type StatusPageConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPageConfig
     */
    select?: StatusPageConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusPageConfigInclude<ExtArgs> | null
    /**
     * Filter, which StatusPageConfig to fetch.
     */
    where?: StatusPageConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusPageConfigs to fetch.
     */
    orderBy?: StatusPageConfigOrderByWithRelationInput | StatusPageConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatusPageConfigs.
     */
    cursor?: StatusPageConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusPageConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusPageConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatusPageConfigs.
     */
    distinct?: StatusPageConfigScalarFieldEnum | StatusPageConfigScalarFieldEnum[]
  }

  /**
   * StatusPageConfig findFirstOrThrow
   */
  export type StatusPageConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPageConfig
     */
    select?: StatusPageConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusPageConfigInclude<ExtArgs> | null
    /**
     * Filter, which StatusPageConfig to fetch.
     */
    where?: StatusPageConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusPageConfigs to fetch.
     */
    orderBy?: StatusPageConfigOrderByWithRelationInput | StatusPageConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatusPageConfigs.
     */
    cursor?: StatusPageConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusPageConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusPageConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatusPageConfigs.
     */
    distinct?: StatusPageConfigScalarFieldEnum | StatusPageConfigScalarFieldEnum[]
  }

  /**
   * StatusPageConfig findMany
   */
  export type StatusPageConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPageConfig
     */
    select?: StatusPageConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusPageConfigInclude<ExtArgs> | null
    /**
     * Filter, which StatusPageConfigs to fetch.
     */
    where?: StatusPageConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusPageConfigs to fetch.
     */
    orderBy?: StatusPageConfigOrderByWithRelationInput | StatusPageConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StatusPageConfigs.
     */
    cursor?: StatusPageConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusPageConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusPageConfigs.
     */
    skip?: number
    distinct?: StatusPageConfigScalarFieldEnum | StatusPageConfigScalarFieldEnum[]
  }

  /**
   * StatusPageConfig create
   */
  export type StatusPageConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPageConfig
     */
    select?: StatusPageConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusPageConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a StatusPageConfig.
     */
    data: XOR<StatusPageConfigCreateInput, StatusPageConfigUncheckedCreateInput>
  }

  /**
   * StatusPageConfig createMany
   */
  export type StatusPageConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StatusPageConfigs.
     */
    data: StatusPageConfigCreateManyInput | StatusPageConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StatusPageConfig createManyAndReturn
   */
  export type StatusPageConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPageConfig
     */
    select?: StatusPageConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StatusPageConfigs.
     */
    data: StatusPageConfigCreateManyInput | StatusPageConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusPageConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StatusPageConfig update
   */
  export type StatusPageConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPageConfig
     */
    select?: StatusPageConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusPageConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a StatusPageConfig.
     */
    data: XOR<StatusPageConfigUpdateInput, StatusPageConfigUncheckedUpdateInput>
    /**
     * Choose, which StatusPageConfig to update.
     */
    where: StatusPageConfigWhereUniqueInput
  }

  /**
   * StatusPageConfig updateMany
   */
  export type StatusPageConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StatusPageConfigs.
     */
    data: XOR<StatusPageConfigUpdateManyMutationInput, StatusPageConfigUncheckedUpdateManyInput>
    /**
     * Filter which StatusPageConfigs to update
     */
    where?: StatusPageConfigWhereInput
  }

  /**
   * StatusPageConfig upsert
   */
  export type StatusPageConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPageConfig
     */
    select?: StatusPageConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusPageConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the StatusPageConfig to update in case it exists.
     */
    where: StatusPageConfigWhereUniqueInput
    /**
     * In case the StatusPageConfig found by the `where` argument doesn't exist, create a new StatusPageConfig with this data.
     */
    create: XOR<StatusPageConfigCreateInput, StatusPageConfigUncheckedCreateInput>
    /**
     * In case the StatusPageConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StatusPageConfigUpdateInput, StatusPageConfigUncheckedUpdateInput>
  }

  /**
   * StatusPageConfig delete
   */
  export type StatusPageConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPageConfig
     */
    select?: StatusPageConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusPageConfigInclude<ExtArgs> | null
    /**
     * Filter which StatusPageConfig to delete.
     */
    where: StatusPageConfigWhereUniqueInput
  }

  /**
   * StatusPageConfig deleteMany
   */
  export type StatusPageConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatusPageConfigs to delete
     */
    where?: StatusPageConfigWhereInput
  }

  /**
   * StatusPageConfig without action
   */
  export type StatusPageConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPageConfig
     */
    select?: StatusPageConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusPageConfigInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const MemberScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    role: 'role',
    orgId: 'orgId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MemberScalarFieldEnum = (typeof MemberScalarFieldEnum)[keyof typeof MemberScalarFieldEnum]


  export const MonitorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    url: 'url',
    target: 'target',
    method: 'method',
    interval: 'interval',
    timeout: 'timeout',
    status: 'status',
    currentStatus: 'currentStatus',
    enabled: 'enabled',
    orgId: 'orgId',
    componentId: 'componentId',
    headers: 'headers',
    body: 'body',
    expectedStatus: 'expectedStatus',
    keyword: 'keyword',
    keywordType: 'keywordType',
    heartbeatToken: 'heartbeatToken',
    heartbeatGrace: 'heartbeatGrace',
    sslExpiryThreshold: 'sslExpiryThreshold',
    alertAfter: 'alertAfter',
    recoveryAfter: 'recoveryAfter',
    lastCheckedAt: 'lastCheckedAt',
    uptimeDay: 'uptimeDay',
    uptimeWeek: 'uptimeWeek',
    uptimeMonth: 'uptimeMonth',
    avgResponseTime: 'avgResponseTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MonitorScalarFieldEnum = (typeof MonitorScalarFieldEnum)[keyof typeof MonitorScalarFieldEnum]


  export const MonitorCheckScalarFieldEnum: {
    id: 'id',
    monitorId: 'monitorId',
    status: 'status',
    responseTime: 'responseTime',
    statusCode: 'statusCode',
    message: 'message',
    error: 'error',
    region: 'region',
    checkedAt: 'checkedAt'
  };

  export type MonitorCheckScalarFieldEnum = (typeof MonitorCheckScalarFieldEnum)[keyof typeof MonitorCheckScalarFieldEnum]


  export const MonitorAlertScalarFieldEnum: {
    id: 'id',
    monitorId: 'monitorId',
    type: 'type',
    message: 'message',
    createdAt: 'createdAt'
  };

  export type MonitorAlertScalarFieldEnum = (typeof MonitorAlertScalarFieldEnum)[keyof typeof MonitorAlertScalarFieldEnum]


  export const ComponentGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    order: 'order',
    orgId: 'orgId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComponentGroupScalarFieldEnum = (typeof ComponentGroupScalarFieldEnum)[keyof typeof ComponentGroupScalarFieldEnum]


  export const ComponentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    order: 'order',
    orgId: 'orgId',
    groupId: 'groupId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComponentScalarFieldEnum = (typeof ComponentScalarFieldEnum)[keyof typeof ComponentScalarFieldEnum]


  export const IncidentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    status: 'status',
    severity: 'severity',
    orgId: 'orgId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    resolvedAt: 'resolvedAt'
  };

  export type IncidentScalarFieldEnum = (typeof IncidentScalarFieldEnum)[keyof typeof IncidentScalarFieldEnum]


  export const IncidentUpdateScalarFieldEnum: {
    id: 'id',
    incidentId: 'incidentId',
    status: 'status',
    message: 'message',
    createdAt: 'createdAt'
  };

  export type IncidentUpdateScalarFieldEnum = (typeof IncidentUpdateScalarFieldEnum)[keyof typeof IncidentUpdateScalarFieldEnum]


  export const IncidentComponentScalarFieldEnum: {
    id: 'id',
    incidentId: 'incidentId',
    componentId: 'componentId',
    status: 'status'
  };

  export type IncidentComponentScalarFieldEnum = (typeof IncidentComponentScalarFieldEnum)[keyof typeof IncidentComponentScalarFieldEnum]


  export const SubscriberScalarFieldEnum: {
    id: 'id',
    type: 'type',
    email: 'email',
    webhookUrl: 'webhookUrl',
    confirmed: 'confirmed',
    token: 'token',
    orgId: 'orgId',
    createdAt: 'createdAt'
  };

  export type SubscriberScalarFieldEnum = (typeof SubscriberScalarFieldEnum)[keyof typeof SubscriberScalarFieldEnum]


  export const AlertScalarFieldEnum: {
    id: 'id',
    subscriberId: 'subscriberId',
    incidentId: 'incidentId',
    subject: 'subject',
    body: 'body',
    status: 'status',
    sentAt: 'sentAt',
    createdAt: 'createdAt'
  };

  export type AlertScalarFieldEnum = (typeof AlertScalarFieldEnum)[keyof typeof AlertScalarFieldEnum]


  export const NotificationChannelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    config: 'config',
    enabled: 'enabled',
    orgId: 'orgId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationChannelScalarFieldEnum = (typeof NotificationChannelScalarFieldEnum)[keyof typeof NotificationChannelScalarFieldEnum]


  export const ApiKeyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    key: 'key',
    orgId: 'orgId',
    expiresAt: 'expiresAt',
    lastUsedAt: 'lastUsedAt',
    createdAt: 'createdAt'
  };

  export type ApiKeyScalarFieldEnum = (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum]


  export const StatusPageConfigScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    title: 'title',
    description: 'description',
    logoUrl: 'logoUrl',
    faviconUrl: 'faviconUrl',
    customDomain: 'customDomain',
    customCss: 'customCss',
    showUptime: 'showUptime',
    showResponseTime: 'showResponseTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StatusPageConfigScalarFieldEnum = (typeof StatusPageConfigScalarFieldEnum)[keyof typeof StatusPageConfigScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'MemberRole'
   */
  export type EnumMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberRole'>
    


  /**
   * Reference to a field of type 'MemberRole[]'
   */
  export type ListEnumMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberRole[]'>
    


  /**
   * Reference to a field of type 'MonitorType'
   */
  export type EnumMonitorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MonitorType'>
    


  /**
   * Reference to a field of type 'MonitorType[]'
   */
  export type ListEnumMonitorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MonitorType[]'>
    


  /**
   * Reference to a field of type 'HttpMethod'
   */
  export type EnumHttpMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HttpMethod'>
    


  /**
   * Reference to a field of type 'HttpMethod[]'
   */
  export type ListEnumHttpMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HttpMethod[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'MonitorStatus'
   */
  export type EnumMonitorStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MonitorStatus'>
    


  /**
   * Reference to a field of type 'MonitorStatus[]'
   */
  export type ListEnumMonitorStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MonitorStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'KeywordType'
   */
  export type EnumKeywordTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KeywordType'>
    


  /**
   * Reference to a field of type 'KeywordType[]'
   */
  export type ListEnumKeywordTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KeywordType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ComponentStatus'
   */
  export type EnumComponentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComponentStatus'>
    


  /**
   * Reference to a field of type 'ComponentStatus[]'
   */
  export type ListEnumComponentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComponentStatus[]'>
    


  /**
   * Reference to a field of type 'IncidentStatus'
   */
  export type EnumIncidentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentStatus'>
    


  /**
   * Reference to a field of type 'IncidentStatus[]'
   */
  export type ListEnumIncidentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentStatus[]'>
    


  /**
   * Reference to a field of type 'IncidentSeverity'
   */
  export type EnumIncidentSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentSeverity'>
    


  /**
   * Reference to a field of type 'IncidentSeverity[]'
   */
  export type ListEnumIncidentSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentSeverity[]'>
    


  /**
   * Reference to a field of type 'SubscriberType'
   */
  export type EnumSubscriberTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriberType'>
    


  /**
   * Reference to a field of type 'SubscriberType[]'
   */
  export type ListEnumSubscriberTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriberType[]'>
    


  /**
   * Reference to a field of type 'AlertStatus'
   */
  export type EnumAlertStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertStatus'>
    


  /**
   * Reference to a field of type 'AlertStatus[]'
   */
  export type ListEnumAlertStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationChannelType'
   */
  export type EnumNotificationChannelTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationChannelType'>
    


  /**
   * Reference to a field of type 'NotificationChannelType[]'
   */
  export type ListEnumNotificationChannelTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationChannelType[]'>
    
  /**
   * Deep Input Types
   */


  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    name?: StringFilter<"Organization"> | string
    slug?: StringFilter<"Organization"> | string
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    members?: MemberListRelationFilter
    monitors?: MonitorListRelationFilter
    components?: ComponentListRelationFilter
    componentGroups?: ComponentGroupListRelationFilter
    incidents?: IncidentListRelationFilter
    subscribers?: SubscriberListRelationFilter
    notificationChannels?: NotificationChannelListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
    statusPageConfig?: XOR<StatusPageConfigNullableRelationFilter, StatusPageConfigWhereInput> | null
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    members?: MemberOrderByRelationAggregateInput
    monitors?: MonitorOrderByRelationAggregateInput
    components?: ComponentOrderByRelationAggregateInput
    componentGroups?: ComponentGroupOrderByRelationAggregateInput
    incidents?: IncidentOrderByRelationAggregateInput
    subscribers?: SubscriberOrderByRelationAggregateInput
    notificationChannels?: NotificationChannelOrderByRelationAggregateInput
    apiKeys?: ApiKeyOrderByRelationAggregateInput
    statusPageConfig?: StatusPageConfigOrderByWithRelationInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    members?: MemberListRelationFilter
    monitors?: MonitorListRelationFilter
    components?: ComponentListRelationFilter
    componentGroups?: ComponentGroupListRelationFilter
    incidents?: IncidentListRelationFilter
    subscribers?: SubscriberListRelationFilter
    notificationChannels?: NotificationChannelListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
    statusPageConfig?: XOR<StatusPageConfigNullableRelationFilter, StatusPageConfigWhereInput> | null
  }, "id" | "slug">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    name?: StringWithAggregatesFilter<"Organization"> | string
    slug?: StringWithAggregatesFilter<"Organization"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
  }

  export type MemberWhereInput = {
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    id?: StringFilter<"Member"> | string
    email?: StringFilter<"Member"> | string
    password?: StringFilter<"Member"> | string
    name?: StringFilter<"Member"> | string
    role?: EnumMemberRoleFilter<"Member"> | $Enums.MemberRole
    orgId?: StringFilter<"Member"> | string
    createdAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeFilter<"Member"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }

  export type MemberOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
  }

  export type MemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    password?: StringFilter<"Member"> | string
    name?: StringFilter<"Member"> | string
    role?: EnumMemberRoleFilter<"Member"> | $Enums.MemberRole
    orgId?: StringFilter<"Member"> | string
    createdAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeFilter<"Member"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }, "id" | "email">

  export type MemberOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MemberCountOrderByAggregateInput
    _max?: MemberMaxOrderByAggregateInput
    _min?: MemberMinOrderByAggregateInput
  }

  export type MemberScalarWhereWithAggregatesInput = {
    AND?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    OR?: MemberScalarWhereWithAggregatesInput[]
    NOT?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Member"> | string
    email?: StringWithAggregatesFilter<"Member"> | string
    password?: StringWithAggregatesFilter<"Member"> | string
    name?: StringWithAggregatesFilter<"Member"> | string
    role?: EnumMemberRoleWithAggregatesFilter<"Member"> | $Enums.MemberRole
    orgId?: StringWithAggregatesFilter<"Member"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Member"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Member"> | Date | string
  }

  export type MonitorWhereInput = {
    AND?: MonitorWhereInput | MonitorWhereInput[]
    OR?: MonitorWhereInput[]
    NOT?: MonitorWhereInput | MonitorWhereInput[]
    id?: StringFilter<"Monitor"> | string
    name?: StringFilter<"Monitor"> | string
    type?: EnumMonitorTypeFilter<"Monitor"> | $Enums.MonitorType
    url?: StringNullableFilter<"Monitor"> | string | null
    target?: StringNullableFilter<"Monitor"> | string | null
    method?: EnumHttpMethodFilter<"Monitor"> | $Enums.HttpMethod
    interval?: IntFilter<"Monitor"> | number
    timeout?: IntFilter<"Monitor"> | number
    status?: EnumMonitorStatusFilter<"Monitor"> | $Enums.MonitorStatus
    currentStatus?: StringFilter<"Monitor"> | string
    enabled?: BoolFilter<"Monitor"> | boolean
    orgId?: StringFilter<"Monitor"> | string
    componentId?: StringNullableFilter<"Monitor"> | string | null
    headers?: JsonNullableFilter<"Monitor">
    body?: StringNullableFilter<"Monitor"> | string | null
    expectedStatus?: IntNullableFilter<"Monitor"> | number | null
    keyword?: StringNullableFilter<"Monitor"> | string | null
    keywordType?: EnumKeywordTypeNullableFilter<"Monitor"> | $Enums.KeywordType | null
    heartbeatToken?: StringNullableFilter<"Monitor"> | string | null
    heartbeatGrace?: IntNullableFilter<"Monitor"> | number | null
    sslExpiryThreshold?: IntNullableFilter<"Monitor"> | number | null
    alertAfter?: IntFilter<"Monitor"> | number
    recoveryAfter?: IntFilter<"Monitor"> | number
    lastCheckedAt?: DateTimeNullableFilter<"Monitor"> | Date | string | null
    uptimeDay?: FloatNullableFilter<"Monitor"> | number | null
    uptimeWeek?: FloatNullableFilter<"Monitor"> | number | null
    uptimeMonth?: FloatNullableFilter<"Monitor"> | number | null
    avgResponseTime?: FloatNullableFilter<"Monitor"> | number | null
    createdAt?: DateTimeFilter<"Monitor"> | Date | string
    updatedAt?: DateTimeFilter<"Monitor"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    component?: XOR<ComponentNullableRelationFilter, ComponentWhereInput> | null
    checks?: MonitorCheckListRelationFilter
    alerts?: MonitorAlertListRelationFilter
  }

  export type MonitorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrderInput | SortOrder
    target?: SortOrderInput | SortOrder
    method?: SortOrder
    interval?: SortOrder
    timeout?: SortOrder
    status?: SortOrder
    currentStatus?: SortOrder
    enabled?: SortOrder
    orgId?: SortOrder
    componentId?: SortOrderInput | SortOrder
    headers?: SortOrderInput | SortOrder
    body?: SortOrderInput | SortOrder
    expectedStatus?: SortOrderInput | SortOrder
    keyword?: SortOrderInput | SortOrder
    keywordType?: SortOrderInput | SortOrder
    heartbeatToken?: SortOrderInput | SortOrder
    heartbeatGrace?: SortOrderInput | SortOrder
    sslExpiryThreshold?: SortOrderInput | SortOrder
    alertAfter?: SortOrder
    recoveryAfter?: SortOrder
    lastCheckedAt?: SortOrderInput | SortOrder
    uptimeDay?: SortOrderInput | SortOrder
    uptimeWeek?: SortOrderInput | SortOrder
    uptimeMonth?: SortOrderInput | SortOrder
    avgResponseTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    component?: ComponentOrderByWithRelationInput
    checks?: MonitorCheckOrderByRelationAggregateInput
    alerts?: MonitorAlertOrderByRelationAggregateInput
  }

  export type MonitorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    heartbeatToken?: string
    AND?: MonitorWhereInput | MonitorWhereInput[]
    OR?: MonitorWhereInput[]
    NOT?: MonitorWhereInput | MonitorWhereInput[]
    name?: StringFilter<"Monitor"> | string
    type?: EnumMonitorTypeFilter<"Monitor"> | $Enums.MonitorType
    url?: StringNullableFilter<"Monitor"> | string | null
    target?: StringNullableFilter<"Monitor"> | string | null
    method?: EnumHttpMethodFilter<"Monitor"> | $Enums.HttpMethod
    interval?: IntFilter<"Monitor"> | number
    timeout?: IntFilter<"Monitor"> | number
    status?: EnumMonitorStatusFilter<"Monitor"> | $Enums.MonitorStatus
    currentStatus?: StringFilter<"Monitor"> | string
    enabled?: BoolFilter<"Monitor"> | boolean
    orgId?: StringFilter<"Monitor"> | string
    componentId?: StringNullableFilter<"Monitor"> | string | null
    headers?: JsonNullableFilter<"Monitor">
    body?: StringNullableFilter<"Monitor"> | string | null
    expectedStatus?: IntNullableFilter<"Monitor"> | number | null
    keyword?: StringNullableFilter<"Monitor"> | string | null
    keywordType?: EnumKeywordTypeNullableFilter<"Monitor"> | $Enums.KeywordType | null
    heartbeatGrace?: IntNullableFilter<"Monitor"> | number | null
    sslExpiryThreshold?: IntNullableFilter<"Monitor"> | number | null
    alertAfter?: IntFilter<"Monitor"> | number
    recoveryAfter?: IntFilter<"Monitor"> | number
    lastCheckedAt?: DateTimeNullableFilter<"Monitor"> | Date | string | null
    uptimeDay?: FloatNullableFilter<"Monitor"> | number | null
    uptimeWeek?: FloatNullableFilter<"Monitor"> | number | null
    uptimeMonth?: FloatNullableFilter<"Monitor"> | number | null
    avgResponseTime?: FloatNullableFilter<"Monitor"> | number | null
    createdAt?: DateTimeFilter<"Monitor"> | Date | string
    updatedAt?: DateTimeFilter<"Monitor"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    component?: XOR<ComponentNullableRelationFilter, ComponentWhereInput> | null
    checks?: MonitorCheckListRelationFilter
    alerts?: MonitorAlertListRelationFilter
  }, "id" | "heartbeatToken">

  export type MonitorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrderInput | SortOrder
    target?: SortOrderInput | SortOrder
    method?: SortOrder
    interval?: SortOrder
    timeout?: SortOrder
    status?: SortOrder
    currentStatus?: SortOrder
    enabled?: SortOrder
    orgId?: SortOrder
    componentId?: SortOrderInput | SortOrder
    headers?: SortOrderInput | SortOrder
    body?: SortOrderInput | SortOrder
    expectedStatus?: SortOrderInput | SortOrder
    keyword?: SortOrderInput | SortOrder
    keywordType?: SortOrderInput | SortOrder
    heartbeatToken?: SortOrderInput | SortOrder
    heartbeatGrace?: SortOrderInput | SortOrder
    sslExpiryThreshold?: SortOrderInput | SortOrder
    alertAfter?: SortOrder
    recoveryAfter?: SortOrder
    lastCheckedAt?: SortOrderInput | SortOrder
    uptimeDay?: SortOrderInput | SortOrder
    uptimeWeek?: SortOrderInput | SortOrder
    uptimeMonth?: SortOrderInput | SortOrder
    avgResponseTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MonitorCountOrderByAggregateInput
    _avg?: MonitorAvgOrderByAggregateInput
    _max?: MonitorMaxOrderByAggregateInput
    _min?: MonitorMinOrderByAggregateInput
    _sum?: MonitorSumOrderByAggregateInput
  }

  export type MonitorScalarWhereWithAggregatesInput = {
    AND?: MonitorScalarWhereWithAggregatesInput | MonitorScalarWhereWithAggregatesInput[]
    OR?: MonitorScalarWhereWithAggregatesInput[]
    NOT?: MonitorScalarWhereWithAggregatesInput | MonitorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Monitor"> | string
    name?: StringWithAggregatesFilter<"Monitor"> | string
    type?: EnumMonitorTypeWithAggregatesFilter<"Monitor"> | $Enums.MonitorType
    url?: StringNullableWithAggregatesFilter<"Monitor"> | string | null
    target?: StringNullableWithAggregatesFilter<"Monitor"> | string | null
    method?: EnumHttpMethodWithAggregatesFilter<"Monitor"> | $Enums.HttpMethod
    interval?: IntWithAggregatesFilter<"Monitor"> | number
    timeout?: IntWithAggregatesFilter<"Monitor"> | number
    status?: EnumMonitorStatusWithAggregatesFilter<"Monitor"> | $Enums.MonitorStatus
    currentStatus?: StringWithAggregatesFilter<"Monitor"> | string
    enabled?: BoolWithAggregatesFilter<"Monitor"> | boolean
    orgId?: StringWithAggregatesFilter<"Monitor"> | string
    componentId?: StringNullableWithAggregatesFilter<"Monitor"> | string | null
    headers?: JsonNullableWithAggregatesFilter<"Monitor">
    body?: StringNullableWithAggregatesFilter<"Monitor"> | string | null
    expectedStatus?: IntNullableWithAggregatesFilter<"Monitor"> | number | null
    keyword?: StringNullableWithAggregatesFilter<"Monitor"> | string | null
    keywordType?: EnumKeywordTypeNullableWithAggregatesFilter<"Monitor"> | $Enums.KeywordType | null
    heartbeatToken?: StringNullableWithAggregatesFilter<"Monitor"> | string | null
    heartbeatGrace?: IntNullableWithAggregatesFilter<"Monitor"> | number | null
    sslExpiryThreshold?: IntNullableWithAggregatesFilter<"Monitor"> | number | null
    alertAfter?: IntWithAggregatesFilter<"Monitor"> | number
    recoveryAfter?: IntWithAggregatesFilter<"Monitor"> | number
    lastCheckedAt?: DateTimeNullableWithAggregatesFilter<"Monitor"> | Date | string | null
    uptimeDay?: FloatNullableWithAggregatesFilter<"Monitor"> | number | null
    uptimeWeek?: FloatNullableWithAggregatesFilter<"Monitor"> | number | null
    uptimeMonth?: FloatNullableWithAggregatesFilter<"Monitor"> | number | null
    avgResponseTime?: FloatNullableWithAggregatesFilter<"Monitor"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Monitor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Monitor"> | Date | string
  }

  export type MonitorCheckWhereInput = {
    AND?: MonitorCheckWhereInput | MonitorCheckWhereInput[]
    OR?: MonitorCheckWhereInput[]
    NOT?: MonitorCheckWhereInput | MonitorCheckWhereInput[]
    id?: StringFilter<"MonitorCheck"> | string
    monitorId?: StringFilter<"MonitorCheck"> | string
    status?: EnumMonitorStatusFilter<"MonitorCheck"> | $Enums.MonitorStatus
    responseTime?: IntNullableFilter<"MonitorCheck"> | number | null
    statusCode?: IntNullableFilter<"MonitorCheck"> | number | null
    message?: StringNullableFilter<"MonitorCheck"> | string | null
    error?: StringNullableFilter<"MonitorCheck"> | string | null
    region?: StringNullableFilter<"MonitorCheck"> | string | null
    checkedAt?: DateTimeFilter<"MonitorCheck"> | Date | string
    monitor?: XOR<MonitorRelationFilter, MonitorWhereInput>
  }

  export type MonitorCheckOrderByWithRelationInput = {
    id?: SortOrder
    monitorId?: SortOrder
    status?: SortOrder
    responseTime?: SortOrderInput | SortOrder
    statusCode?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    checkedAt?: SortOrder
    monitor?: MonitorOrderByWithRelationInput
  }

  export type MonitorCheckWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MonitorCheckWhereInput | MonitorCheckWhereInput[]
    OR?: MonitorCheckWhereInput[]
    NOT?: MonitorCheckWhereInput | MonitorCheckWhereInput[]
    monitorId?: StringFilter<"MonitorCheck"> | string
    status?: EnumMonitorStatusFilter<"MonitorCheck"> | $Enums.MonitorStatus
    responseTime?: IntNullableFilter<"MonitorCheck"> | number | null
    statusCode?: IntNullableFilter<"MonitorCheck"> | number | null
    message?: StringNullableFilter<"MonitorCheck"> | string | null
    error?: StringNullableFilter<"MonitorCheck"> | string | null
    region?: StringNullableFilter<"MonitorCheck"> | string | null
    checkedAt?: DateTimeFilter<"MonitorCheck"> | Date | string
    monitor?: XOR<MonitorRelationFilter, MonitorWhereInput>
  }, "id">

  export type MonitorCheckOrderByWithAggregationInput = {
    id?: SortOrder
    monitorId?: SortOrder
    status?: SortOrder
    responseTime?: SortOrderInput | SortOrder
    statusCode?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    checkedAt?: SortOrder
    _count?: MonitorCheckCountOrderByAggregateInput
    _avg?: MonitorCheckAvgOrderByAggregateInput
    _max?: MonitorCheckMaxOrderByAggregateInput
    _min?: MonitorCheckMinOrderByAggregateInput
    _sum?: MonitorCheckSumOrderByAggregateInput
  }

  export type MonitorCheckScalarWhereWithAggregatesInput = {
    AND?: MonitorCheckScalarWhereWithAggregatesInput | MonitorCheckScalarWhereWithAggregatesInput[]
    OR?: MonitorCheckScalarWhereWithAggregatesInput[]
    NOT?: MonitorCheckScalarWhereWithAggregatesInput | MonitorCheckScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MonitorCheck"> | string
    monitorId?: StringWithAggregatesFilter<"MonitorCheck"> | string
    status?: EnumMonitorStatusWithAggregatesFilter<"MonitorCheck"> | $Enums.MonitorStatus
    responseTime?: IntNullableWithAggregatesFilter<"MonitorCheck"> | number | null
    statusCode?: IntNullableWithAggregatesFilter<"MonitorCheck"> | number | null
    message?: StringNullableWithAggregatesFilter<"MonitorCheck"> | string | null
    error?: StringNullableWithAggregatesFilter<"MonitorCheck"> | string | null
    region?: StringNullableWithAggregatesFilter<"MonitorCheck"> | string | null
    checkedAt?: DateTimeWithAggregatesFilter<"MonitorCheck"> | Date | string
  }

  export type MonitorAlertWhereInput = {
    AND?: MonitorAlertWhereInput | MonitorAlertWhereInput[]
    OR?: MonitorAlertWhereInput[]
    NOT?: MonitorAlertWhereInput | MonitorAlertWhereInput[]
    id?: StringFilter<"MonitorAlert"> | string
    monitorId?: StringFilter<"MonitorAlert"> | string
    type?: StringFilter<"MonitorAlert"> | string
    message?: StringFilter<"MonitorAlert"> | string
    createdAt?: DateTimeFilter<"MonitorAlert"> | Date | string
    monitor?: XOR<MonitorRelationFilter, MonitorWhereInput>
  }

  export type MonitorAlertOrderByWithRelationInput = {
    id?: SortOrder
    monitorId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    monitor?: MonitorOrderByWithRelationInput
  }

  export type MonitorAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MonitorAlertWhereInput | MonitorAlertWhereInput[]
    OR?: MonitorAlertWhereInput[]
    NOT?: MonitorAlertWhereInput | MonitorAlertWhereInput[]
    monitorId?: StringFilter<"MonitorAlert"> | string
    type?: StringFilter<"MonitorAlert"> | string
    message?: StringFilter<"MonitorAlert"> | string
    createdAt?: DateTimeFilter<"MonitorAlert"> | Date | string
    monitor?: XOR<MonitorRelationFilter, MonitorWhereInput>
  }, "id">

  export type MonitorAlertOrderByWithAggregationInput = {
    id?: SortOrder
    monitorId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    _count?: MonitorAlertCountOrderByAggregateInput
    _max?: MonitorAlertMaxOrderByAggregateInput
    _min?: MonitorAlertMinOrderByAggregateInput
  }

  export type MonitorAlertScalarWhereWithAggregatesInput = {
    AND?: MonitorAlertScalarWhereWithAggregatesInput | MonitorAlertScalarWhereWithAggregatesInput[]
    OR?: MonitorAlertScalarWhereWithAggregatesInput[]
    NOT?: MonitorAlertScalarWhereWithAggregatesInput | MonitorAlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MonitorAlert"> | string
    monitorId?: StringWithAggregatesFilter<"MonitorAlert"> | string
    type?: StringWithAggregatesFilter<"MonitorAlert"> | string
    message?: StringWithAggregatesFilter<"MonitorAlert"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MonitorAlert"> | Date | string
  }

  export type ComponentGroupWhereInput = {
    AND?: ComponentGroupWhereInput | ComponentGroupWhereInput[]
    OR?: ComponentGroupWhereInput[]
    NOT?: ComponentGroupWhereInput | ComponentGroupWhereInput[]
    id?: StringFilter<"ComponentGroup"> | string
    name?: StringFilter<"ComponentGroup"> | string
    order?: IntFilter<"ComponentGroup"> | number
    orgId?: StringFilter<"ComponentGroup"> | string
    createdAt?: DateTimeFilter<"ComponentGroup"> | Date | string
    updatedAt?: DateTimeFilter<"ComponentGroup"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    components?: ComponentListRelationFilter
  }

  export type ComponentGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    components?: ComponentOrderByRelationAggregateInput
  }

  export type ComponentGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ComponentGroupWhereInput | ComponentGroupWhereInput[]
    OR?: ComponentGroupWhereInput[]
    NOT?: ComponentGroupWhereInput | ComponentGroupWhereInput[]
    name?: StringFilter<"ComponentGroup"> | string
    order?: IntFilter<"ComponentGroup"> | number
    orgId?: StringFilter<"ComponentGroup"> | string
    createdAt?: DateTimeFilter<"ComponentGroup"> | Date | string
    updatedAt?: DateTimeFilter<"ComponentGroup"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    components?: ComponentListRelationFilter
  }, "id">

  export type ComponentGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ComponentGroupCountOrderByAggregateInput
    _avg?: ComponentGroupAvgOrderByAggregateInput
    _max?: ComponentGroupMaxOrderByAggregateInput
    _min?: ComponentGroupMinOrderByAggregateInput
    _sum?: ComponentGroupSumOrderByAggregateInput
  }

  export type ComponentGroupScalarWhereWithAggregatesInput = {
    AND?: ComponentGroupScalarWhereWithAggregatesInput | ComponentGroupScalarWhereWithAggregatesInput[]
    OR?: ComponentGroupScalarWhereWithAggregatesInput[]
    NOT?: ComponentGroupScalarWhereWithAggregatesInput | ComponentGroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ComponentGroup"> | string
    name?: StringWithAggregatesFilter<"ComponentGroup"> | string
    order?: IntWithAggregatesFilter<"ComponentGroup"> | number
    orgId?: StringWithAggregatesFilter<"ComponentGroup"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ComponentGroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ComponentGroup"> | Date | string
  }

  export type ComponentWhereInput = {
    AND?: ComponentWhereInput | ComponentWhereInput[]
    OR?: ComponentWhereInput[]
    NOT?: ComponentWhereInput | ComponentWhereInput[]
    id?: StringFilter<"Component"> | string
    name?: StringFilter<"Component"> | string
    description?: StringNullableFilter<"Component"> | string | null
    status?: EnumComponentStatusFilter<"Component"> | $Enums.ComponentStatus
    order?: IntFilter<"Component"> | number
    orgId?: StringFilter<"Component"> | string
    groupId?: StringNullableFilter<"Component"> | string | null
    createdAt?: DateTimeFilter<"Component"> | Date | string
    updatedAt?: DateTimeFilter<"Component"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    group?: XOR<ComponentGroupNullableRelationFilter, ComponentGroupWhereInput> | null
    monitors?: MonitorListRelationFilter
    incidents?: IncidentComponentListRelationFilter
  }

  export type ComponentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    order?: SortOrder
    orgId?: SortOrder
    groupId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    group?: ComponentGroupOrderByWithRelationInput
    monitors?: MonitorOrderByRelationAggregateInput
    incidents?: IncidentComponentOrderByRelationAggregateInput
  }

  export type ComponentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ComponentWhereInput | ComponentWhereInput[]
    OR?: ComponentWhereInput[]
    NOT?: ComponentWhereInput | ComponentWhereInput[]
    name?: StringFilter<"Component"> | string
    description?: StringNullableFilter<"Component"> | string | null
    status?: EnumComponentStatusFilter<"Component"> | $Enums.ComponentStatus
    order?: IntFilter<"Component"> | number
    orgId?: StringFilter<"Component"> | string
    groupId?: StringNullableFilter<"Component"> | string | null
    createdAt?: DateTimeFilter<"Component"> | Date | string
    updatedAt?: DateTimeFilter<"Component"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    group?: XOR<ComponentGroupNullableRelationFilter, ComponentGroupWhereInput> | null
    monitors?: MonitorListRelationFilter
    incidents?: IncidentComponentListRelationFilter
  }, "id">

  export type ComponentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    order?: SortOrder
    orgId?: SortOrder
    groupId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ComponentCountOrderByAggregateInput
    _avg?: ComponentAvgOrderByAggregateInput
    _max?: ComponentMaxOrderByAggregateInput
    _min?: ComponentMinOrderByAggregateInput
    _sum?: ComponentSumOrderByAggregateInput
  }

  export type ComponentScalarWhereWithAggregatesInput = {
    AND?: ComponentScalarWhereWithAggregatesInput | ComponentScalarWhereWithAggregatesInput[]
    OR?: ComponentScalarWhereWithAggregatesInput[]
    NOT?: ComponentScalarWhereWithAggregatesInput | ComponentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Component"> | string
    name?: StringWithAggregatesFilter<"Component"> | string
    description?: StringNullableWithAggregatesFilter<"Component"> | string | null
    status?: EnumComponentStatusWithAggregatesFilter<"Component"> | $Enums.ComponentStatus
    order?: IntWithAggregatesFilter<"Component"> | number
    orgId?: StringWithAggregatesFilter<"Component"> | string
    groupId?: StringNullableWithAggregatesFilter<"Component"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Component"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Component"> | Date | string
  }

  export type IncidentWhereInput = {
    AND?: IncidentWhereInput | IncidentWhereInput[]
    OR?: IncidentWhereInput[]
    NOT?: IncidentWhereInput | IncidentWhereInput[]
    id?: StringFilter<"Incident"> | string
    title?: StringFilter<"Incident"> | string
    status?: EnumIncidentStatusFilter<"Incident"> | $Enums.IncidentStatus
    severity?: EnumIncidentSeverityFilter<"Incident"> | $Enums.IncidentSeverity
    orgId?: StringFilter<"Incident"> | string
    createdAt?: DateTimeFilter<"Incident"> | Date | string
    updatedAt?: DateTimeFilter<"Incident"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Incident"> | Date | string | null
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    updates?: IncidentUpdateListRelationFilter
    components?: IncidentComponentListRelationFilter
  }

  export type IncidentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    status?: SortOrder
    severity?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    organization?: OrganizationOrderByWithRelationInput
    updates?: IncidentUpdateOrderByRelationAggregateInput
    components?: IncidentComponentOrderByRelationAggregateInput
  }

  export type IncidentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IncidentWhereInput | IncidentWhereInput[]
    OR?: IncidentWhereInput[]
    NOT?: IncidentWhereInput | IncidentWhereInput[]
    title?: StringFilter<"Incident"> | string
    status?: EnumIncidentStatusFilter<"Incident"> | $Enums.IncidentStatus
    severity?: EnumIncidentSeverityFilter<"Incident"> | $Enums.IncidentSeverity
    orgId?: StringFilter<"Incident"> | string
    createdAt?: DateTimeFilter<"Incident"> | Date | string
    updatedAt?: DateTimeFilter<"Incident"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Incident"> | Date | string | null
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    updates?: IncidentUpdateListRelationFilter
    components?: IncidentComponentListRelationFilter
  }, "id">

  export type IncidentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    status?: SortOrder
    severity?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    _count?: IncidentCountOrderByAggregateInput
    _max?: IncidentMaxOrderByAggregateInput
    _min?: IncidentMinOrderByAggregateInput
  }

  export type IncidentScalarWhereWithAggregatesInput = {
    AND?: IncidentScalarWhereWithAggregatesInput | IncidentScalarWhereWithAggregatesInput[]
    OR?: IncidentScalarWhereWithAggregatesInput[]
    NOT?: IncidentScalarWhereWithAggregatesInput | IncidentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Incident"> | string
    title?: StringWithAggregatesFilter<"Incident"> | string
    status?: EnumIncidentStatusWithAggregatesFilter<"Incident"> | $Enums.IncidentStatus
    severity?: EnumIncidentSeverityWithAggregatesFilter<"Incident"> | $Enums.IncidentSeverity
    orgId?: StringWithAggregatesFilter<"Incident"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Incident"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Incident"> | Date | string
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Incident"> | Date | string | null
  }

  export type IncidentUpdateWhereInput = {
    AND?: IncidentUpdateWhereInput | IncidentUpdateWhereInput[]
    OR?: IncidentUpdateWhereInput[]
    NOT?: IncidentUpdateWhereInput | IncidentUpdateWhereInput[]
    id?: StringFilter<"IncidentUpdate"> | string
    incidentId?: StringFilter<"IncidentUpdate"> | string
    status?: EnumIncidentStatusFilter<"IncidentUpdate"> | $Enums.IncidentStatus
    message?: StringFilter<"IncidentUpdate"> | string
    createdAt?: DateTimeFilter<"IncidentUpdate"> | Date | string
    incident?: XOR<IncidentRelationFilter, IncidentWhereInput>
  }

  export type IncidentUpdateOrderByWithRelationInput = {
    id?: SortOrder
    incidentId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    incident?: IncidentOrderByWithRelationInput
  }

  export type IncidentUpdateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IncidentUpdateWhereInput | IncidentUpdateWhereInput[]
    OR?: IncidentUpdateWhereInput[]
    NOT?: IncidentUpdateWhereInput | IncidentUpdateWhereInput[]
    incidentId?: StringFilter<"IncidentUpdate"> | string
    status?: EnumIncidentStatusFilter<"IncidentUpdate"> | $Enums.IncidentStatus
    message?: StringFilter<"IncidentUpdate"> | string
    createdAt?: DateTimeFilter<"IncidentUpdate"> | Date | string
    incident?: XOR<IncidentRelationFilter, IncidentWhereInput>
  }, "id">

  export type IncidentUpdateOrderByWithAggregationInput = {
    id?: SortOrder
    incidentId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    _count?: IncidentUpdateCountOrderByAggregateInput
    _max?: IncidentUpdateMaxOrderByAggregateInput
    _min?: IncidentUpdateMinOrderByAggregateInput
  }

  export type IncidentUpdateScalarWhereWithAggregatesInput = {
    AND?: IncidentUpdateScalarWhereWithAggregatesInput | IncidentUpdateScalarWhereWithAggregatesInput[]
    OR?: IncidentUpdateScalarWhereWithAggregatesInput[]
    NOT?: IncidentUpdateScalarWhereWithAggregatesInput | IncidentUpdateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IncidentUpdate"> | string
    incidentId?: StringWithAggregatesFilter<"IncidentUpdate"> | string
    status?: EnumIncidentStatusWithAggregatesFilter<"IncidentUpdate"> | $Enums.IncidentStatus
    message?: StringWithAggregatesFilter<"IncidentUpdate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"IncidentUpdate"> | Date | string
  }

  export type IncidentComponentWhereInput = {
    AND?: IncidentComponentWhereInput | IncidentComponentWhereInput[]
    OR?: IncidentComponentWhereInput[]
    NOT?: IncidentComponentWhereInput | IncidentComponentWhereInput[]
    id?: StringFilter<"IncidentComponent"> | string
    incidentId?: StringFilter<"IncidentComponent"> | string
    componentId?: StringFilter<"IncidentComponent"> | string
    status?: EnumComponentStatusFilter<"IncidentComponent"> | $Enums.ComponentStatus
    incident?: XOR<IncidentRelationFilter, IncidentWhereInput>
    component?: XOR<ComponentRelationFilter, ComponentWhereInput>
  }

  export type IncidentComponentOrderByWithRelationInput = {
    id?: SortOrder
    incidentId?: SortOrder
    componentId?: SortOrder
    status?: SortOrder
    incident?: IncidentOrderByWithRelationInput
    component?: ComponentOrderByWithRelationInput
  }

  export type IncidentComponentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    incidentId_componentId?: IncidentComponentIncidentIdComponentIdCompoundUniqueInput
    AND?: IncidentComponentWhereInput | IncidentComponentWhereInput[]
    OR?: IncidentComponentWhereInput[]
    NOT?: IncidentComponentWhereInput | IncidentComponentWhereInput[]
    incidentId?: StringFilter<"IncidentComponent"> | string
    componentId?: StringFilter<"IncidentComponent"> | string
    status?: EnumComponentStatusFilter<"IncidentComponent"> | $Enums.ComponentStatus
    incident?: XOR<IncidentRelationFilter, IncidentWhereInput>
    component?: XOR<ComponentRelationFilter, ComponentWhereInput>
  }, "id" | "incidentId_componentId">

  export type IncidentComponentOrderByWithAggregationInput = {
    id?: SortOrder
    incidentId?: SortOrder
    componentId?: SortOrder
    status?: SortOrder
    _count?: IncidentComponentCountOrderByAggregateInput
    _max?: IncidentComponentMaxOrderByAggregateInput
    _min?: IncidentComponentMinOrderByAggregateInput
  }

  export type IncidentComponentScalarWhereWithAggregatesInput = {
    AND?: IncidentComponentScalarWhereWithAggregatesInput | IncidentComponentScalarWhereWithAggregatesInput[]
    OR?: IncidentComponentScalarWhereWithAggregatesInput[]
    NOT?: IncidentComponentScalarWhereWithAggregatesInput | IncidentComponentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IncidentComponent"> | string
    incidentId?: StringWithAggregatesFilter<"IncidentComponent"> | string
    componentId?: StringWithAggregatesFilter<"IncidentComponent"> | string
    status?: EnumComponentStatusWithAggregatesFilter<"IncidentComponent"> | $Enums.ComponentStatus
  }

  export type SubscriberWhereInput = {
    AND?: SubscriberWhereInput | SubscriberWhereInput[]
    OR?: SubscriberWhereInput[]
    NOT?: SubscriberWhereInput | SubscriberWhereInput[]
    id?: StringFilter<"Subscriber"> | string
    type?: EnumSubscriberTypeFilter<"Subscriber"> | $Enums.SubscriberType
    email?: StringNullableFilter<"Subscriber"> | string | null
    webhookUrl?: StringNullableFilter<"Subscriber"> | string | null
    confirmed?: BoolFilter<"Subscriber"> | boolean
    token?: StringFilter<"Subscriber"> | string
    orgId?: StringFilter<"Subscriber"> | string
    createdAt?: DateTimeFilter<"Subscriber"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    alerts?: AlertListRelationFilter
  }

  export type SubscriberOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    email?: SortOrderInput | SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    confirmed?: SortOrder
    token?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    alerts?: AlertOrderByRelationAggregateInput
  }

  export type SubscriberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SubscriberWhereInput | SubscriberWhereInput[]
    OR?: SubscriberWhereInput[]
    NOT?: SubscriberWhereInput | SubscriberWhereInput[]
    type?: EnumSubscriberTypeFilter<"Subscriber"> | $Enums.SubscriberType
    email?: StringNullableFilter<"Subscriber"> | string | null
    webhookUrl?: StringNullableFilter<"Subscriber"> | string | null
    confirmed?: BoolFilter<"Subscriber"> | boolean
    orgId?: StringFilter<"Subscriber"> | string
    createdAt?: DateTimeFilter<"Subscriber"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    alerts?: AlertListRelationFilter
  }, "id" | "token">

  export type SubscriberOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    email?: SortOrderInput | SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    confirmed?: SortOrder
    token?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    _count?: SubscriberCountOrderByAggregateInput
    _max?: SubscriberMaxOrderByAggregateInput
    _min?: SubscriberMinOrderByAggregateInput
  }

  export type SubscriberScalarWhereWithAggregatesInput = {
    AND?: SubscriberScalarWhereWithAggregatesInput | SubscriberScalarWhereWithAggregatesInput[]
    OR?: SubscriberScalarWhereWithAggregatesInput[]
    NOT?: SubscriberScalarWhereWithAggregatesInput | SubscriberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscriber"> | string
    type?: EnumSubscriberTypeWithAggregatesFilter<"Subscriber"> | $Enums.SubscriberType
    email?: StringNullableWithAggregatesFilter<"Subscriber"> | string | null
    webhookUrl?: StringNullableWithAggregatesFilter<"Subscriber"> | string | null
    confirmed?: BoolWithAggregatesFilter<"Subscriber"> | boolean
    token?: StringWithAggregatesFilter<"Subscriber"> | string
    orgId?: StringWithAggregatesFilter<"Subscriber"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Subscriber"> | Date | string
  }

  export type AlertWhereInput = {
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    id?: StringFilter<"Alert"> | string
    subscriberId?: StringFilter<"Alert"> | string
    incidentId?: StringNullableFilter<"Alert"> | string | null
    subject?: StringFilter<"Alert"> | string
    body?: StringFilter<"Alert"> | string
    status?: EnumAlertStatusFilter<"Alert"> | $Enums.AlertStatus
    sentAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    subscriber?: XOR<SubscriberRelationFilter, SubscriberWhereInput>
  }

  export type AlertOrderByWithRelationInput = {
    id?: SortOrder
    subscriberId?: SortOrder
    incidentId?: SortOrderInput | SortOrder
    subject?: SortOrder
    body?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    subscriber?: SubscriberOrderByWithRelationInput
  }

  export type AlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    subscriberId?: StringFilter<"Alert"> | string
    incidentId?: StringNullableFilter<"Alert"> | string | null
    subject?: StringFilter<"Alert"> | string
    body?: StringFilter<"Alert"> | string
    status?: EnumAlertStatusFilter<"Alert"> | $Enums.AlertStatus
    sentAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    subscriber?: XOR<SubscriberRelationFilter, SubscriberWhereInput>
  }, "id">

  export type AlertOrderByWithAggregationInput = {
    id?: SortOrder
    subscriberId?: SortOrder
    incidentId?: SortOrderInput | SortOrder
    subject?: SortOrder
    body?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AlertCountOrderByAggregateInput
    _max?: AlertMaxOrderByAggregateInput
    _min?: AlertMinOrderByAggregateInput
  }

  export type AlertScalarWhereWithAggregatesInput = {
    AND?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    OR?: AlertScalarWhereWithAggregatesInput[]
    NOT?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Alert"> | string
    subscriberId?: StringWithAggregatesFilter<"Alert"> | string
    incidentId?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    subject?: StringWithAggregatesFilter<"Alert"> | string
    body?: StringWithAggregatesFilter<"Alert"> | string
    status?: EnumAlertStatusWithAggregatesFilter<"Alert"> | $Enums.AlertStatus
    sentAt?: DateTimeNullableWithAggregatesFilter<"Alert"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
  }

  export type NotificationChannelWhereInput = {
    AND?: NotificationChannelWhereInput | NotificationChannelWhereInput[]
    OR?: NotificationChannelWhereInput[]
    NOT?: NotificationChannelWhereInput | NotificationChannelWhereInput[]
    id?: StringFilter<"NotificationChannel"> | string
    name?: StringFilter<"NotificationChannel"> | string
    type?: EnumNotificationChannelTypeFilter<"NotificationChannel"> | $Enums.NotificationChannelType
    config?: JsonFilter<"NotificationChannel">
    enabled?: BoolFilter<"NotificationChannel"> | boolean
    orgId?: StringFilter<"NotificationChannel"> | string
    createdAt?: DateTimeFilter<"NotificationChannel"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationChannel"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }

  export type NotificationChannelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    config?: SortOrder
    enabled?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
  }

  export type NotificationChannelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationChannelWhereInput | NotificationChannelWhereInput[]
    OR?: NotificationChannelWhereInput[]
    NOT?: NotificationChannelWhereInput | NotificationChannelWhereInput[]
    name?: StringFilter<"NotificationChannel"> | string
    type?: EnumNotificationChannelTypeFilter<"NotificationChannel"> | $Enums.NotificationChannelType
    config?: JsonFilter<"NotificationChannel">
    enabled?: BoolFilter<"NotificationChannel"> | boolean
    orgId?: StringFilter<"NotificationChannel"> | string
    createdAt?: DateTimeFilter<"NotificationChannel"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationChannel"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }, "id">

  export type NotificationChannelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    config?: SortOrder
    enabled?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationChannelCountOrderByAggregateInput
    _max?: NotificationChannelMaxOrderByAggregateInput
    _min?: NotificationChannelMinOrderByAggregateInput
  }

  export type NotificationChannelScalarWhereWithAggregatesInput = {
    AND?: NotificationChannelScalarWhereWithAggregatesInput | NotificationChannelScalarWhereWithAggregatesInput[]
    OR?: NotificationChannelScalarWhereWithAggregatesInput[]
    NOT?: NotificationChannelScalarWhereWithAggregatesInput | NotificationChannelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationChannel"> | string
    name?: StringWithAggregatesFilter<"NotificationChannel"> | string
    type?: EnumNotificationChannelTypeWithAggregatesFilter<"NotificationChannel"> | $Enums.NotificationChannelType
    config?: JsonWithAggregatesFilter<"NotificationChannel">
    enabled?: BoolWithAggregatesFilter<"NotificationChannel"> | boolean
    orgId?: StringWithAggregatesFilter<"NotificationChannel"> | string
    createdAt?: DateTimeWithAggregatesFilter<"NotificationChannel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationChannel"> | Date | string
  }

  export type ApiKeyWhereInput = {
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    key?: StringFilter<"ApiKey"> | string
    orgId?: StringFilter<"ApiKey"> | string
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }

  export type ApiKeyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    orgId?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
  }

  export type ApiKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    name?: StringFilter<"ApiKey"> | string
    orgId?: StringFilter<"ApiKey"> | string
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }, "id" | "key">

  export type ApiKeyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    orgId?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ApiKeyCountOrderByAggregateInput
    _max?: ApiKeyMaxOrderByAggregateInput
    _min?: ApiKeyMinOrderByAggregateInput
  }

  export type ApiKeyScalarWhereWithAggregatesInput = {
    AND?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    OR?: ApiKeyScalarWhereWithAggregatesInput[]
    NOT?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiKey"> | string
    name?: StringWithAggregatesFilter<"ApiKey"> | string
    key?: StringWithAggregatesFilter<"ApiKey"> | string
    orgId?: StringWithAggregatesFilter<"ApiKey"> | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
  }

  export type StatusPageConfigWhereInput = {
    AND?: StatusPageConfigWhereInput | StatusPageConfigWhereInput[]
    OR?: StatusPageConfigWhereInput[]
    NOT?: StatusPageConfigWhereInput | StatusPageConfigWhereInput[]
    id?: StringFilter<"StatusPageConfig"> | string
    orgId?: StringFilter<"StatusPageConfig"> | string
    title?: StringFilter<"StatusPageConfig"> | string
    description?: StringNullableFilter<"StatusPageConfig"> | string | null
    logoUrl?: StringNullableFilter<"StatusPageConfig"> | string | null
    faviconUrl?: StringNullableFilter<"StatusPageConfig"> | string | null
    customDomain?: StringNullableFilter<"StatusPageConfig"> | string | null
    customCss?: StringNullableFilter<"StatusPageConfig"> | string | null
    showUptime?: BoolFilter<"StatusPageConfig"> | boolean
    showResponseTime?: BoolFilter<"StatusPageConfig"> | boolean
    createdAt?: DateTimeFilter<"StatusPageConfig"> | Date | string
    updatedAt?: DateTimeFilter<"StatusPageConfig"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }

  export type StatusPageConfigOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    faviconUrl?: SortOrderInput | SortOrder
    customDomain?: SortOrderInput | SortOrder
    customCss?: SortOrderInput | SortOrder
    showUptime?: SortOrder
    showResponseTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
  }

  export type StatusPageConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orgId?: string
    AND?: StatusPageConfigWhereInput | StatusPageConfigWhereInput[]
    OR?: StatusPageConfigWhereInput[]
    NOT?: StatusPageConfigWhereInput | StatusPageConfigWhereInput[]
    title?: StringFilter<"StatusPageConfig"> | string
    description?: StringNullableFilter<"StatusPageConfig"> | string | null
    logoUrl?: StringNullableFilter<"StatusPageConfig"> | string | null
    faviconUrl?: StringNullableFilter<"StatusPageConfig"> | string | null
    customDomain?: StringNullableFilter<"StatusPageConfig"> | string | null
    customCss?: StringNullableFilter<"StatusPageConfig"> | string | null
    showUptime?: BoolFilter<"StatusPageConfig"> | boolean
    showResponseTime?: BoolFilter<"StatusPageConfig"> | boolean
    createdAt?: DateTimeFilter<"StatusPageConfig"> | Date | string
    updatedAt?: DateTimeFilter<"StatusPageConfig"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }, "id" | "orgId">

  export type StatusPageConfigOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    faviconUrl?: SortOrderInput | SortOrder
    customDomain?: SortOrderInput | SortOrder
    customCss?: SortOrderInput | SortOrder
    showUptime?: SortOrder
    showResponseTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StatusPageConfigCountOrderByAggregateInput
    _max?: StatusPageConfigMaxOrderByAggregateInput
    _min?: StatusPageConfigMinOrderByAggregateInput
  }

  export type StatusPageConfigScalarWhereWithAggregatesInput = {
    AND?: StatusPageConfigScalarWhereWithAggregatesInput | StatusPageConfigScalarWhereWithAggregatesInput[]
    OR?: StatusPageConfigScalarWhereWithAggregatesInput[]
    NOT?: StatusPageConfigScalarWhereWithAggregatesInput | StatusPageConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StatusPageConfig"> | string
    orgId?: StringWithAggregatesFilter<"StatusPageConfig"> | string
    title?: StringWithAggregatesFilter<"StatusPageConfig"> | string
    description?: StringNullableWithAggregatesFilter<"StatusPageConfig"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"StatusPageConfig"> | string | null
    faviconUrl?: StringNullableWithAggregatesFilter<"StatusPageConfig"> | string | null
    customDomain?: StringNullableWithAggregatesFilter<"StatusPageConfig"> | string | null
    customCss?: StringNullableWithAggregatesFilter<"StatusPageConfig"> | string | null
    showUptime?: BoolWithAggregatesFilter<"StatusPageConfig"> | boolean
    showResponseTime?: BoolWithAggregatesFilter<"StatusPageConfig"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StatusPageConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StatusPageConfig"> | Date | string
  }

  export type OrganizationCreateInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MemberCreateNestedManyWithoutOrganizationInput
    monitors?: MonitorCreateNestedManyWithoutOrganizationInput
    components?: ComponentCreateNestedManyWithoutOrganizationInput
    componentGroups?: ComponentGroupCreateNestedManyWithoutOrganizationInput
    incidents?: IncidentCreateNestedManyWithoutOrganizationInput
    subscribers?: SubscriberCreateNestedManyWithoutOrganizationInput
    notificationChannels?: NotificationChannelCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput
    statusPageConfig?: StatusPageConfigCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    monitors?: MonitorUncheckedCreateNestedManyWithoutOrganizationInput
    components?: ComponentUncheckedCreateNestedManyWithoutOrganizationInput
    componentGroups?: ComponentGroupUncheckedCreateNestedManyWithoutOrganizationInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrganizationInput
    subscribers?: SubscriberUncheckedCreateNestedManyWithoutOrganizationInput
    notificationChannels?: NotificationChannelUncheckedCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput
    statusPageConfig?: StatusPageConfigUncheckedCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    monitors?: MonitorUpdateManyWithoutOrganizationNestedInput
    components?: ComponentUpdateManyWithoutOrganizationNestedInput
    componentGroups?: ComponentGroupUpdateManyWithoutOrganizationNestedInput
    incidents?: IncidentUpdateManyWithoutOrganizationNestedInput
    subscribers?: SubscriberUpdateManyWithoutOrganizationNestedInput
    notificationChannels?: NotificationChannelUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput
    statusPageConfig?: StatusPageConfigUpdateOneWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    monitors?: MonitorUncheckedUpdateManyWithoutOrganizationNestedInput
    components?: ComponentUncheckedUpdateManyWithoutOrganizationNestedInput
    componentGroups?: ComponentGroupUncheckedUpdateManyWithoutOrganizationNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrganizationNestedInput
    subscribers?: SubscriberUncheckedUpdateManyWithoutOrganizationNestedInput
    notificationChannels?: NotificationChannelUncheckedUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput
    statusPageConfig?: StatusPageConfigUncheckedUpdateOneWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.MemberRole
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.MemberRole
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberCreateManyInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.MemberRole
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitorCreateInput = {
    id?: string
    name: string
    type: $Enums.MonitorType
    url?: string | null
    target?: string | null
    method?: $Enums.HttpMethod
    interval?: number
    timeout?: number
    status?: $Enums.MonitorStatus
    currentStatus?: string
    enabled?: boolean
    headers?: NullableJsonNullValueInput | InputJsonValue
    body?: string | null
    expectedStatus?: number | null
    keyword?: string | null
    keywordType?: $Enums.KeywordType | null
    heartbeatToken?: string | null
    heartbeatGrace?: number | null
    sslExpiryThreshold?: number | null
    alertAfter?: number
    recoveryAfter?: number
    lastCheckedAt?: Date | string | null
    uptimeDay?: number | null
    uptimeWeek?: number | null
    uptimeMonth?: number | null
    avgResponseTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutMonitorsInput
    component?: ComponentCreateNestedOneWithoutMonitorsInput
    checks?: MonitorCheckCreateNestedManyWithoutMonitorInput
    alerts?: MonitorAlertCreateNestedManyWithoutMonitorInput
  }

  export type MonitorUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.MonitorType
    url?: string | null
    target?: string | null
    method?: $Enums.HttpMethod
    interval?: number
    timeout?: number
    status?: $Enums.MonitorStatus
    currentStatus?: string
    enabled?: boolean
    orgId: string
    componentId?: string | null
    headers?: NullableJsonNullValueInput | InputJsonValue
    body?: string | null
    expectedStatus?: number | null
    keyword?: string | null
    keywordType?: $Enums.KeywordType | null
    heartbeatToken?: string | null
    heartbeatGrace?: number | null
    sslExpiryThreshold?: number | null
    alertAfter?: number
    recoveryAfter?: number
    lastCheckedAt?: Date | string | null
    uptimeDay?: number | null
    uptimeWeek?: number | null
    uptimeMonth?: number | null
    avgResponseTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checks?: MonitorCheckUncheckedCreateNestedManyWithoutMonitorInput
    alerts?: MonitorAlertUncheckedCreateNestedManyWithoutMonitorInput
  }

  export type MonitorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMonitorTypeFieldUpdateOperationsInput | $Enums.MonitorType
    url?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod
    interval?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    status?: EnumMonitorStatusFieldUpdateOperationsInput | $Enums.MonitorStatus
    currentStatus?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    headers?: NullableJsonNullValueInput | InputJsonValue
    body?: NullableStringFieldUpdateOperationsInput | string | null
    expectedStatus?: NullableIntFieldUpdateOperationsInput | number | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    keywordType?: NullableEnumKeywordTypeFieldUpdateOperationsInput | $Enums.KeywordType | null
    heartbeatToken?: NullableStringFieldUpdateOperationsInput | string | null
    heartbeatGrace?: NullableIntFieldUpdateOperationsInput | number | null
    sslExpiryThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    alertAfter?: IntFieldUpdateOperationsInput | number
    recoveryAfter?: IntFieldUpdateOperationsInput | number
    lastCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uptimeDay?: NullableFloatFieldUpdateOperationsInput | number | null
    uptimeWeek?: NullableFloatFieldUpdateOperationsInput | number | null
    uptimeMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    avgResponseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutMonitorsNestedInput
    component?: ComponentUpdateOneWithoutMonitorsNestedInput
    checks?: MonitorCheckUpdateManyWithoutMonitorNestedInput
    alerts?: MonitorAlertUpdateManyWithoutMonitorNestedInput
  }

  export type MonitorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMonitorTypeFieldUpdateOperationsInput | $Enums.MonitorType
    url?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod
    interval?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    status?: EnumMonitorStatusFieldUpdateOperationsInput | $Enums.MonitorStatus
    currentStatus?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    orgId?: StringFieldUpdateOperationsInput | string
    componentId?: NullableStringFieldUpdateOperationsInput | string | null
    headers?: NullableJsonNullValueInput | InputJsonValue
    body?: NullableStringFieldUpdateOperationsInput | string | null
    expectedStatus?: NullableIntFieldUpdateOperationsInput | number | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    keywordType?: NullableEnumKeywordTypeFieldUpdateOperationsInput | $Enums.KeywordType | null
    heartbeatToken?: NullableStringFieldUpdateOperationsInput | string | null
    heartbeatGrace?: NullableIntFieldUpdateOperationsInput | number | null
    sslExpiryThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    alertAfter?: IntFieldUpdateOperationsInput | number
    recoveryAfter?: IntFieldUpdateOperationsInput | number
    lastCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uptimeDay?: NullableFloatFieldUpdateOperationsInput | number | null
    uptimeWeek?: NullableFloatFieldUpdateOperationsInput | number | null
    uptimeMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    avgResponseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checks?: MonitorCheckUncheckedUpdateManyWithoutMonitorNestedInput
    alerts?: MonitorAlertUncheckedUpdateManyWithoutMonitorNestedInput
  }

  export type MonitorCreateManyInput = {
    id?: string
    name: string
    type: $Enums.MonitorType
    url?: string | null
    target?: string | null
    method?: $Enums.HttpMethod
    interval?: number
    timeout?: number
    status?: $Enums.MonitorStatus
    currentStatus?: string
    enabled?: boolean
    orgId: string
    componentId?: string | null
    headers?: NullableJsonNullValueInput | InputJsonValue
    body?: string | null
    expectedStatus?: number | null
    keyword?: string | null
    keywordType?: $Enums.KeywordType | null
    heartbeatToken?: string | null
    heartbeatGrace?: number | null
    sslExpiryThreshold?: number | null
    alertAfter?: number
    recoveryAfter?: number
    lastCheckedAt?: Date | string | null
    uptimeDay?: number | null
    uptimeWeek?: number | null
    uptimeMonth?: number | null
    avgResponseTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MonitorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMonitorTypeFieldUpdateOperationsInput | $Enums.MonitorType
    url?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod
    interval?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    status?: EnumMonitorStatusFieldUpdateOperationsInput | $Enums.MonitorStatus
    currentStatus?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    headers?: NullableJsonNullValueInput | InputJsonValue
    body?: NullableStringFieldUpdateOperationsInput | string | null
    expectedStatus?: NullableIntFieldUpdateOperationsInput | number | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    keywordType?: NullableEnumKeywordTypeFieldUpdateOperationsInput | $Enums.KeywordType | null
    heartbeatToken?: NullableStringFieldUpdateOperationsInput | string | null
    heartbeatGrace?: NullableIntFieldUpdateOperationsInput | number | null
    sslExpiryThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    alertAfter?: IntFieldUpdateOperationsInput | number
    recoveryAfter?: IntFieldUpdateOperationsInput | number
    lastCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uptimeDay?: NullableFloatFieldUpdateOperationsInput | number | null
    uptimeWeek?: NullableFloatFieldUpdateOperationsInput | number | null
    uptimeMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    avgResponseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMonitorTypeFieldUpdateOperationsInput | $Enums.MonitorType
    url?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod
    interval?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    status?: EnumMonitorStatusFieldUpdateOperationsInput | $Enums.MonitorStatus
    currentStatus?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    orgId?: StringFieldUpdateOperationsInput | string
    componentId?: NullableStringFieldUpdateOperationsInput | string | null
    headers?: NullableJsonNullValueInput | InputJsonValue
    body?: NullableStringFieldUpdateOperationsInput | string | null
    expectedStatus?: NullableIntFieldUpdateOperationsInput | number | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    keywordType?: NullableEnumKeywordTypeFieldUpdateOperationsInput | $Enums.KeywordType | null
    heartbeatToken?: NullableStringFieldUpdateOperationsInput | string | null
    heartbeatGrace?: NullableIntFieldUpdateOperationsInput | number | null
    sslExpiryThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    alertAfter?: IntFieldUpdateOperationsInput | number
    recoveryAfter?: IntFieldUpdateOperationsInput | number
    lastCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uptimeDay?: NullableFloatFieldUpdateOperationsInput | number | null
    uptimeWeek?: NullableFloatFieldUpdateOperationsInput | number | null
    uptimeMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    avgResponseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitorCheckCreateInput = {
    id?: string
    status: $Enums.MonitorStatus
    responseTime?: number | null
    statusCode?: number | null
    message?: string | null
    error?: string | null
    region?: string | null
    checkedAt?: Date | string
    monitor: MonitorCreateNestedOneWithoutChecksInput
  }

  export type MonitorCheckUncheckedCreateInput = {
    id?: string
    monitorId: string
    status: $Enums.MonitorStatus
    responseTime?: number | null
    statusCode?: number | null
    message?: string | null
    error?: string | null
    region?: string | null
    checkedAt?: Date | string
  }

  export type MonitorCheckUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumMonitorStatusFieldUpdateOperationsInput | $Enums.MonitorStatus
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monitor?: MonitorUpdateOneRequiredWithoutChecksNestedInput
  }

  export type MonitorCheckUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    monitorId?: StringFieldUpdateOperationsInput | string
    status?: EnumMonitorStatusFieldUpdateOperationsInput | $Enums.MonitorStatus
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitorCheckCreateManyInput = {
    id?: string
    monitorId: string
    status: $Enums.MonitorStatus
    responseTime?: number | null
    statusCode?: number | null
    message?: string | null
    error?: string | null
    region?: string | null
    checkedAt?: Date | string
  }

  export type MonitorCheckUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumMonitorStatusFieldUpdateOperationsInput | $Enums.MonitorStatus
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitorCheckUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    monitorId?: StringFieldUpdateOperationsInput | string
    status?: EnumMonitorStatusFieldUpdateOperationsInput | $Enums.MonitorStatus
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitorAlertCreateInput = {
    id?: string
    type: string
    message: string
    createdAt?: Date | string
    monitor: MonitorCreateNestedOneWithoutAlertsInput
  }

  export type MonitorAlertUncheckedCreateInput = {
    id?: string
    monitorId: string
    type: string
    message: string
    createdAt?: Date | string
  }

  export type MonitorAlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monitor?: MonitorUpdateOneRequiredWithoutAlertsNestedInput
  }

  export type MonitorAlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    monitorId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitorAlertCreateManyInput = {
    id?: string
    monitorId: string
    type: string
    message: string
    createdAt?: Date | string
  }

  export type MonitorAlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitorAlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    monitorId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComponentGroupCreateInput = {
    id?: string
    name: string
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutComponentGroupsInput
    components?: ComponentCreateNestedManyWithoutGroupInput
  }

  export type ComponentGroupUncheckedCreateInput = {
    id?: string
    name: string
    order?: number
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    components?: ComponentUncheckedCreateNestedManyWithoutGroupInput
  }

  export type ComponentGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutComponentGroupsNestedInput
    components?: ComponentUpdateManyWithoutGroupNestedInput
  }

  export type ComponentGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    components?: ComponentUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type ComponentGroupCreateManyInput = {
    id?: string
    name: string
    order?: number
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComponentGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComponentGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComponentCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ComponentStatus
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutComponentsInput
    group?: ComponentGroupCreateNestedOneWithoutComponentsInput
    monitors?: MonitorCreateNestedManyWithoutComponentInput
    incidents?: IncidentComponentCreateNestedManyWithoutComponentInput
  }

  export type ComponentUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ComponentStatus
    order?: number
    orgId: string
    groupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    monitors?: MonitorUncheckedCreateNestedManyWithoutComponentInput
    incidents?: IncidentComponentUncheckedCreateNestedManyWithoutComponentInput
  }

  export type ComponentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComponentStatusFieldUpdateOperationsInput | $Enums.ComponentStatus
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutComponentsNestedInput
    group?: ComponentGroupUpdateOneWithoutComponentsNestedInput
    monitors?: MonitorUpdateManyWithoutComponentNestedInput
    incidents?: IncidentComponentUpdateManyWithoutComponentNestedInput
  }

  export type ComponentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComponentStatusFieldUpdateOperationsInput | $Enums.ComponentStatus
    order?: IntFieldUpdateOperationsInput | number
    orgId?: StringFieldUpdateOperationsInput | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monitors?: MonitorUncheckedUpdateManyWithoutComponentNestedInput
    incidents?: IncidentComponentUncheckedUpdateManyWithoutComponentNestedInput
  }

  export type ComponentCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ComponentStatus
    order?: number
    orgId: string
    groupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComponentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComponentStatusFieldUpdateOperationsInput | $Enums.ComponentStatus
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComponentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComponentStatusFieldUpdateOperationsInput | $Enums.ComponentStatus
    order?: IntFieldUpdateOperationsInput | number
    orgId?: StringFieldUpdateOperationsInput | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentCreateInput = {
    id?: string
    title: string
    status?: $Enums.IncidentStatus
    severity?: $Enums.IncidentSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    organization: OrganizationCreateNestedOneWithoutIncidentsInput
    updates?: IncidentUpdateCreateNestedManyWithoutIncidentInput
    components?: IncidentComponentCreateNestedManyWithoutIncidentInput
  }

  export type IncidentUncheckedCreateInput = {
    id?: string
    title: string
    status?: $Enums.IncidentStatus
    severity?: $Enums.IncidentSeverity
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    updates?: IncidentUpdateUncheckedCreateNestedManyWithoutIncidentInput
    components?: IncidentComponentUncheckedCreateNestedManyWithoutIncidentInput
  }

  export type IncidentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: OrganizationUpdateOneRequiredWithoutIncidentsNestedInput
    updates?: IncidentUpdateUpdateManyWithoutIncidentNestedInput
    components?: IncidentComponentUpdateManyWithoutIncidentNestedInput
  }

  export type IncidentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updates?: IncidentUpdateUncheckedUpdateManyWithoutIncidentNestedInput
    components?: IncidentComponentUncheckedUpdateManyWithoutIncidentNestedInput
  }

  export type IncidentCreateManyInput = {
    id?: string
    title: string
    status?: $Enums.IncidentStatus
    severity?: $Enums.IncidentSeverity
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type IncidentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IncidentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IncidentUpdateCreateInput = {
    id?: string
    status: $Enums.IncidentStatus
    message: string
    createdAt?: Date | string
    incident: IncidentCreateNestedOneWithoutUpdatesInput
  }

  export type IncidentUpdateUncheckedCreateInput = {
    id?: string
    incidentId: string
    status: $Enums.IncidentStatus
    message: string
    createdAt?: Date | string
  }

  export type IncidentUpdateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    incident?: IncidentUpdateOneRequiredWithoutUpdatesNestedInput
  }

  export type IncidentUpdateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUpdateCreateManyInput = {
    id?: string
    incidentId: string
    status: $Enums.IncidentStatus
    message: string
    createdAt?: Date | string
  }

  export type IncidentUpdateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUpdateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentComponentCreateInput = {
    id?: string
    status: $Enums.ComponentStatus
    incident: IncidentCreateNestedOneWithoutComponentsInput
    component: ComponentCreateNestedOneWithoutIncidentsInput
  }

  export type IncidentComponentUncheckedCreateInput = {
    id?: string
    incidentId: string
    componentId: string
    status: $Enums.ComponentStatus
  }

  export type IncidentComponentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumComponentStatusFieldUpdateOperationsInput | $Enums.ComponentStatus
    incident?: IncidentUpdateOneRequiredWithoutComponentsNestedInput
    component?: ComponentUpdateOneRequiredWithoutIncidentsNestedInput
  }

  export type IncidentComponentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    status?: EnumComponentStatusFieldUpdateOperationsInput | $Enums.ComponentStatus
  }

  export type IncidentComponentCreateManyInput = {
    id?: string
    incidentId: string
    componentId: string
    status: $Enums.ComponentStatus
  }

  export type IncidentComponentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumComponentStatusFieldUpdateOperationsInput | $Enums.ComponentStatus
  }

  export type IncidentComponentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    status?: EnumComponentStatusFieldUpdateOperationsInput | $Enums.ComponentStatus
  }

  export type SubscriberCreateInput = {
    id?: string
    type?: $Enums.SubscriberType
    email?: string | null
    webhookUrl?: string | null
    confirmed?: boolean
    token?: string
    createdAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutSubscribersInput
    alerts?: AlertCreateNestedManyWithoutSubscriberInput
  }

  export type SubscriberUncheckedCreateInput = {
    id?: string
    type?: $Enums.SubscriberType
    email?: string | null
    webhookUrl?: string | null
    confirmed?: boolean
    token?: string
    orgId: string
    createdAt?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutSubscriberInput
  }

  export type SubscriberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriberTypeFieldUpdateOperationsInput | $Enums.SubscriberType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutSubscribersNestedInput
    alerts?: AlertUpdateManyWithoutSubscriberNestedInput
  }

  export type SubscriberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriberTypeFieldUpdateOperationsInput | $Enums.SubscriberType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutSubscriberNestedInput
  }

  export type SubscriberCreateManyInput = {
    id?: string
    type?: $Enums.SubscriberType
    email?: string | null
    webhookUrl?: string | null
    confirmed?: boolean
    token?: string
    orgId: string
    createdAt?: Date | string
  }

  export type SubscriberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriberTypeFieldUpdateOperationsInput | $Enums.SubscriberType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriberTypeFieldUpdateOperationsInput | $Enums.SubscriberType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertCreateInput = {
    id?: string
    incidentId?: string | null
    subject: string
    body: string
    status?: $Enums.AlertStatus
    sentAt?: Date | string | null
    createdAt?: Date | string
    subscriber: SubscriberCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateInput = {
    id?: string
    subscriberId: string
    incidentId?: string | null
    subject: string
    body: string
    status?: $Enums.AlertStatus
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriber?: SubscriberUpdateOneRequiredWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriberId?: StringFieldUpdateOperationsInput | string
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertCreateManyInput = {
    id?: string
    subscriberId: string
    incidentId?: string | null
    subject: string
    body: string
    status?: $Enums.AlertStatus
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriberId?: StringFieldUpdateOperationsInput | string
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationChannelCreateInput = {
    id?: string
    name: string
    type: $Enums.NotificationChannelType
    config: JsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutNotificationChannelsInput
  }

  export type NotificationChannelUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.NotificationChannelType
    config: JsonNullValueInput | InputJsonValue
    enabled?: boolean
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationChannelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationChannelTypeFieldUpdateOperationsInput | $Enums.NotificationChannelType
    config?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutNotificationChannelsNestedInput
  }

  export type NotificationChannelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationChannelTypeFieldUpdateOperationsInput | $Enums.NotificationChannelType
    config?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationChannelCreateManyInput = {
    id?: string
    name: string
    type: $Enums.NotificationChannelType
    config: JsonNullValueInput | InputJsonValue
    enabled?: boolean
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationChannelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationChannelTypeFieldUpdateOperationsInput | $Enums.NotificationChannelType
    config?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationChannelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationChannelTypeFieldUpdateOperationsInput | $Enums.NotificationChannelType
    config?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateInput = {
    id?: string
    name: string
    key: string
    expiresAt?: Date | string | null
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutApiKeysInput
  }

  export type ApiKeyUncheckedCreateInput = {
    id?: string
    name: string
    key: string
    orgId: string
    expiresAt?: Date | string | null
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ApiKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutApiKeysNestedInput
  }

  export type ApiKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateManyInput = {
    id?: string
    name: string
    key: string
    orgId: string
    expiresAt?: Date | string | null
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ApiKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusPageConfigCreateInput = {
    id?: string
    title: string
    description?: string | null
    logoUrl?: string | null
    faviconUrl?: string | null
    customDomain?: string | null
    customCss?: string | null
    showUptime?: boolean
    showResponseTime?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutStatusPageConfigInput
  }

  export type StatusPageConfigUncheckedCreateInput = {
    id?: string
    orgId: string
    title: string
    description?: string | null
    logoUrl?: string | null
    faviconUrl?: string | null
    customDomain?: string | null
    customCss?: string | null
    showUptime?: boolean
    showResponseTime?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatusPageConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    faviconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    customCss?: NullableStringFieldUpdateOperationsInput | string | null
    showUptime?: BoolFieldUpdateOperationsInput | boolean
    showResponseTime?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutStatusPageConfigNestedInput
  }

  export type StatusPageConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    faviconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    customCss?: NullableStringFieldUpdateOperationsInput | string | null
    showUptime?: BoolFieldUpdateOperationsInput | boolean
    showResponseTime?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusPageConfigCreateManyInput = {
    id?: string
    orgId: string
    title: string
    description?: string | null
    logoUrl?: string | null
    faviconUrl?: string | null
    customDomain?: string | null
    customCss?: string | null
    showUptime?: boolean
    showResponseTime?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatusPageConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    faviconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    customCss?: NullableStringFieldUpdateOperationsInput | string | null
    showUptime?: BoolFieldUpdateOperationsInput | boolean
    showResponseTime?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusPageConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    faviconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    customCss?: NullableStringFieldUpdateOperationsInput | string | null
    showUptime?: BoolFieldUpdateOperationsInput | boolean
    showResponseTime?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type MemberListRelationFilter = {
    every?: MemberWhereInput
    some?: MemberWhereInput
    none?: MemberWhereInput
  }

  export type MonitorListRelationFilter = {
    every?: MonitorWhereInput
    some?: MonitorWhereInput
    none?: MonitorWhereInput
  }

  export type ComponentListRelationFilter = {
    every?: ComponentWhereInput
    some?: ComponentWhereInput
    none?: ComponentWhereInput
  }

  export type ComponentGroupListRelationFilter = {
    every?: ComponentGroupWhereInput
    some?: ComponentGroupWhereInput
    none?: ComponentGroupWhereInput
  }

  export type IncidentListRelationFilter = {
    every?: IncidentWhereInput
    some?: IncidentWhereInput
    none?: IncidentWhereInput
  }

  export type SubscriberListRelationFilter = {
    every?: SubscriberWhereInput
    some?: SubscriberWhereInput
    none?: SubscriberWhereInput
  }

  export type NotificationChannelListRelationFilter = {
    every?: NotificationChannelWhereInput
    some?: NotificationChannelWhereInput
    none?: NotificationChannelWhereInput
  }

  export type ApiKeyListRelationFilter = {
    every?: ApiKeyWhereInput
    some?: ApiKeyWhereInput
    none?: ApiKeyWhereInput
  }

  export type StatusPageConfigNullableRelationFilter = {
    is?: StatusPageConfigWhereInput | null
    isNot?: StatusPageConfigWhereInput | null
  }

  export type MemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MonitorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComponentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComponentGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncidentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationChannelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberRole | EnumMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberRoleFilter<$PrismaModel> | $Enums.MemberRole
  }

  export type OrganizationRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type MemberCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberRole | EnumMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.MemberRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberRoleFilter<$PrismaModel>
    _max?: NestedEnumMemberRoleFilter<$PrismaModel>
  }

  export type EnumMonitorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MonitorType | EnumMonitorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MonitorType[] | ListEnumMonitorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MonitorType[] | ListEnumMonitorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMonitorTypeFilter<$PrismaModel> | $Enums.MonitorType
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumHttpMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.HttpMethod | EnumHttpMethodFieldRefInput<$PrismaModel>
    in?: $Enums.HttpMethod[] | ListEnumHttpMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.HttpMethod[] | ListEnumHttpMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumHttpMethodFilter<$PrismaModel> | $Enums.HttpMethod
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumMonitorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MonitorStatus | EnumMonitorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MonitorStatus[] | ListEnumMonitorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MonitorStatus[] | ListEnumMonitorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMonitorStatusFilter<$PrismaModel> | $Enums.MonitorStatus
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumKeywordTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.KeywordType | EnumKeywordTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.KeywordType[] | ListEnumKeywordTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.KeywordType[] | ListEnumKeywordTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumKeywordTypeNullableFilter<$PrismaModel> | $Enums.KeywordType | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ComponentNullableRelationFilter = {
    is?: ComponentWhereInput | null
    isNot?: ComponentWhereInput | null
  }

  export type MonitorCheckListRelationFilter = {
    every?: MonitorCheckWhereInput
    some?: MonitorCheckWhereInput
    none?: MonitorCheckWhereInput
  }

  export type MonitorAlertListRelationFilter = {
    every?: MonitorAlertWhereInput
    some?: MonitorAlertWhereInput
    none?: MonitorAlertWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MonitorCheckOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MonitorAlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MonitorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    target?: SortOrder
    method?: SortOrder
    interval?: SortOrder
    timeout?: SortOrder
    status?: SortOrder
    currentStatus?: SortOrder
    enabled?: SortOrder
    orgId?: SortOrder
    componentId?: SortOrder
    headers?: SortOrder
    body?: SortOrder
    expectedStatus?: SortOrder
    keyword?: SortOrder
    keywordType?: SortOrder
    heartbeatToken?: SortOrder
    heartbeatGrace?: SortOrder
    sslExpiryThreshold?: SortOrder
    alertAfter?: SortOrder
    recoveryAfter?: SortOrder
    lastCheckedAt?: SortOrder
    uptimeDay?: SortOrder
    uptimeWeek?: SortOrder
    uptimeMonth?: SortOrder
    avgResponseTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MonitorAvgOrderByAggregateInput = {
    interval?: SortOrder
    timeout?: SortOrder
    expectedStatus?: SortOrder
    heartbeatGrace?: SortOrder
    sslExpiryThreshold?: SortOrder
    alertAfter?: SortOrder
    recoveryAfter?: SortOrder
    uptimeDay?: SortOrder
    uptimeWeek?: SortOrder
    uptimeMonth?: SortOrder
    avgResponseTime?: SortOrder
  }

  export type MonitorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    target?: SortOrder
    method?: SortOrder
    interval?: SortOrder
    timeout?: SortOrder
    status?: SortOrder
    currentStatus?: SortOrder
    enabled?: SortOrder
    orgId?: SortOrder
    componentId?: SortOrder
    body?: SortOrder
    expectedStatus?: SortOrder
    keyword?: SortOrder
    keywordType?: SortOrder
    heartbeatToken?: SortOrder
    heartbeatGrace?: SortOrder
    sslExpiryThreshold?: SortOrder
    alertAfter?: SortOrder
    recoveryAfter?: SortOrder
    lastCheckedAt?: SortOrder
    uptimeDay?: SortOrder
    uptimeWeek?: SortOrder
    uptimeMonth?: SortOrder
    avgResponseTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MonitorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    target?: SortOrder
    method?: SortOrder
    interval?: SortOrder
    timeout?: SortOrder
    status?: SortOrder
    currentStatus?: SortOrder
    enabled?: SortOrder
    orgId?: SortOrder
    componentId?: SortOrder
    body?: SortOrder
    expectedStatus?: SortOrder
    keyword?: SortOrder
    keywordType?: SortOrder
    heartbeatToken?: SortOrder
    heartbeatGrace?: SortOrder
    sslExpiryThreshold?: SortOrder
    alertAfter?: SortOrder
    recoveryAfter?: SortOrder
    lastCheckedAt?: SortOrder
    uptimeDay?: SortOrder
    uptimeWeek?: SortOrder
    uptimeMonth?: SortOrder
    avgResponseTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MonitorSumOrderByAggregateInput = {
    interval?: SortOrder
    timeout?: SortOrder
    expectedStatus?: SortOrder
    heartbeatGrace?: SortOrder
    sslExpiryThreshold?: SortOrder
    alertAfter?: SortOrder
    recoveryAfter?: SortOrder
    uptimeDay?: SortOrder
    uptimeWeek?: SortOrder
    uptimeMonth?: SortOrder
    avgResponseTime?: SortOrder
  }

  export type EnumMonitorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MonitorType | EnumMonitorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MonitorType[] | ListEnumMonitorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MonitorType[] | ListEnumMonitorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMonitorTypeWithAggregatesFilter<$PrismaModel> | $Enums.MonitorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMonitorTypeFilter<$PrismaModel>
    _max?: NestedEnumMonitorTypeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumHttpMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HttpMethod | EnumHttpMethodFieldRefInput<$PrismaModel>
    in?: $Enums.HttpMethod[] | ListEnumHttpMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.HttpMethod[] | ListEnumHttpMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumHttpMethodWithAggregatesFilter<$PrismaModel> | $Enums.HttpMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHttpMethodFilter<$PrismaModel>
    _max?: NestedEnumHttpMethodFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumMonitorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MonitorStatus | EnumMonitorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MonitorStatus[] | ListEnumMonitorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MonitorStatus[] | ListEnumMonitorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMonitorStatusWithAggregatesFilter<$PrismaModel> | $Enums.MonitorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMonitorStatusFilter<$PrismaModel>
    _max?: NestedEnumMonitorStatusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumKeywordTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KeywordType | EnumKeywordTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.KeywordType[] | ListEnumKeywordTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.KeywordType[] | ListEnumKeywordTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumKeywordTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.KeywordType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumKeywordTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumKeywordTypeNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type MonitorRelationFilter = {
    is?: MonitorWhereInput
    isNot?: MonitorWhereInput
  }

  export type MonitorCheckCountOrderByAggregateInput = {
    id?: SortOrder
    monitorId?: SortOrder
    status?: SortOrder
    responseTime?: SortOrder
    statusCode?: SortOrder
    message?: SortOrder
    error?: SortOrder
    region?: SortOrder
    checkedAt?: SortOrder
  }

  export type MonitorCheckAvgOrderByAggregateInput = {
    responseTime?: SortOrder
    statusCode?: SortOrder
  }

  export type MonitorCheckMaxOrderByAggregateInput = {
    id?: SortOrder
    monitorId?: SortOrder
    status?: SortOrder
    responseTime?: SortOrder
    statusCode?: SortOrder
    message?: SortOrder
    error?: SortOrder
    region?: SortOrder
    checkedAt?: SortOrder
  }

  export type MonitorCheckMinOrderByAggregateInput = {
    id?: SortOrder
    monitorId?: SortOrder
    status?: SortOrder
    responseTime?: SortOrder
    statusCode?: SortOrder
    message?: SortOrder
    error?: SortOrder
    region?: SortOrder
    checkedAt?: SortOrder
  }

  export type MonitorCheckSumOrderByAggregateInput = {
    responseTime?: SortOrder
    statusCode?: SortOrder
  }

  export type MonitorAlertCountOrderByAggregateInput = {
    id?: SortOrder
    monitorId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type MonitorAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    monitorId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type MonitorAlertMinOrderByAggregateInput = {
    id?: SortOrder
    monitorId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type ComponentGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComponentGroupAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ComponentGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComponentGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComponentGroupSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumComponentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ComponentStatus | EnumComponentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComponentStatus[] | ListEnumComponentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComponentStatus[] | ListEnumComponentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComponentStatusFilter<$PrismaModel> | $Enums.ComponentStatus
  }

  export type ComponentGroupNullableRelationFilter = {
    is?: ComponentGroupWhereInput | null
    isNot?: ComponentGroupWhereInput | null
  }

  export type IncidentComponentListRelationFilter = {
    every?: IncidentComponentWhereInput
    some?: IncidentComponentWhereInput
    none?: IncidentComponentWhereInput
  }

  export type IncidentComponentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComponentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    order?: SortOrder
    orgId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComponentAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ComponentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    order?: SortOrder
    orgId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComponentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    order?: SortOrder
    orgId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComponentSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumComponentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComponentStatus | EnumComponentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComponentStatus[] | ListEnumComponentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComponentStatus[] | ListEnumComponentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComponentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ComponentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComponentStatusFilter<$PrismaModel>
    _max?: NestedEnumComponentStatusFilter<$PrismaModel>
  }

  export type EnumIncidentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentStatusFilter<$PrismaModel> | $Enums.IncidentStatus
  }

  export type EnumIncidentSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentSeverity | EnumIncidentSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentSeverityFilter<$PrismaModel> | $Enums.IncidentSeverity
  }

  export type IncidentUpdateListRelationFilter = {
    every?: IncidentUpdateWhereInput
    some?: IncidentUpdateWhereInput
    none?: IncidentUpdateWhereInput
  }

  export type IncidentUpdateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncidentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    status?: SortOrder
    severity?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type IncidentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    status?: SortOrder
    severity?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type IncidentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    status?: SortOrder
    severity?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type EnumIncidentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentStatusWithAggregatesFilter<$PrismaModel> | $Enums.IncidentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentStatusFilter<$PrismaModel>
    _max?: NestedEnumIncidentStatusFilter<$PrismaModel>
  }

  export type EnumIncidentSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentSeverity | EnumIncidentSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentSeverityWithAggregatesFilter<$PrismaModel> | $Enums.IncidentSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentSeverityFilter<$PrismaModel>
    _max?: NestedEnumIncidentSeverityFilter<$PrismaModel>
  }

  export type IncidentRelationFilter = {
    is?: IncidentWhereInput
    isNot?: IncidentWhereInput
  }

  export type IncidentUpdateCountOrderByAggregateInput = {
    id?: SortOrder
    incidentId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type IncidentUpdateMaxOrderByAggregateInput = {
    id?: SortOrder
    incidentId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type IncidentUpdateMinOrderByAggregateInput = {
    id?: SortOrder
    incidentId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type ComponentRelationFilter = {
    is?: ComponentWhereInput
    isNot?: ComponentWhereInput
  }

  export type IncidentComponentIncidentIdComponentIdCompoundUniqueInput = {
    incidentId: string
    componentId: string
  }

  export type IncidentComponentCountOrderByAggregateInput = {
    id?: SortOrder
    incidentId?: SortOrder
    componentId?: SortOrder
    status?: SortOrder
  }

  export type IncidentComponentMaxOrderByAggregateInput = {
    id?: SortOrder
    incidentId?: SortOrder
    componentId?: SortOrder
    status?: SortOrder
  }

  export type IncidentComponentMinOrderByAggregateInput = {
    id?: SortOrder
    incidentId?: SortOrder
    componentId?: SortOrder
    status?: SortOrder
  }

  export type EnumSubscriberTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriberType | EnumSubscriberTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriberType[] | ListEnumSubscriberTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriberType[] | ListEnumSubscriberTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriberTypeFilter<$PrismaModel> | $Enums.SubscriberType
  }

  export type AlertListRelationFilter = {
    every?: AlertWhereInput
    some?: AlertWhereInput
    none?: AlertWhereInput
  }

  export type AlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriberCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    email?: SortOrder
    webhookUrl?: SortOrder
    confirmed?: SortOrder
    token?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
  }

  export type SubscriberMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    email?: SortOrder
    webhookUrl?: SortOrder
    confirmed?: SortOrder
    token?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
  }

  export type SubscriberMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    email?: SortOrder
    webhookUrl?: SortOrder
    confirmed?: SortOrder
    token?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumSubscriberTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriberType | EnumSubscriberTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriberType[] | ListEnumSubscriberTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriberType[] | ListEnumSubscriberTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriberTypeWithAggregatesFilter<$PrismaModel> | $Enums.SubscriberType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriberTypeFilter<$PrismaModel>
    _max?: NestedEnumSubscriberTypeFilter<$PrismaModel>
  }

  export type EnumAlertStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertStatus | EnumAlertStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertStatusFilter<$PrismaModel> | $Enums.AlertStatus
  }

  export type SubscriberRelationFilter = {
    is?: SubscriberWhereInput
    isNot?: SubscriberWhereInput
  }

  export type AlertCountOrderByAggregateInput = {
    id?: SortOrder
    subscriberId?: SortOrder
    incidentId?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AlertMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriberId?: SortOrder
    incidentId?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AlertMinOrderByAggregateInput = {
    id?: SortOrder
    subscriberId?: SortOrder
    incidentId?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAlertStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertStatus | EnumAlertStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertStatusWithAggregatesFilter<$PrismaModel> | $Enums.AlertStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertStatusFilter<$PrismaModel>
    _max?: NestedEnumAlertStatusFilter<$PrismaModel>
  }

  export type EnumNotificationChannelTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannelType | EnumNotificationChannelTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannelType[] | ListEnumNotificationChannelTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannelType[] | ListEnumNotificationChannelTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelTypeFilter<$PrismaModel> | $Enums.NotificationChannelType
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NotificationChannelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    config?: SortOrder
    enabled?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    enabled?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationChannelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    enabled?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationChannelTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannelType | EnumNotificationChannelTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannelType[] | ListEnumNotificationChannelTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannelType[] | ListEnumNotificationChannelTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationChannelType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationChannelTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationChannelTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type ApiKeyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    orgId?: SortOrder
    expiresAt?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    orgId?: SortOrder
    expiresAt?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiKeyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    orgId?: SortOrder
    expiresAt?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StatusPageConfigCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    faviconUrl?: SortOrder
    customDomain?: SortOrder
    customCss?: SortOrder
    showUptime?: SortOrder
    showResponseTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatusPageConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    faviconUrl?: SortOrder
    customDomain?: SortOrder
    customCss?: SortOrder
    showUptime?: SortOrder
    showResponseTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatusPageConfigMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    faviconUrl?: SortOrder
    customDomain?: SortOrder
    customCss?: SortOrder
    showUptime?: SortOrder
    showResponseTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput> | MemberCreateWithoutOrganizationInput[] | MemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutOrganizationInput | MemberCreateOrConnectWithoutOrganizationInput[]
    createMany?: MemberCreateManyOrganizationInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type MonitorCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<MonitorCreateWithoutOrganizationInput, MonitorUncheckedCreateWithoutOrganizationInput> | MonitorCreateWithoutOrganizationInput[] | MonitorUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MonitorCreateOrConnectWithoutOrganizationInput | MonitorCreateOrConnectWithoutOrganizationInput[]
    createMany?: MonitorCreateManyOrganizationInputEnvelope
    connect?: MonitorWhereUniqueInput | MonitorWhereUniqueInput[]
  }

  export type ComponentCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ComponentCreateWithoutOrganizationInput, ComponentUncheckedCreateWithoutOrganizationInput> | ComponentCreateWithoutOrganizationInput[] | ComponentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ComponentCreateOrConnectWithoutOrganizationInput | ComponentCreateOrConnectWithoutOrganizationInput[]
    createMany?: ComponentCreateManyOrganizationInputEnvelope
    connect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
  }

  export type ComponentGroupCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ComponentGroupCreateWithoutOrganizationInput, ComponentGroupUncheckedCreateWithoutOrganizationInput> | ComponentGroupCreateWithoutOrganizationInput[] | ComponentGroupUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ComponentGroupCreateOrConnectWithoutOrganizationInput | ComponentGroupCreateOrConnectWithoutOrganizationInput[]
    createMany?: ComponentGroupCreateManyOrganizationInputEnvelope
    connect?: ComponentGroupWhereUniqueInput | ComponentGroupWhereUniqueInput[]
  }

  export type IncidentCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<IncidentCreateWithoutOrganizationInput, IncidentUncheckedCreateWithoutOrganizationInput> | IncidentCreateWithoutOrganizationInput[] | IncidentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutOrganizationInput | IncidentCreateOrConnectWithoutOrganizationInput[]
    createMany?: IncidentCreateManyOrganizationInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type SubscriberCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<SubscriberCreateWithoutOrganizationInput, SubscriberUncheckedCreateWithoutOrganizationInput> | SubscriberCreateWithoutOrganizationInput[] | SubscriberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SubscriberCreateOrConnectWithoutOrganizationInput | SubscriberCreateOrConnectWithoutOrganizationInput[]
    createMany?: SubscriberCreateManyOrganizationInputEnvelope
    connect?: SubscriberWhereUniqueInput | SubscriberWhereUniqueInput[]
  }

  export type NotificationChannelCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<NotificationChannelCreateWithoutOrganizationInput, NotificationChannelUncheckedCreateWithoutOrganizationInput> | NotificationChannelCreateWithoutOrganizationInput[] | NotificationChannelUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: NotificationChannelCreateOrConnectWithoutOrganizationInput | NotificationChannelCreateOrConnectWithoutOrganizationInput[]
    createMany?: NotificationChannelCreateManyOrganizationInputEnvelope
    connect?: NotificationChannelWhereUniqueInput | NotificationChannelWhereUniqueInput[]
  }

  export type ApiKeyCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ApiKeyCreateWithoutOrganizationInput, ApiKeyUncheckedCreateWithoutOrganizationInput> | ApiKeyCreateWithoutOrganizationInput[] | ApiKeyUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutOrganizationInput | ApiKeyCreateOrConnectWithoutOrganizationInput[]
    createMany?: ApiKeyCreateManyOrganizationInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type StatusPageConfigCreateNestedOneWithoutOrganizationInput = {
    create?: XOR<StatusPageConfigCreateWithoutOrganizationInput, StatusPageConfigUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: StatusPageConfigCreateOrConnectWithoutOrganizationInput
    connect?: StatusPageConfigWhereUniqueInput
  }

  export type MemberUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput> | MemberCreateWithoutOrganizationInput[] | MemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutOrganizationInput | MemberCreateOrConnectWithoutOrganizationInput[]
    createMany?: MemberCreateManyOrganizationInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type MonitorUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<MonitorCreateWithoutOrganizationInput, MonitorUncheckedCreateWithoutOrganizationInput> | MonitorCreateWithoutOrganizationInput[] | MonitorUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MonitorCreateOrConnectWithoutOrganizationInput | MonitorCreateOrConnectWithoutOrganizationInput[]
    createMany?: MonitorCreateManyOrganizationInputEnvelope
    connect?: MonitorWhereUniqueInput | MonitorWhereUniqueInput[]
  }

  export type ComponentUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ComponentCreateWithoutOrganizationInput, ComponentUncheckedCreateWithoutOrganizationInput> | ComponentCreateWithoutOrganizationInput[] | ComponentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ComponentCreateOrConnectWithoutOrganizationInput | ComponentCreateOrConnectWithoutOrganizationInput[]
    createMany?: ComponentCreateManyOrganizationInputEnvelope
    connect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
  }

  export type ComponentGroupUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ComponentGroupCreateWithoutOrganizationInput, ComponentGroupUncheckedCreateWithoutOrganizationInput> | ComponentGroupCreateWithoutOrganizationInput[] | ComponentGroupUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ComponentGroupCreateOrConnectWithoutOrganizationInput | ComponentGroupCreateOrConnectWithoutOrganizationInput[]
    createMany?: ComponentGroupCreateManyOrganizationInputEnvelope
    connect?: ComponentGroupWhereUniqueInput | ComponentGroupWhereUniqueInput[]
  }

  export type IncidentUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<IncidentCreateWithoutOrganizationInput, IncidentUncheckedCreateWithoutOrganizationInput> | IncidentCreateWithoutOrganizationInput[] | IncidentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutOrganizationInput | IncidentCreateOrConnectWithoutOrganizationInput[]
    createMany?: IncidentCreateManyOrganizationInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type SubscriberUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<SubscriberCreateWithoutOrganizationInput, SubscriberUncheckedCreateWithoutOrganizationInput> | SubscriberCreateWithoutOrganizationInput[] | SubscriberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SubscriberCreateOrConnectWithoutOrganizationInput | SubscriberCreateOrConnectWithoutOrganizationInput[]
    createMany?: SubscriberCreateManyOrganizationInputEnvelope
    connect?: SubscriberWhereUniqueInput | SubscriberWhereUniqueInput[]
  }

  export type NotificationChannelUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<NotificationChannelCreateWithoutOrganizationInput, NotificationChannelUncheckedCreateWithoutOrganizationInput> | NotificationChannelCreateWithoutOrganizationInput[] | NotificationChannelUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: NotificationChannelCreateOrConnectWithoutOrganizationInput | NotificationChannelCreateOrConnectWithoutOrganizationInput[]
    createMany?: NotificationChannelCreateManyOrganizationInputEnvelope
    connect?: NotificationChannelWhereUniqueInput | NotificationChannelWhereUniqueInput[]
  }

  export type ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ApiKeyCreateWithoutOrganizationInput, ApiKeyUncheckedCreateWithoutOrganizationInput> | ApiKeyCreateWithoutOrganizationInput[] | ApiKeyUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutOrganizationInput | ApiKeyCreateOrConnectWithoutOrganizationInput[]
    createMany?: ApiKeyCreateManyOrganizationInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type StatusPageConfigUncheckedCreateNestedOneWithoutOrganizationInput = {
    create?: XOR<StatusPageConfigCreateWithoutOrganizationInput, StatusPageConfigUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: StatusPageConfigCreateOrConnectWithoutOrganizationInput
    connect?: StatusPageConfigWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type MemberUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput> | MemberCreateWithoutOrganizationInput[] | MemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutOrganizationInput | MemberCreateOrConnectWithoutOrganizationInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutOrganizationInput | MemberUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: MemberCreateManyOrganizationInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutOrganizationInput | MemberUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutOrganizationInput | MemberUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type MonitorUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<MonitorCreateWithoutOrganizationInput, MonitorUncheckedCreateWithoutOrganizationInput> | MonitorCreateWithoutOrganizationInput[] | MonitorUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MonitorCreateOrConnectWithoutOrganizationInput | MonitorCreateOrConnectWithoutOrganizationInput[]
    upsert?: MonitorUpsertWithWhereUniqueWithoutOrganizationInput | MonitorUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: MonitorCreateManyOrganizationInputEnvelope
    set?: MonitorWhereUniqueInput | MonitorWhereUniqueInput[]
    disconnect?: MonitorWhereUniqueInput | MonitorWhereUniqueInput[]
    delete?: MonitorWhereUniqueInput | MonitorWhereUniqueInput[]
    connect?: MonitorWhereUniqueInput | MonitorWhereUniqueInput[]
    update?: MonitorUpdateWithWhereUniqueWithoutOrganizationInput | MonitorUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: MonitorUpdateManyWithWhereWithoutOrganizationInput | MonitorUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: MonitorScalarWhereInput | MonitorScalarWhereInput[]
  }

  export type ComponentUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ComponentCreateWithoutOrganizationInput, ComponentUncheckedCreateWithoutOrganizationInput> | ComponentCreateWithoutOrganizationInput[] | ComponentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ComponentCreateOrConnectWithoutOrganizationInput | ComponentCreateOrConnectWithoutOrganizationInput[]
    upsert?: ComponentUpsertWithWhereUniqueWithoutOrganizationInput | ComponentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ComponentCreateManyOrganizationInputEnvelope
    set?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    disconnect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    delete?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    connect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    update?: ComponentUpdateWithWhereUniqueWithoutOrganizationInput | ComponentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ComponentUpdateManyWithWhereWithoutOrganizationInput | ComponentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ComponentScalarWhereInput | ComponentScalarWhereInput[]
  }

  export type ComponentGroupUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ComponentGroupCreateWithoutOrganizationInput, ComponentGroupUncheckedCreateWithoutOrganizationInput> | ComponentGroupCreateWithoutOrganizationInput[] | ComponentGroupUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ComponentGroupCreateOrConnectWithoutOrganizationInput | ComponentGroupCreateOrConnectWithoutOrganizationInput[]
    upsert?: ComponentGroupUpsertWithWhereUniqueWithoutOrganizationInput | ComponentGroupUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ComponentGroupCreateManyOrganizationInputEnvelope
    set?: ComponentGroupWhereUniqueInput | ComponentGroupWhereUniqueInput[]
    disconnect?: ComponentGroupWhereUniqueInput | ComponentGroupWhereUniqueInput[]
    delete?: ComponentGroupWhereUniqueInput | ComponentGroupWhereUniqueInput[]
    connect?: ComponentGroupWhereUniqueInput | ComponentGroupWhereUniqueInput[]
    update?: ComponentGroupUpdateWithWhereUniqueWithoutOrganizationInput | ComponentGroupUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ComponentGroupUpdateManyWithWhereWithoutOrganizationInput | ComponentGroupUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ComponentGroupScalarWhereInput | ComponentGroupScalarWhereInput[]
  }

  export type IncidentUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<IncidentCreateWithoutOrganizationInput, IncidentUncheckedCreateWithoutOrganizationInput> | IncidentCreateWithoutOrganizationInput[] | IncidentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutOrganizationInput | IncidentCreateOrConnectWithoutOrganizationInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutOrganizationInput | IncidentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: IncidentCreateManyOrganizationInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutOrganizationInput | IncidentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutOrganizationInput | IncidentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type SubscriberUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<SubscriberCreateWithoutOrganizationInput, SubscriberUncheckedCreateWithoutOrganizationInput> | SubscriberCreateWithoutOrganizationInput[] | SubscriberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SubscriberCreateOrConnectWithoutOrganizationInput | SubscriberCreateOrConnectWithoutOrganizationInput[]
    upsert?: SubscriberUpsertWithWhereUniqueWithoutOrganizationInput | SubscriberUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: SubscriberCreateManyOrganizationInputEnvelope
    set?: SubscriberWhereUniqueInput | SubscriberWhereUniqueInput[]
    disconnect?: SubscriberWhereUniqueInput | SubscriberWhereUniqueInput[]
    delete?: SubscriberWhereUniqueInput | SubscriberWhereUniqueInput[]
    connect?: SubscriberWhereUniqueInput | SubscriberWhereUniqueInput[]
    update?: SubscriberUpdateWithWhereUniqueWithoutOrganizationInput | SubscriberUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: SubscriberUpdateManyWithWhereWithoutOrganizationInput | SubscriberUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: SubscriberScalarWhereInput | SubscriberScalarWhereInput[]
  }

  export type NotificationChannelUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<NotificationChannelCreateWithoutOrganizationInput, NotificationChannelUncheckedCreateWithoutOrganizationInput> | NotificationChannelCreateWithoutOrganizationInput[] | NotificationChannelUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: NotificationChannelCreateOrConnectWithoutOrganizationInput | NotificationChannelCreateOrConnectWithoutOrganizationInput[]
    upsert?: NotificationChannelUpsertWithWhereUniqueWithoutOrganizationInput | NotificationChannelUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: NotificationChannelCreateManyOrganizationInputEnvelope
    set?: NotificationChannelWhereUniqueInput | NotificationChannelWhereUniqueInput[]
    disconnect?: NotificationChannelWhereUniqueInput | NotificationChannelWhereUniqueInput[]
    delete?: NotificationChannelWhereUniqueInput | NotificationChannelWhereUniqueInput[]
    connect?: NotificationChannelWhereUniqueInput | NotificationChannelWhereUniqueInput[]
    update?: NotificationChannelUpdateWithWhereUniqueWithoutOrganizationInput | NotificationChannelUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: NotificationChannelUpdateManyWithWhereWithoutOrganizationInput | NotificationChannelUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: NotificationChannelScalarWhereInput | NotificationChannelScalarWhereInput[]
  }

  export type ApiKeyUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ApiKeyCreateWithoutOrganizationInput, ApiKeyUncheckedCreateWithoutOrganizationInput> | ApiKeyCreateWithoutOrganizationInput[] | ApiKeyUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutOrganizationInput | ApiKeyCreateOrConnectWithoutOrganizationInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutOrganizationInput | ApiKeyUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ApiKeyCreateManyOrganizationInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutOrganizationInput | ApiKeyUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutOrganizationInput | ApiKeyUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type StatusPageConfigUpdateOneWithoutOrganizationNestedInput = {
    create?: XOR<StatusPageConfigCreateWithoutOrganizationInput, StatusPageConfigUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: StatusPageConfigCreateOrConnectWithoutOrganizationInput
    upsert?: StatusPageConfigUpsertWithoutOrganizationInput
    disconnect?: StatusPageConfigWhereInput | boolean
    delete?: StatusPageConfigWhereInput | boolean
    connect?: StatusPageConfigWhereUniqueInput
    update?: XOR<XOR<StatusPageConfigUpdateToOneWithWhereWithoutOrganizationInput, StatusPageConfigUpdateWithoutOrganizationInput>, StatusPageConfigUncheckedUpdateWithoutOrganizationInput>
  }

  export type MemberUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput> | MemberCreateWithoutOrganizationInput[] | MemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutOrganizationInput | MemberCreateOrConnectWithoutOrganizationInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutOrganizationInput | MemberUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: MemberCreateManyOrganizationInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutOrganizationInput | MemberUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutOrganizationInput | MemberUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type MonitorUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<MonitorCreateWithoutOrganizationInput, MonitorUncheckedCreateWithoutOrganizationInput> | MonitorCreateWithoutOrganizationInput[] | MonitorUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MonitorCreateOrConnectWithoutOrganizationInput | MonitorCreateOrConnectWithoutOrganizationInput[]
    upsert?: MonitorUpsertWithWhereUniqueWithoutOrganizationInput | MonitorUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: MonitorCreateManyOrganizationInputEnvelope
    set?: MonitorWhereUniqueInput | MonitorWhereUniqueInput[]
    disconnect?: MonitorWhereUniqueInput | MonitorWhereUniqueInput[]
    delete?: MonitorWhereUniqueInput | MonitorWhereUniqueInput[]
    connect?: MonitorWhereUniqueInput | MonitorWhereUniqueInput[]
    update?: MonitorUpdateWithWhereUniqueWithoutOrganizationInput | MonitorUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: MonitorUpdateManyWithWhereWithoutOrganizationInput | MonitorUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: MonitorScalarWhereInput | MonitorScalarWhereInput[]
  }

  export type ComponentUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ComponentCreateWithoutOrganizationInput, ComponentUncheckedCreateWithoutOrganizationInput> | ComponentCreateWithoutOrganizationInput[] | ComponentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ComponentCreateOrConnectWithoutOrganizationInput | ComponentCreateOrConnectWithoutOrganizationInput[]
    upsert?: ComponentUpsertWithWhereUniqueWithoutOrganizationInput | ComponentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ComponentCreateManyOrganizationInputEnvelope
    set?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    disconnect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    delete?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    connect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    update?: ComponentUpdateWithWhereUniqueWithoutOrganizationInput | ComponentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ComponentUpdateManyWithWhereWithoutOrganizationInput | ComponentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ComponentScalarWhereInput | ComponentScalarWhereInput[]
  }

  export type ComponentGroupUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ComponentGroupCreateWithoutOrganizationInput, ComponentGroupUncheckedCreateWithoutOrganizationInput> | ComponentGroupCreateWithoutOrganizationInput[] | ComponentGroupUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ComponentGroupCreateOrConnectWithoutOrganizationInput | ComponentGroupCreateOrConnectWithoutOrganizationInput[]
    upsert?: ComponentGroupUpsertWithWhereUniqueWithoutOrganizationInput | ComponentGroupUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ComponentGroupCreateManyOrganizationInputEnvelope
    set?: ComponentGroupWhereUniqueInput | ComponentGroupWhereUniqueInput[]
    disconnect?: ComponentGroupWhereUniqueInput | ComponentGroupWhereUniqueInput[]
    delete?: ComponentGroupWhereUniqueInput | ComponentGroupWhereUniqueInput[]
    connect?: ComponentGroupWhereUniqueInput | ComponentGroupWhereUniqueInput[]
    update?: ComponentGroupUpdateWithWhereUniqueWithoutOrganizationInput | ComponentGroupUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ComponentGroupUpdateManyWithWhereWithoutOrganizationInput | ComponentGroupUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ComponentGroupScalarWhereInput | ComponentGroupScalarWhereInput[]
  }

  export type IncidentUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<IncidentCreateWithoutOrganizationInput, IncidentUncheckedCreateWithoutOrganizationInput> | IncidentCreateWithoutOrganizationInput[] | IncidentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutOrganizationInput | IncidentCreateOrConnectWithoutOrganizationInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutOrganizationInput | IncidentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: IncidentCreateManyOrganizationInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutOrganizationInput | IncidentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutOrganizationInput | IncidentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type SubscriberUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<SubscriberCreateWithoutOrganizationInput, SubscriberUncheckedCreateWithoutOrganizationInput> | SubscriberCreateWithoutOrganizationInput[] | SubscriberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SubscriberCreateOrConnectWithoutOrganizationInput | SubscriberCreateOrConnectWithoutOrganizationInput[]
    upsert?: SubscriberUpsertWithWhereUniqueWithoutOrganizationInput | SubscriberUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: SubscriberCreateManyOrganizationInputEnvelope
    set?: SubscriberWhereUniqueInput | SubscriberWhereUniqueInput[]
    disconnect?: SubscriberWhereUniqueInput | SubscriberWhereUniqueInput[]
    delete?: SubscriberWhereUniqueInput | SubscriberWhereUniqueInput[]
    connect?: SubscriberWhereUniqueInput | SubscriberWhereUniqueInput[]
    update?: SubscriberUpdateWithWhereUniqueWithoutOrganizationInput | SubscriberUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: SubscriberUpdateManyWithWhereWithoutOrganizationInput | SubscriberUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: SubscriberScalarWhereInput | SubscriberScalarWhereInput[]
  }

  export type NotificationChannelUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<NotificationChannelCreateWithoutOrganizationInput, NotificationChannelUncheckedCreateWithoutOrganizationInput> | NotificationChannelCreateWithoutOrganizationInput[] | NotificationChannelUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: NotificationChannelCreateOrConnectWithoutOrganizationInput | NotificationChannelCreateOrConnectWithoutOrganizationInput[]
    upsert?: NotificationChannelUpsertWithWhereUniqueWithoutOrganizationInput | NotificationChannelUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: NotificationChannelCreateManyOrganizationInputEnvelope
    set?: NotificationChannelWhereUniqueInput | NotificationChannelWhereUniqueInput[]
    disconnect?: NotificationChannelWhereUniqueInput | NotificationChannelWhereUniqueInput[]
    delete?: NotificationChannelWhereUniqueInput | NotificationChannelWhereUniqueInput[]
    connect?: NotificationChannelWhereUniqueInput | NotificationChannelWhereUniqueInput[]
    update?: NotificationChannelUpdateWithWhereUniqueWithoutOrganizationInput | NotificationChannelUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: NotificationChannelUpdateManyWithWhereWithoutOrganizationInput | NotificationChannelUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: NotificationChannelScalarWhereInput | NotificationChannelScalarWhereInput[]
  }

  export type ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ApiKeyCreateWithoutOrganizationInput, ApiKeyUncheckedCreateWithoutOrganizationInput> | ApiKeyCreateWithoutOrganizationInput[] | ApiKeyUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutOrganizationInput | ApiKeyCreateOrConnectWithoutOrganizationInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutOrganizationInput | ApiKeyUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ApiKeyCreateManyOrganizationInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutOrganizationInput | ApiKeyUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutOrganizationInput | ApiKeyUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type StatusPageConfigUncheckedUpdateOneWithoutOrganizationNestedInput = {
    create?: XOR<StatusPageConfigCreateWithoutOrganizationInput, StatusPageConfigUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: StatusPageConfigCreateOrConnectWithoutOrganizationInput
    upsert?: StatusPageConfigUpsertWithoutOrganizationInput
    disconnect?: StatusPageConfigWhereInput | boolean
    delete?: StatusPageConfigWhereInput | boolean
    connect?: StatusPageConfigWhereUniqueInput
    update?: XOR<XOR<StatusPageConfigUpdateToOneWithWhereWithoutOrganizationInput, StatusPageConfigUpdateWithoutOrganizationInput>, StatusPageConfigUncheckedUpdateWithoutOrganizationInput>
  }

  export type OrganizationCreateNestedOneWithoutMembersInput = {
    create?: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type EnumMemberRoleFieldUpdateOperationsInput = {
    set?: $Enums.MemberRole
  }

  export type OrganizationUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembersInput
    upsert?: OrganizationUpsertWithoutMembersInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutMembersInput, OrganizationUpdateWithoutMembersInput>, OrganizationUncheckedUpdateWithoutMembersInput>
  }

  export type OrganizationCreateNestedOneWithoutMonitorsInput = {
    create?: XOR<OrganizationCreateWithoutMonitorsInput, OrganizationUncheckedCreateWithoutMonitorsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMonitorsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ComponentCreateNestedOneWithoutMonitorsInput = {
    create?: XOR<ComponentCreateWithoutMonitorsInput, ComponentUncheckedCreateWithoutMonitorsInput>
    connectOrCreate?: ComponentCreateOrConnectWithoutMonitorsInput
    connect?: ComponentWhereUniqueInput
  }

  export type MonitorCheckCreateNestedManyWithoutMonitorInput = {
    create?: XOR<MonitorCheckCreateWithoutMonitorInput, MonitorCheckUncheckedCreateWithoutMonitorInput> | MonitorCheckCreateWithoutMonitorInput[] | MonitorCheckUncheckedCreateWithoutMonitorInput[]
    connectOrCreate?: MonitorCheckCreateOrConnectWithoutMonitorInput | MonitorCheckCreateOrConnectWithoutMonitorInput[]
    createMany?: MonitorCheckCreateManyMonitorInputEnvelope
    connect?: MonitorCheckWhereUniqueInput | MonitorCheckWhereUniqueInput[]
  }

  export type MonitorAlertCreateNestedManyWithoutMonitorInput = {
    create?: XOR<MonitorAlertCreateWithoutMonitorInput, MonitorAlertUncheckedCreateWithoutMonitorInput> | MonitorAlertCreateWithoutMonitorInput[] | MonitorAlertUncheckedCreateWithoutMonitorInput[]
    connectOrCreate?: MonitorAlertCreateOrConnectWithoutMonitorInput | MonitorAlertCreateOrConnectWithoutMonitorInput[]
    createMany?: MonitorAlertCreateManyMonitorInputEnvelope
    connect?: MonitorAlertWhereUniqueInput | MonitorAlertWhereUniqueInput[]
  }

  export type MonitorCheckUncheckedCreateNestedManyWithoutMonitorInput = {
    create?: XOR<MonitorCheckCreateWithoutMonitorInput, MonitorCheckUncheckedCreateWithoutMonitorInput> | MonitorCheckCreateWithoutMonitorInput[] | MonitorCheckUncheckedCreateWithoutMonitorInput[]
    connectOrCreate?: MonitorCheckCreateOrConnectWithoutMonitorInput | MonitorCheckCreateOrConnectWithoutMonitorInput[]
    createMany?: MonitorCheckCreateManyMonitorInputEnvelope
    connect?: MonitorCheckWhereUniqueInput | MonitorCheckWhereUniqueInput[]
  }

  export type MonitorAlertUncheckedCreateNestedManyWithoutMonitorInput = {
    create?: XOR<MonitorAlertCreateWithoutMonitorInput, MonitorAlertUncheckedCreateWithoutMonitorInput> | MonitorAlertCreateWithoutMonitorInput[] | MonitorAlertUncheckedCreateWithoutMonitorInput[]
    connectOrCreate?: MonitorAlertCreateOrConnectWithoutMonitorInput | MonitorAlertCreateOrConnectWithoutMonitorInput[]
    createMany?: MonitorAlertCreateManyMonitorInputEnvelope
    connect?: MonitorAlertWhereUniqueInput | MonitorAlertWhereUniqueInput[]
  }

  export type EnumMonitorTypeFieldUpdateOperationsInput = {
    set?: $Enums.MonitorType
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumHttpMethodFieldUpdateOperationsInput = {
    set?: $Enums.HttpMethod
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumMonitorStatusFieldUpdateOperationsInput = {
    set?: $Enums.MonitorStatus
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumKeywordTypeFieldUpdateOperationsInput = {
    set?: $Enums.KeywordType | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrganizationUpdateOneRequiredWithoutMonitorsNestedInput = {
    create?: XOR<OrganizationCreateWithoutMonitorsInput, OrganizationUncheckedCreateWithoutMonitorsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMonitorsInput
    upsert?: OrganizationUpsertWithoutMonitorsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutMonitorsInput, OrganizationUpdateWithoutMonitorsInput>, OrganizationUncheckedUpdateWithoutMonitorsInput>
  }

  export type ComponentUpdateOneWithoutMonitorsNestedInput = {
    create?: XOR<ComponentCreateWithoutMonitorsInput, ComponentUncheckedCreateWithoutMonitorsInput>
    connectOrCreate?: ComponentCreateOrConnectWithoutMonitorsInput
    upsert?: ComponentUpsertWithoutMonitorsInput
    disconnect?: ComponentWhereInput | boolean
    delete?: ComponentWhereInput | boolean
    connect?: ComponentWhereUniqueInput
    update?: XOR<XOR<ComponentUpdateToOneWithWhereWithoutMonitorsInput, ComponentUpdateWithoutMonitorsInput>, ComponentUncheckedUpdateWithoutMonitorsInput>
  }

  export type MonitorCheckUpdateManyWithoutMonitorNestedInput = {
    create?: XOR<MonitorCheckCreateWithoutMonitorInput, MonitorCheckUncheckedCreateWithoutMonitorInput> | MonitorCheckCreateWithoutMonitorInput[] | MonitorCheckUncheckedCreateWithoutMonitorInput[]
    connectOrCreate?: MonitorCheckCreateOrConnectWithoutMonitorInput | MonitorCheckCreateOrConnectWithoutMonitorInput[]
    upsert?: MonitorCheckUpsertWithWhereUniqueWithoutMonitorInput | MonitorCheckUpsertWithWhereUniqueWithoutMonitorInput[]
    createMany?: MonitorCheckCreateManyMonitorInputEnvelope
    set?: MonitorCheckWhereUniqueInput | MonitorCheckWhereUniqueInput[]
    disconnect?: MonitorCheckWhereUniqueInput | MonitorCheckWhereUniqueInput[]
    delete?: MonitorCheckWhereUniqueInput | MonitorCheckWhereUniqueInput[]
    connect?: MonitorCheckWhereUniqueInput | MonitorCheckWhereUniqueInput[]
    update?: MonitorCheckUpdateWithWhereUniqueWithoutMonitorInput | MonitorCheckUpdateWithWhereUniqueWithoutMonitorInput[]
    updateMany?: MonitorCheckUpdateManyWithWhereWithoutMonitorInput | MonitorCheckUpdateManyWithWhereWithoutMonitorInput[]
    deleteMany?: MonitorCheckScalarWhereInput | MonitorCheckScalarWhereInput[]
  }

  export type MonitorAlertUpdateManyWithoutMonitorNestedInput = {
    create?: XOR<MonitorAlertCreateWithoutMonitorInput, MonitorAlertUncheckedCreateWithoutMonitorInput> | MonitorAlertCreateWithoutMonitorInput[] | MonitorAlertUncheckedCreateWithoutMonitorInput[]
    connectOrCreate?: MonitorAlertCreateOrConnectWithoutMonitorInput | MonitorAlertCreateOrConnectWithoutMonitorInput[]
    upsert?: MonitorAlertUpsertWithWhereUniqueWithoutMonitorInput | MonitorAlertUpsertWithWhereUniqueWithoutMonitorInput[]
    createMany?: MonitorAlertCreateManyMonitorInputEnvelope
    set?: MonitorAlertWhereUniqueInput | MonitorAlertWhereUniqueInput[]
    disconnect?: MonitorAlertWhereUniqueInput | MonitorAlertWhereUniqueInput[]
    delete?: MonitorAlertWhereUniqueInput | MonitorAlertWhereUniqueInput[]
    connect?: MonitorAlertWhereUniqueInput | MonitorAlertWhereUniqueInput[]
    update?: MonitorAlertUpdateWithWhereUniqueWithoutMonitorInput | MonitorAlertUpdateWithWhereUniqueWithoutMonitorInput[]
    updateMany?: MonitorAlertUpdateManyWithWhereWithoutMonitorInput | MonitorAlertUpdateManyWithWhereWithoutMonitorInput[]
    deleteMany?: MonitorAlertScalarWhereInput | MonitorAlertScalarWhereInput[]
  }

  export type MonitorCheckUncheckedUpdateManyWithoutMonitorNestedInput = {
    create?: XOR<MonitorCheckCreateWithoutMonitorInput, MonitorCheckUncheckedCreateWithoutMonitorInput> | MonitorCheckCreateWithoutMonitorInput[] | MonitorCheckUncheckedCreateWithoutMonitorInput[]
    connectOrCreate?: MonitorCheckCreateOrConnectWithoutMonitorInput | MonitorCheckCreateOrConnectWithoutMonitorInput[]
    upsert?: MonitorCheckUpsertWithWhereUniqueWithoutMonitorInput | MonitorCheckUpsertWithWhereUniqueWithoutMonitorInput[]
    createMany?: MonitorCheckCreateManyMonitorInputEnvelope
    set?: MonitorCheckWhereUniqueInput | MonitorCheckWhereUniqueInput[]
    disconnect?: MonitorCheckWhereUniqueInput | MonitorCheckWhereUniqueInput[]
    delete?: MonitorCheckWhereUniqueInput | MonitorCheckWhereUniqueInput[]
    connect?: MonitorCheckWhereUniqueInput | MonitorCheckWhereUniqueInput[]
    update?: MonitorCheckUpdateWithWhereUniqueWithoutMonitorInput | MonitorCheckUpdateWithWhereUniqueWithoutMonitorInput[]
    updateMany?: MonitorCheckUpdateManyWithWhereWithoutMonitorInput | MonitorCheckUpdateManyWithWhereWithoutMonitorInput[]
    deleteMany?: MonitorCheckScalarWhereInput | MonitorCheckScalarWhereInput[]
  }

  export type MonitorAlertUncheckedUpdateManyWithoutMonitorNestedInput = {
    create?: XOR<MonitorAlertCreateWithoutMonitorInput, MonitorAlertUncheckedCreateWithoutMonitorInput> | MonitorAlertCreateWithoutMonitorInput[] | MonitorAlertUncheckedCreateWithoutMonitorInput[]
    connectOrCreate?: MonitorAlertCreateOrConnectWithoutMonitorInput | MonitorAlertCreateOrConnectWithoutMonitorInput[]
    upsert?: MonitorAlertUpsertWithWhereUniqueWithoutMonitorInput | MonitorAlertUpsertWithWhereUniqueWithoutMonitorInput[]
    createMany?: MonitorAlertCreateManyMonitorInputEnvelope
    set?: MonitorAlertWhereUniqueInput | MonitorAlertWhereUniqueInput[]
    disconnect?: MonitorAlertWhereUniqueInput | MonitorAlertWhereUniqueInput[]
    delete?: MonitorAlertWhereUniqueInput | MonitorAlertWhereUniqueInput[]
    connect?: MonitorAlertWhereUniqueInput | MonitorAlertWhereUniqueInput[]
    update?: MonitorAlertUpdateWithWhereUniqueWithoutMonitorInput | MonitorAlertUpdateWithWhereUniqueWithoutMonitorInput[]
    updateMany?: MonitorAlertUpdateManyWithWhereWithoutMonitorInput | MonitorAlertUpdateManyWithWhereWithoutMonitorInput[]
    deleteMany?: MonitorAlertScalarWhereInput | MonitorAlertScalarWhereInput[]
  }

  export type MonitorCreateNestedOneWithoutChecksInput = {
    create?: XOR<MonitorCreateWithoutChecksInput, MonitorUncheckedCreateWithoutChecksInput>
    connectOrCreate?: MonitorCreateOrConnectWithoutChecksInput
    connect?: MonitorWhereUniqueInput
  }

  export type MonitorUpdateOneRequiredWithoutChecksNestedInput = {
    create?: XOR<MonitorCreateWithoutChecksInput, MonitorUncheckedCreateWithoutChecksInput>
    connectOrCreate?: MonitorCreateOrConnectWithoutChecksInput
    upsert?: MonitorUpsertWithoutChecksInput
    connect?: MonitorWhereUniqueInput
    update?: XOR<XOR<MonitorUpdateToOneWithWhereWithoutChecksInput, MonitorUpdateWithoutChecksInput>, MonitorUncheckedUpdateWithoutChecksInput>
  }

  export type MonitorCreateNestedOneWithoutAlertsInput = {
    create?: XOR<MonitorCreateWithoutAlertsInput, MonitorUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: MonitorCreateOrConnectWithoutAlertsInput
    connect?: MonitorWhereUniqueInput
  }

  export type MonitorUpdateOneRequiredWithoutAlertsNestedInput = {
    create?: XOR<MonitorCreateWithoutAlertsInput, MonitorUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: MonitorCreateOrConnectWithoutAlertsInput
    upsert?: MonitorUpsertWithoutAlertsInput
    connect?: MonitorWhereUniqueInput
    update?: XOR<XOR<MonitorUpdateToOneWithWhereWithoutAlertsInput, MonitorUpdateWithoutAlertsInput>, MonitorUncheckedUpdateWithoutAlertsInput>
  }

  export type OrganizationCreateNestedOneWithoutComponentGroupsInput = {
    create?: XOR<OrganizationCreateWithoutComponentGroupsInput, OrganizationUncheckedCreateWithoutComponentGroupsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutComponentGroupsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ComponentCreateNestedManyWithoutGroupInput = {
    create?: XOR<ComponentCreateWithoutGroupInput, ComponentUncheckedCreateWithoutGroupInput> | ComponentCreateWithoutGroupInput[] | ComponentUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ComponentCreateOrConnectWithoutGroupInput | ComponentCreateOrConnectWithoutGroupInput[]
    createMany?: ComponentCreateManyGroupInputEnvelope
    connect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
  }

  export type ComponentUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<ComponentCreateWithoutGroupInput, ComponentUncheckedCreateWithoutGroupInput> | ComponentCreateWithoutGroupInput[] | ComponentUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ComponentCreateOrConnectWithoutGroupInput | ComponentCreateOrConnectWithoutGroupInput[]
    createMany?: ComponentCreateManyGroupInputEnvelope
    connect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutComponentGroupsNestedInput = {
    create?: XOR<OrganizationCreateWithoutComponentGroupsInput, OrganizationUncheckedCreateWithoutComponentGroupsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutComponentGroupsInput
    upsert?: OrganizationUpsertWithoutComponentGroupsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutComponentGroupsInput, OrganizationUpdateWithoutComponentGroupsInput>, OrganizationUncheckedUpdateWithoutComponentGroupsInput>
  }

  export type ComponentUpdateManyWithoutGroupNestedInput = {
    create?: XOR<ComponentCreateWithoutGroupInput, ComponentUncheckedCreateWithoutGroupInput> | ComponentCreateWithoutGroupInput[] | ComponentUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ComponentCreateOrConnectWithoutGroupInput | ComponentCreateOrConnectWithoutGroupInput[]
    upsert?: ComponentUpsertWithWhereUniqueWithoutGroupInput | ComponentUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: ComponentCreateManyGroupInputEnvelope
    set?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    disconnect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    delete?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    connect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    update?: ComponentUpdateWithWhereUniqueWithoutGroupInput | ComponentUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: ComponentUpdateManyWithWhereWithoutGroupInput | ComponentUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: ComponentScalarWhereInput | ComponentScalarWhereInput[]
  }

  export type ComponentUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<ComponentCreateWithoutGroupInput, ComponentUncheckedCreateWithoutGroupInput> | ComponentCreateWithoutGroupInput[] | ComponentUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ComponentCreateOrConnectWithoutGroupInput | ComponentCreateOrConnectWithoutGroupInput[]
    upsert?: ComponentUpsertWithWhereUniqueWithoutGroupInput | ComponentUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: ComponentCreateManyGroupInputEnvelope
    set?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    disconnect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    delete?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    connect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    update?: ComponentUpdateWithWhereUniqueWithoutGroupInput | ComponentUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: ComponentUpdateManyWithWhereWithoutGroupInput | ComponentUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: ComponentScalarWhereInput | ComponentScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutComponentsInput = {
    create?: XOR<OrganizationCreateWithoutComponentsInput, OrganizationUncheckedCreateWithoutComponentsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutComponentsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ComponentGroupCreateNestedOneWithoutComponentsInput = {
    create?: XOR<ComponentGroupCreateWithoutComponentsInput, ComponentGroupUncheckedCreateWithoutComponentsInput>
    connectOrCreate?: ComponentGroupCreateOrConnectWithoutComponentsInput
    connect?: ComponentGroupWhereUniqueInput
  }

  export type MonitorCreateNestedManyWithoutComponentInput = {
    create?: XOR<MonitorCreateWithoutComponentInput, MonitorUncheckedCreateWithoutComponentInput> | MonitorCreateWithoutComponentInput[] | MonitorUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: MonitorCreateOrConnectWithoutComponentInput | MonitorCreateOrConnectWithoutComponentInput[]
    createMany?: MonitorCreateManyComponentInputEnvelope
    connect?: MonitorWhereUniqueInput | MonitorWhereUniqueInput[]
  }

  export type IncidentComponentCreateNestedManyWithoutComponentInput = {
    create?: XOR<IncidentComponentCreateWithoutComponentInput, IncidentComponentUncheckedCreateWithoutComponentInput> | IncidentComponentCreateWithoutComponentInput[] | IncidentComponentUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: IncidentComponentCreateOrConnectWithoutComponentInput | IncidentComponentCreateOrConnectWithoutComponentInput[]
    createMany?: IncidentComponentCreateManyComponentInputEnvelope
    connect?: IncidentComponentWhereUniqueInput | IncidentComponentWhereUniqueInput[]
  }

  export type MonitorUncheckedCreateNestedManyWithoutComponentInput = {
    create?: XOR<MonitorCreateWithoutComponentInput, MonitorUncheckedCreateWithoutComponentInput> | MonitorCreateWithoutComponentInput[] | MonitorUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: MonitorCreateOrConnectWithoutComponentInput | MonitorCreateOrConnectWithoutComponentInput[]
    createMany?: MonitorCreateManyComponentInputEnvelope
    connect?: MonitorWhereUniqueInput | MonitorWhereUniqueInput[]
  }

  export type IncidentComponentUncheckedCreateNestedManyWithoutComponentInput = {
    create?: XOR<IncidentComponentCreateWithoutComponentInput, IncidentComponentUncheckedCreateWithoutComponentInput> | IncidentComponentCreateWithoutComponentInput[] | IncidentComponentUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: IncidentComponentCreateOrConnectWithoutComponentInput | IncidentComponentCreateOrConnectWithoutComponentInput[]
    createMany?: IncidentComponentCreateManyComponentInputEnvelope
    connect?: IncidentComponentWhereUniqueInput | IncidentComponentWhereUniqueInput[]
  }

  export type EnumComponentStatusFieldUpdateOperationsInput = {
    set?: $Enums.ComponentStatus
  }

  export type OrganizationUpdateOneRequiredWithoutComponentsNestedInput = {
    create?: XOR<OrganizationCreateWithoutComponentsInput, OrganizationUncheckedCreateWithoutComponentsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutComponentsInput
    upsert?: OrganizationUpsertWithoutComponentsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutComponentsInput, OrganizationUpdateWithoutComponentsInput>, OrganizationUncheckedUpdateWithoutComponentsInput>
  }

  export type ComponentGroupUpdateOneWithoutComponentsNestedInput = {
    create?: XOR<ComponentGroupCreateWithoutComponentsInput, ComponentGroupUncheckedCreateWithoutComponentsInput>
    connectOrCreate?: ComponentGroupCreateOrConnectWithoutComponentsInput
    upsert?: ComponentGroupUpsertWithoutComponentsInput
    disconnect?: ComponentGroupWhereInput | boolean
    delete?: ComponentGroupWhereInput | boolean
    connect?: ComponentGroupWhereUniqueInput
    update?: XOR<XOR<ComponentGroupUpdateToOneWithWhereWithoutComponentsInput, ComponentGroupUpdateWithoutComponentsInput>, ComponentGroupUncheckedUpdateWithoutComponentsInput>
  }

  export type MonitorUpdateManyWithoutComponentNestedInput = {
    create?: XOR<MonitorCreateWithoutComponentInput, MonitorUncheckedCreateWithoutComponentInput> | MonitorCreateWithoutComponentInput[] | MonitorUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: MonitorCreateOrConnectWithoutComponentInput | MonitorCreateOrConnectWithoutComponentInput[]
    upsert?: MonitorUpsertWithWhereUniqueWithoutComponentInput | MonitorUpsertWithWhereUniqueWithoutComponentInput[]
    createMany?: MonitorCreateManyComponentInputEnvelope
    set?: MonitorWhereUniqueInput | MonitorWhereUniqueInput[]
    disconnect?: MonitorWhereUniqueInput | MonitorWhereUniqueInput[]
    delete?: MonitorWhereUniqueInput | MonitorWhereUniqueInput[]
    connect?: MonitorWhereUniqueInput | MonitorWhereUniqueInput[]
    update?: MonitorUpdateWithWhereUniqueWithoutComponentInput | MonitorUpdateWithWhereUniqueWithoutComponentInput[]
    updateMany?: MonitorUpdateManyWithWhereWithoutComponentInput | MonitorUpdateManyWithWhereWithoutComponentInput[]
    deleteMany?: MonitorScalarWhereInput | MonitorScalarWhereInput[]
  }

  export type IncidentComponentUpdateManyWithoutComponentNestedInput = {
    create?: XOR<IncidentComponentCreateWithoutComponentInput, IncidentComponentUncheckedCreateWithoutComponentInput> | IncidentComponentCreateWithoutComponentInput[] | IncidentComponentUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: IncidentComponentCreateOrConnectWithoutComponentInput | IncidentComponentCreateOrConnectWithoutComponentInput[]
    upsert?: IncidentComponentUpsertWithWhereUniqueWithoutComponentInput | IncidentComponentUpsertWithWhereUniqueWithoutComponentInput[]
    createMany?: IncidentComponentCreateManyComponentInputEnvelope
    set?: IncidentComponentWhereUniqueInput | IncidentComponentWhereUniqueInput[]
    disconnect?: IncidentComponentWhereUniqueInput | IncidentComponentWhereUniqueInput[]
    delete?: IncidentComponentWhereUniqueInput | IncidentComponentWhereUniqueInput[]
    connect?: IncidentComponentWhereUniqueInput | IncidentComponentWhereUniqueInput[]
    update?: IncidentComponentUpdateWithWhereUniqueWithoutComponentInput | IncidentComponentUpdateWithWhereUniqueWithoutComponentInput[]
    updateMany?: IncidentComponentUpdateManyWithWhereWithoutComponentInput | IncidentComponentUpdateManyWithWhereWithoutComponentInput[]
    deleteMany?: IncidentComponentScalarWhereInput | IncidentComponentScalarWhereInput[]
  }

  export type MonitorUncheckedUpdateManyWithoutComponentNestedInput = {
    create?: XOR<MonitorCreateWithoutComponentInput, MonitorUncheckedCreateWithoutComponentInput> | MonitorCreateWithoutComponentInput[] | MonitorUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: MonitorCreateOrConnectWithoutComponentInput | MonitorCreateOrConnectWithoutComponentInput[]
    upsert?: MonitorUpsertWithWhereUniqueWithoutComponentInput | MonitorUpsertWithWhereUniqueWithoutComponentInput[]
    createMany?: MonitorCreateManyComponentInputEnvelope
    set?: MonitorWhereUniqueInput | MonitorWhereUniqueInput[]
    disconnect?: MonitorWhereUniqueInput | MonitorWhereUniqueInput[]
    delete?: MonitorWhereUniqueInput | MonitorWhereUniqueInput[]
    connect?: MonitorWhereUniqueInput | MonitorWhereUniqueInput[]
    update?: MonitorUpdateWithWhereUniqueWithoutComponentInput | MonitorUpdateWithWhereUniqueWithoutComponentInput[]
    updateMany?: MonitorUpdateManyWithWhereWithoutComponentInput | MonitorUpdateManyWithWhereWithoutComponentInput[]
    deleteMany?: MonitorScalarWhereInput | MonitorScalarWhereInput[]
  }

  export type IncidentComponentUncheckedUpdateManyWithoutComponentNestedInput = {
    create?: XOR<IncidentComponentCreateWithoutComponentInput, IncidentComponentUncheckedCreateWithoutComponentInput> | IncidentComponentCreateWithoutComponentInput[] | IncidentComponentUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: IncidentComponentCreateOrConnectWithoutComponentInput | IncidentComponentCreateOrConnectWithoutComponentInput[]
    upsert?: IncidentComponentUpsertWithWhereUniqueWithoutComponentInput | IncidentComponentUpsertWithWhereUniqueWithoutComponentInput[]
    createMany?: IncidentComponentCreateManyComponentInputEnvelope
    set?: IncidentComponentWhereUniqueInput | IncidentComponentWhereUniqueInput[]
    disconnect?: IncidentComponentWhereUniqueInput | IncidentComponentWhereUniqueInput[]
    delete?: IncidentComponentWhereUniqueInput | IncidentComponentWhereUniqueInput[]
    connect?: IncidentComponentWhereUniqueInput | IncidentComponentWhereUniqueInput[]
    update?: IncidentComponentUpdateWithWhereUniqueWithoutComponentInput | IncidentComponentUpdateWithWhereUniqueWithoutComponentInput[]
    updateMany?: IncidentComponentUpdateManyWithWhereWithoutComponentInput | IncidentComponentUpdateManyWithWhereWithoutComponentInput[]
    deleteMany?: IncidentComponentScalarWhereInput | IncidentComponentScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutIncidentsInput = {
    create?: XOR<OrganizationCreateWithoutIncidentsInput, OrganizationUncheckedCreateWithoutIncidentsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutIncidentsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type IncidentUpdateCreateNestedManyWithoutIncidentInput = {
    create?: XOR<IncidentUpdateCreateWithoutIncidentInput, IncidentUpdateUncheckedCreateWithoutIncidentInput> | IncidentUpdateCreateWithoutIncidentInput[] | IncidentUpdateUncheckedCreateWithoutIncidentInput[]
    connectOrCreate?: IncidentUpdateCreateOrConnectWithoutIncidentInput | IncidentUpdateCreateOrConnectWithoutIncidentInput[]
    createMany?: IncidentUpdateCreateManyIncidentInputEnvelope
    connect?: IncidentUpdateWhereUniqueInput | IncidentUpdateWhereUniqueInput[]
  }

  export type IncidentComponentCreateNestedManyWithoutIncidentInput = {
    create?: XOR<IncidentComponentCreateWithoutIncidentInput, IncidentComponentUncheckedCreateWithoutIncidentInput> | IncidentComponentCreateWithoutIncidentInput[] | IncidentComponentUncheckedCreateWithoutIncidentInput[]
    connectOrCreate?: IncidentComponentCreateOrConnectWithoutIncidentInput | IncidentComponentCreateOrConnectWithoutIncidentInput[]
    createMany?: IncidentComponentCreateManyIncidentInputEnvelope
    connect?: IncidentComponentWhereUniqueInput | IncidentComponentWhereUniqueInput[]
  }

  export type IncidentUpdateUncheckedCreateNestedManyWithoutIncidentInput = {
    create?: XOR<IncidentUpdateCreateWithoutIncidentInput, IncidentUpdateUncheckedCreateWithoutIncidentInput> | IncidentUpdateCreateWithoutIncidentInput[] | IncidentUpdateUncheckedCreateWithoutIncidentInput[]
    connectOrCreate?: IncidentUpdateCreateOrConnectWithoutIncidentInput | IncidentUpdateCreateOrConnectWithoutIncidentInput[]
    createMany?: IncidentUpdateCreateManyIncidentInputEnvelope
    connect?: IncidentUpdateWhereUniqueInput | IncidentUpdateWhereUniqueInput[]
  }

  export type IncidentComponentUncheckedCreateNestedManyWithoutIncidentInput = {
    create?: XOR<IncidentComponentCreateWithoutIncidentInput, IncidentComponentUncheckedCreateWithoutIncidentInput> | IncidentComponentCreateWithoutIncidentInput[] | IncidentComponentUncheckedCreateWithoutIncidentInput[]
    connectOrCreate?: IncidentComponentCreateOrConnectWithoutIncidentInput | IncidentComponentCreateOrConnectWithoutIncidentInput[]
    createMany?: IncidentComponentCreateManyIncidentInputEnvelope
    connect?: IncidentComponentWhereUniqueInput | IncidentComponentWhereUniqueInput[]
  }

  export type EnumIncidentStatusFieldUpdateOperationsInput = {
    set?: $Enums.IncidentStatus
  }

  export type EnumIncidentSeverityFieldUpdateOperationsInput = {
    set?: $Enums.IncidentSeverity
  }

  export type OrganizationUpdateOneRequiredWithoutIncidentsNestedInput = {
    create?: XOR<OrganizationCreateWithoutIncidentsInput, OrganizationUncheckedCreateWithoutIncidentsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutIncidentsInput
    upsert?: OrganizationUpsertWithoutIncidentsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutIncidentsInput, OrganizationUpdateWithoutIncidentsInput>, OrganizationUncheckedUpdateWithoutIncidentsInput>
  }

  export type IncidentUpdateUpdateManyWithoutIncidentNestedInput = {
    create?: XOR<IncidentUpdateCreateWithoutIncidentInput, IncidentUpdateUncheckedCreateWithoutIncidentInput> | IncidentUpdateCreateWithoutIncidentInput[] | IncidentUpdateUncheckedCreateWithoutIncidentInput[]
    connectOrCreate?: IncidentUpdateCreateOrConnectWithoutIncidentInput | IncidentUpdateCreateOrConnectWithoutIncidentInput[]
    upsert?: IncidentUpdateUpsertWithWhereUniqueWithoutIncidentInput | IncidentUpdateUpsertWithWhereUniqueWithoutIncidentInput[]
    createMany?: IncidentUpdateCreateManyIncidentInputEnvelope
    set?: IncidentUpdateWhereUniqueInput | IncidentUpdateWhereUniqueInput[]
    disconnect?: IncidentUpdateWhereUniqueInput | IncidentUpdateWhereUniqueInput[]
    delete?: IncidentUpdateWhereUniqueInput | IncidentUpdateWhereUniqueInput[]
    connect?: IncidentUpdateWhereUniqueInput | IncidentUpdateWhereUniqueInput[]
    update?: IncidentUpdateUpdateWithWhereUniqueWithoutIncidentInput | IncidentUpdateUpdateWithWhereUniqueWithoutIncidentInput[]
    updateMany?: IncidentUpdateUpdateManyWithWhereWithoutIncidentInput | IncidentUpdateUpdateManyWithWhereWithoutIncidentInput[]
    deleteMany?: IncidentUpdateScalarWhereInput | IncidentUpdateScalarWhereInput[]
  }

  export type IncidentComponentUpdateManyWithoutIncidentNestedInput = {
    create?: XOR<IncidentComponentCreateWithoutIncidentInput, IncidentComponentUncheckedCreateWithoutIncidentInput> | IncidentComponentCreateWithoutIncidentInput[] | IncidentComponentUncheckedCreateWithoutIncidentInput[]
    connectOrCreate?: IncidentComponentCreateOrConnectWithoutIncidentInput | IncidentComponentCreateOrConnectWithoutIncidentInput[]
    upsert?: IncidentComponentUpsertWithWhereUniqueWithoutIncidentInput | IncidentComponentUpsertWithWhereUniqueWithoutIncidentInput[]
    createMany?: IncidentComponentCreateManyIncidentInputEnvelope
    set?: IncidentComponentWhereUniqueInput | IncidentComponentWhereUniqueInput[]
    disconnect?: IncidentComponentWhereUniqueInput | IncidentComponentWhereUniqueInput[]
    delete?: IncidentComponentWhereUniqueInput | IncidentComponentWhereUniqueInput[]
    connect?: IncidentComponentWhereUniqueInput | IncidentComponentWhereUniqueInput[]
    update?: IncidentComponentUpdateWithWhereUniqueWithoutIncidentInput | IncidentComponentUpdateWithWhereUniqueWithoutIncidentInput[]
    updateMany?: IncidentComponentUpdateManyWithWhereWithoutIncidentInput | IncidentComponentUpdateManyWithWhereWithoutIncidentInput[]
    deleteMany?: IncidentComponentScalarWhereInput | IncidentComponentScalarWhereInput[]
  }

  export type IncidentUpdateUncheckedUpdateManyWithoutIncidentNestedInput = {
    create?: XOR<IncidentUpdateCreateWithoutIncidentInput, IncidentUpdateUncheckedCreateWithoutIncidentInput> | IncidentUpdateCreateWithoutIncidentInput[] | IncidentUpdateUncheckedCreateWithoutIncidentInput[]
    connectOrCreate?: IncidentUpdateCreateOrConnectWithoutIncidentInput | IncidentUpdateCreateOrConnectWithoutIncidentInput[]
    upsert?: IncidentUpdateUpsertWithWhereUniqueWithoutIncidentInput | IncidentUpdateUpsertWithWhereUniqueWithoutIncidentInput[]
    createMany?: IncidentUpdateCreateManyIncidentInputEnvelope
    set?: IncidentUpdateWhereUniqueInput | IncidentUpdateWhereUniqueInput[]
    disconnect?: IncidentUpdateWhereUniqueInput | IncidentUpdateWhereUniqueInput[]
    delete?: IncidentUpdateWhereUniqueInput | IncidentUpdateWhereUniqueInput[]
    connect?: IncidentUpdateWhereUniqueInput | IncidentUpdateWhereUniqueInput[]
    update?: IncidentUpdateUpdateWithWhereUniqueWithoutIncidentInput | IncidentUpdateUpdateWithWhereUniqueWithoutIncidentInput[]
    updateMany?: IncidentUpdateUpdateManyWithWhereWithoutIncidentInput | IncidentUpdateUpdateManyWithWhereWithoutIncidentInput[]
    deleteMany?: IncidentUpdateScalarWhereInput | IncidentUpdateScalarWhereInput[]
  }

  export type IncidentComponentUncheckedUpdateManyWithoutIncidentNestedInput = {
    create?: XOR<IncidentComponentCreateWithoutIncidentInput, IncidentComponentUncheckedCreateWithoutIncidentInput> | IncidentComponentCreateWithoutIncidentInput[] | IncidentComponentUncheckedCreateWithoutIncidentInput[]
    connectOrCreate?: IncidentComponentCreateOrConnectWithoutIncidentInput | IncidentComponentCreateOrConnectWithoutIncidentInput[]
    upsert?: IncidentComponentUpsertWithWhereUniqueWithoutIncidentInput | IncidentComponentUpsertWithWhereUniqueWithoutIncidentInput[]
    createMany?: IncidentComponentCreateManyIncidentInputEnvelope
    set?: IncidentComponentWhereUniqueInput | IncidentComponentWhereUniqueInput[]
    disconnect?: IncidentComponentWhereUniqueInput | IncidentComponentWhereUniqueInput[]
    delete?: IncidentComponentWhereUniqueInput | IncidentComponentWhereUniqueInput[]
    connect?: IncidentComponentWhereUniqueInput | IncidentComponentWhereUniqueInput[]
    update?: IncidentComponentUpdateWithWhereUniqueWithoutIncidentInput | IncidentComponentUpdateWithWhereUniqueWithoutIncidentInput[]
    updateMany?: IncidentComponentUpdateManyWithWhereWithoutIncidentInput | IncidentComponentUpdateManyWithWhereWithoutIncidentInput[]
    deleteMany?: IncidentComponentScalarWhereInput | IncidentComponentScalarWhereInput[]
  }

  export type IncidentCreateNestedOneWithoutUpdatesInput = {
    create?: XOR<IncidentCreateWithoutUpdatesInput, IncidentUncheckedCreateWithoutUpdatesInput>
    connectOrCreate?: IncidentCreateOrConnectWithoutUpdatesInput
    connect?: IncidentWhereUniqueInput
  }

  export type IncidentUpdateOneRequiredWithoutUpdatesNestedInput = {
    create?: XOR<IncidentCreateWithoutUpdatesInput, IncidentUncheckedCreateWithoutUpdatesInput>
    connectOrCreate?: IncidentCreateOrConnectWithoutUpdatesInput
    upsert?: IncidentUpsertWithoutUpdatesInput
    connect?: IncidentWhereUniqueInput
    update?: XOR<XOR<IncidentUpdateToOneWithWhereWithoutUpdatesInput, IncidentUpdateWithoutUpdatesInput>, IncidentUncheckedUpdateWithoutUpdatesInput>
  }

  export type IncidentCreateNestedOneWithoutComponentsInput = {
    create?: XOR<IncidentCreateWithoutComponentsInput, IncidentUncheckedCreateWithoutComponentsInput>
    connectOrCreate?: IncidentCreateOrConnectWithoutComponentsInput
    connect?: IncidentWhereUniqueInput
  }

  export type ComponentCreateNestedOneWithoutIncidentsInput = {
    create?: XOR<ComponentCreateWithoutIncidentsInput, ComponentUncheckedCreateWithoutIncidentsInput>
    connectOrCreate?: ComponentCreateOrConnectWithoutIncidentsInput
    connect?: ComponentWhereUniqueInput
  }

  export type IncidentUpdateOneRequiredWithoutComponentsNestedInput = {
    create?: XOR<IncidentCreateWithoutComponentsInput, IncidentUncheckedCreateWithoutComponentsInput>
    connectOrCreate?: IncidentCreateOrConnectWithoutComponentsInput
    upsert?: IncidentUpsertWithoutComponentsInput
    connect?: IncidentWhereUniqueInput
    update?: XOR<XOR<IncidentUpdateToOneWithWhereWithoutComponentsInput, IncidentUpdateWithoutComponentsInput>, IncidentUncheckedUpdateWithoutComponentsInput>
  }

  export type ComponentUpdateOneRequiredWithoutIncidentsNestedInput = {
    create?: XOR<ComponentCreateWithoutIncidentsInput, ComponentUncheckedCreateWithoutIncidentsInput>
    connectOrCreate?: ComponentCreateOrConnectWithoutIncidentsInput
    upsert?: ComponentUpsertWithoutIncidentsInput
    connect?: ComponentWhereUniqueInput
    update?: XOR<XOR<ComponentUpdateToOneWithWhereWithoutIncidentsInput, ComponentUpdateWithoutIncidentsInput>, ComponentUncheckedUpdateWithoutIncidentsInput>
  }

  export type OrganizationCreateNestedOneWithoutSubscribersInput = {
    create?: XOR<OrganizationCreateWithoutSubscribersInput, OrganizationUncheckedCreateWithoutSubscribersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSubscribersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type AlertCreateNestedManyWithoutSubscriberInput = {
    create?: XOR<AlertCreateWithoutSubscriberInput, AlertUncheckedCreateWithoutSubscriberInput> | AlertCreateWithoutSubscriberInput[] | AlertUncheckedCreateWithoutSubscriberInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutSubscriberInput | AlertCreateOrConnectWithoutSubscriberInput[]
    createMany?: AlertCreateManySubscriberInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type AlertUncheckedCreateNestedManyWithoutSubscriberInput = {
    create?: XOR<AlertCreateWithoutSubscriberInput, AlertUncheckedCreateWithoutSubscriberInput> | AlertCreateWithoutSubscriberInput[] | AlertUncheckedCreateWithoutSubscriberInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutSubscriberInput | AlertCreateOrConnectWithoutSubscriberInput[]
    createMany?: AlertCreateManySubscriberInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type EnumSubscriberTypeFieldUpdateOperationsInput = {
    set?: $Enums.SubscriberType
  }

  export type OrganizationUpdateOneRequiredWithoutSubscribersNestedInput = {
    create?: XOR<OrganizationCreateWithoutSubscribersInput, OrganizationUncheckedCreateWithoutSubscribersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSubscribersInput
    upsert?: OrganizationUpsertWithoutSubscribersInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutSubscribersInput, OrganizationUpdateWithoutSubscribersInput>, OrganizationUncheckedUpdateWithoutSubscribersInput>
  }

  export type AlertUpdateManyWithoutSubscriberNestedInput = {
    create?: XOR<AlertCreateWithoutSubscriberInput, AlertUncheckedCreateWithoutSubscriberInput> | AlertCreateWithoutSubscriberInput[] | AlertUncheckedCreateWithoutSubscriberInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutSubscriberInput | AlertCreateOrConnectWithoutSubscriberInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutSubscriberInput | AlertUpsertWithWhereUniqueWithoutSubscriberInput[]
    createMany?: AlertCreateManySubscriberInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutSubscriberInput | AlertUpdateWithWhereUniqueWithoutSubscriberInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutSubscriberInput | AlertUpdateManyWithWhereWithoutSubscriberInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type AlertUncheckedUpdateManyWithoutSubscriberNestedInput = {
    create?: XOR<AlertCreateWithoutSubscriberInput, AlertUncheckedCreateWithoutSubscriberInput> | AlertCreateWithoutSubscriberInput[] | AlertUncheckedCreateWithoutSubscriberInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutSubscriberInput | AlertCreateOrConnectWithoutSubscriberInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutSubscriberInput | AlertUpsertWithWhereUniqueWithoutSubscriberInput[]
    createMany?: AlertCreateManySubscriberInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutSubscriberInput | AlertUpdateWithWhereUniqueWithoutSubscriberInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutSubscriberInput | AlertUpdateManyWithWhereWithoutSubscriberInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type SubscriberCreateNestedOneWithoutAlertsInput = {
    create?: XOR<SubscriberCreateWithoutAlertsInput, SubscriberUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: SubscriberCreateOrConnectWithoutAlertsInput
    connect?: SubscriberWhereUniqueInput
  }

  export type EnumAlertStatusFieldUpdateOperationsInput = {
    set?: $Enums.AlertStatus
  }

  export type SubscriberUpdateOneRequiredWithoutAlertsNestedInput = {
    create?: XOR<SubscriberCreateWithoutAlertsInput, SubscriberUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: SubscriberCreateOrConnectWithoutAlertsInput
    upsert?: SubscriberUpsertWithoutAlertsInput
    connect?: SubscriberWhereUniqueInput
    update?: XOR<XOR<SubscriberUpdateToOneWithWhereWithoutAlertsInput, SubscriberUpdateWithoutAlertsInput>, SubscriberUncheckedUpdateWithoutAlertsInput>
  }

  export type OrganizationCreateNestedOneWithoutNotificationChannelsInput = {
    create?: XOR<OrganizationCreateWithoutNotificationChannelsInput, OrganizationUncheckedCreateWithoutNotificationChannelsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutNotificationChannelsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type EnumNotificationChannelTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationChannelType
  }

  export type OrganizationUpdateOneRequiredWithoutNotificationChannelsNestedInput = {
    create?: XOR<OrganizationCreateWithoutNotificationChannelsInput, OrganizationUncheckedCreateWithoutNotificationChannelsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutNotificationChannelsInput
    upsert?: OrganizationUpsertWithoutNotificationChannelsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutNotificationChannelsInput, OrganizationUpdateWithoutNotificationChannelsInput>, OrganizationUncheckedUpdateWithoutNotificationChannelsInput>
  }

  export type OrganizationCreateNestedOneWithoutApiKeysInput = {
    create?: XOR<OrganizationCreateWithoutApiKeysInput, OrganizationUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutApiKeysInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutApiKeysNestedInput = {
    create?: XOR<OrganizationCreateWithoutApiKeysInput, OrganizationUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutApiKeysInput
    upsert?: OrganizationUpsertWithoutApiKeysInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutApiKeysInput, OrganizationUpdateWithoutApiKeysInput>, OrganizationUncheckedUpdateWithoutApiKeysInput>
  }

  export type OrganizationCreateNestedOneWithoutStatusPageConfigInput = {
    create?: XOR<OrganizationCreateWithoutStatusPageConfigInput, OrganizationUncheckedCreateWithoutStatusPageConfigInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutStatusPageConfigInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutStatusPageConfigNestedInput = {
    create?: XOR<OrganizationCreateWithoutStatusPageConfigInput, OrganizationUncheckedCreateWithoutStatusPageConfigInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutStatusPageConfigInput
    upsert?: OrganizationUpsertWithoutStatusPageConfigInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutStatusPageConfigInput, OrganizationUpdateWithoutStatusPageConfigInput>, OrganizationUncheckedUpdateWithoutStatusPageConfigInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberRole | EnumMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberRoleFilter<$PrismaModel> | $Enums.MemberRole
  }

  export type NestedEnumMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberRole | EnumMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.MemberRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberRoleFilter<$PrismaModel>
    _max?: NestedEnumMemberRoleFilter<$PrismaModel>
  }

  export type NestedEnumMonitorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MonitorType | EnumMonitorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MonitorType[] | ListEnumMonitorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MonitorType[] | ListEnumMonitorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMonitorTypeFilter<$PrismaModel> | $Enums.MonitorType
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumHttpMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.HttpMethod | EnumHttpMethodFieldRefInput<$PrismaModel>
    in?: $Enums.HttpMethod[] | ListEnumHttpMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.HttpMethod[] | ListEnumHttpMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumHttpMethodFilter<$PrismaModel> | $Enums.HttpMethod
  }

  export type NestedEnumMonitorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MonitorStatus | EnumMonitorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MonitorStatus[] | ListEnumMonitorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MonitorStatus[] | ListEnumMonitorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMonitorStatusFilter<$PrismaModel> | $Enums.MonitorStatus
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumKeywordTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.KeywordType | EnumKeywordTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.KeywordType[] | ListEnumKeywordTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.KeywordType[] | ListEnumKeywordTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumKeywordTypeNullableFilter<$PrismaModel> | $Enums.KeywordType | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumMonitorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MonitorType | EnumMonitorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MonitorType[] | ListEnumMonitorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MonitorType[] | ListEnumMonitorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMonitorTypeWithAggregatesFilter<$PrismaModel> | $Enums.MonitorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMonitorTypeFilter<$PrismaModel>
    _max?: NestedEnumMonitorTypeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumHttpMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HttpMethod | EnumHttpMethodFieldRefInput<$PrismaModel>
    in?: $Enums.HttpMethod[] | ListEnumHttpMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.HttpMethod[] | ListEnumHttpMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumHttpMethodWithAggregatesFilter<$PrismaModel> | $Enums.HttpMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHttpMethodFilter<$PrismaModel>
    _max?: NestedEnumHttpMethodFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumMonitorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MonitorStatus | EnumMonitorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MonitorStatus[] | ListEnumMonitorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MonitorStatus[] | ListEnumMonitorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMonitorStatusWithAggregatesFilter<$PrismaModel> | $Enums.MonitorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMonitorStatusFilter<$PrismaModel>
    _max?: NestedEnumMonitorStatusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumKeywordTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KeywordType | EnumKeywordTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.KeywordType[] | ListEnumKeywordTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.KeywordType[] | ListEnumKeywordTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumKeywordTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.KeywordType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumKeywordTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumKeywordTypeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumComponentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ComponentStatus | EnumComponentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComponentStatus[] | ListEnumComponentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComponentStatus[] | ListEnumComponentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComponentStatusFilter<$PrismaModel> | $Enums.ComponentStatus
  }

  export type NestedEnumComponentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComponentStatus | EnumComponentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComponentStatus[] | ListEnumComponentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComponentStatus[] | ListEnumComponentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComponentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ComponentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComponentStatusFilter<$PrismaModel>
    _max?: NestedEnumComponentStatusFilter<$PrismaModel>
  }

  export type NestedEnumIncidentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentStatusFilter<$PrismaModel> | $Enums.IncidentStatus
  }

  export type NestedEnumIncidentSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentSeverity | EnumIncidentSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentSeverityFilter<$PrismaModel> | $Enums.IncidentSeverity
  }

  export type NestedEnumIncidentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentStatusWithAggregatesFilter<$PrismaModel> | $Enums.IncidentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentStatusFilter<$PrismaModel>
    _max?: NestedEnumIncidentStatusFilter<$PrismaModel>
  }

  export type NestedEnumIncidentSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentSeverity | EnumIncidentSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentSeverity[] | ListEnumIncidentSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentSeverityWithAggregatesFilter<$PrismaModel> | $Enums.IncidentSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentSeverityFilter<$PrismaModel>
    _max?: NestedEnumIncidentSeverityFilter<$PrismaModel>
  }

  export type NestedEnumSubscriberTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriberType | EnumSubscriberTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriberType[] | ListEnumSubscriberTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriberType[] | ListEnumSubscriberTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriberTypeFilter<$PrismaModel> | $Enums.SubscriberType
  }

  export type NestedEnumSubscriberTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriberType | EnumSubscriberTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriberType[] | ListEnumSubscriberTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriberType[] | ListEnumSubscriberTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriberTypeWithAggregatesFilter<$PrismaModel> | $Enums.SubscriberType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriberTypeFilter<$PrismaModel>
    _max?: NestedEnumSubscriberTypeFilter<$PrismaModel>
  }

  export type NestedEnumAlertStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertStatus | EnumAlertStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertStatusFilter<$PrismaModel> | $Enums.AlertStatus
  }

  export type NestedEnumAlertStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertStatus | EnumAlertStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertStatusWithAggregatesFilter<$PrismaModel> | $Enums.AlertStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertStatusFilter<$PrismaModel>
    _max?: NestedEnumAlertStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationChannelTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannelType | EnumNotificationChannelTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannelType[] | ListEnumNotificationChannelTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannelType[] | ListEnumNotificationChannelTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelTypeFilter<$PrismaModel> | $Enums.NotificationChannelType
  }

  export type NestedEnumNotificationChannelTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannelType | EnumNotificationChannelTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannelType[] | ListEnumNotificationChannelTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannelType[] | ListEnumNotificationChannelTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationChannelType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationChannelTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationChannelTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type MemberCreateWithoutOrganizationInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.MemberRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberUncheckedCreateWithoutOrganizationInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.MemberRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberCreateOrConnectWithoutOrganizationInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput>
  }

  export type MemberCreateManyOrganizationInputEnvelope = {
    data: MemberCreateManyOrganizationInput | MemberCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type MonitorCreateWithoutOrganizationInput = {
    id?: string
    name: string
    type: $Enums.MonitorType
    url?: string | null
    target?: string | null
    method?: $Enums.HttpMethod
    interval?: number
    timeout?: number
    status?: $Enums.MonitorStatus
    currentStatus?: string
    enabled?: boolean
    headers?: NullableJsonNullValueInput | InputJsonValue
    body?: string | null
    expectedStatus?: number | null
    keyword?: string | null
    keywordType?: $Enums.KeywordType | null
    heartbeatToken?: string | null
    heartbeatGrace?: number | null
    sslExpiryThreshold?: number | null
    alertAfter?: number
    recoveryAfter?: number
    lastCheckedAt?: Date | string | null
    uptimeDay?: number | null
    uptimeWeek?: number | null
    uptimeMonth?: number | null
    avgResponseTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    component?: ComponentCreateNestedOneWithoutMonitorsInput
    checks?: MonitorCheckCreateNestedManyWithoutMonitorInput
    alerts?: MonitorAlertCreateNestedManyWithoutMonitorInput
  }

  export type MonitorUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    type: $Enums.MonitorType
    url?: string | null
    target?: string | null
    method?: $Enums.HttpMethod
    interval?: number
    timeout?: number
    status?: $Enums.MonitorStatus
    currentStatus?: string
    enabled?: boolean
    componentId?: string | null
    headers?: NullableJsonNullValueInput | InputJsonValue
    body?: string | null
    expectedStatus?: number | null
    keyword?: string | null
    keywordType?: $Enums.KeywordType | null
    heartbeatToken?: string | null
    heartbeatGrace?: number | null
    sslExpiryThreshold?: number | null
    alertAfter?: number
    recoveryAfter?: number
    lastCheckedAt?: Date | string | null
    uptimeDay?: number | null
    uptimeWeek?: number | null
    uptimeMonth?: number | null
    avgResponseTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checks?: MonitorCheckUncheckedCreateNestedManyWithoutMonitorInput
    alerts?: MonitorAlertUncheckedCreateNestedManyWithoutMonitorInput
  }

  export type MonitorCreateOrConnectWithoutOrganizationInput = {
    where: MonitorWhereUniqueInput
    create: XOR<MonitorCreateWithoutOrganizationInput, MonitorUncheckedCreateWithoutOrganizationInput>
  }

  export type MonitorCreateManyOrganizationInputEnvelope = {
    data: MonitorCreateManyOrganizationInput | MonitorCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type ComponentCreateWithoutOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ComponentStatus
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    group?: ComponentGroupCreateNestedOneWithoutComponentsInput
    monitors?: MonitorCreateNestedManyWithoutComponentInput
    incidents?: IncidentComponentCreateNestedManyWithoutComponentInput
  }

  export type ComponentUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ComponentStatus
    order?: number
    groupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    monitors?: MonitorUncheckedCreateNestedManyWithoutComponentInput
    incidents?: IncidentComponentUncheckedCreateNestedManyWithoutComponentInput
  }

  export type ComponentCreateOrConnectWithoutOrganizationInput = {
    where: ComponentWhereUniqueInput
    create: XOR<ComponentCreateWithoutOrganizationInput, ComponentUncheckedCreateWithoutOrganizationInput>
  }

  export type ComponentCreateManyOrganizationInputEnvelope = {
    data: ComponentCreateManyOrganizationInput | ComponentCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type ComponentGroupCreateWithoutOrganizationInput = {
    id?: string
    name: string
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    components?: ComponentCreateNestedManyWithoutGroupInput
  }

  export type ComponentGroupUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    components?: ComponentUncheckedCreateNestedManyWithoutGroupInput
  }

  export type ComponentGroupCreateOrConnectWithoutOrganizationInput = {
    where: ComponentGroupWhereUniqueInput
    create: XOR<ComponentGroupCreateWithoutOrganizationInput, ComponentGroupUncheckedCreateWithoutOrganizationInput>
  }

  export type ComponentGroupCreateManyOrganizationInputEnvelope = {
    data: ComponentGroupCreateManyOrganizationInput | ComponentGroupCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type IncidentCreateWithoutOrganizationInput = {
    id?: string
    title: string
    status?: $Enums.IncidentStatus
    severity?: $Enums.IncidentSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    updates?: IncidentUpdateCreateNestedManyWithoutIncidentInput
    components?: IncidentComponentCreateNestedManyWithoutIncidentInput
  }

  export type IncidentUncheckedCreateWithoutOrganizationInput = {
    id?: string
    title: string
    status?: $Enums.IncidentStatus
    severity?: $Enums.IncidentSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    updates?: IncidentUpdateUncheckedCreateNestedManyWithoutIncidentInput
    components?: IncidentComponentUncheckedCreateNestedManyWithoutIncidentInput
  }

  export type IncidentCreateOrConnectWithoutOrganizationInput = {
    where: IncidentWhereUniqueInput
    create: XOR<IncidentCreateWithoutOrganizationInput, IncidentUncheckedCreateWithoutOrganizationInput>
  }

  export type IncidentCreateManyOrganizationInputEnvelope = {
    data: IncidentCreateManyOrganizationInput | IncidentCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type SubscriberCreateWithoutOrganizationInput = {
    id?: string
    type?: $Enums.SubscriberType
    email?: string | null
    webhookUrl?: string | null
    confirmed?: boolean
    token?: string
    createdAt?: Date | string
    alerts?: AlertCreateNestedManyWithoutSubscriberInput
  }

  export type SubscriberUncheckedCreateWithoutOrganizationInput = {
    id?: string
    type?: $Enums.SubscriberType
    email?: string | null
    webhookUrl?: string | null
    confirmed?: boolean
    token?: string
    createdAt?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutSubscriberInput
  }

  export type SubscriberCreateOrConnectWithoutOrganizationInput = {
    where: SubscriberWhereUniqueInput
    create: XOR<SubscriberCreateWithoutOrganizationInput, SubscriberUncheckedCreateWithoutOrganizationInput>
  }

  export type SubscriberCreateManyOrganizationInputEnvelope = {
    data: SubscriberCreateManyOrganizationInput | SubscriberCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type NotificationChannelCreateWithoutOrganizationInput = {
    id?: string
    name: string
    type: $Enums.NotificationChannelType
    config: JsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationChannelUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    type: $Enums.NotificationChannelType
    config: JsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationChannelCreateOrConnectWithoutOrganizationInput = {
    where: NotificationChannelWhereUniqueInput
    create: XOR<NotificationChannelCreateWithoutOrganizationInput, NotificationChannelUncheckedCreateWithoutOrganizationInput>
  }

  export type NotificationChannelCreateManyOrganizationInputEnvelope = {
    data: NotificationChannelCreateManyOrganizationInput | NotificationChannelCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type ApiKeyCreateWithoutOrganizationInput = {
    id?: string
    name: string
    key: string
    expiresAt?: Date | string | null
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ApiKeyUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    key: string
    expiresAt?: Date | string | null
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ApiKeyCreateOrConnectWithoutOrganizationInput = {
    where: ApiKeyWhereUniqueInput
    create: XOR<ApiKeyCreateWithoutOrganizationInput, ApiKeyUncheckedCreateWithoutOrganizationInput>
  }

  export type ApiKeyCreateManyOrganizationInputEnvelope = {
    data: ApiKeyCreateManyOrganizationInput | ApiKeyCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type StatusPageConfigCreateWithoutOrganizationInput = {
    id?: string
    title: string
    description?: string | null
    logoUrl?: string | null
    faviconUrl?: string | null
    customDomain?: string | null
    customCss?: string | null
    showUptime?: boolean
    showResponseTime?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatusPageConfigUncheckedCreateWithoutOrganizationInput = {
    id?: string
    title: string
    description?: string | null
    logoUrl?: string | null
    faviconUrl?: string | null
    customDomain?: string | null
    customCss?: string | null
    showUptime?: boolean
    showResponseTime?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatusPageConfigCreateOrConnectWithoutOrganizationInput = {
    where: StatusPageConfigWhereUniqueInput
    create: XOR<StatusPageConfigCreateWithoutOrganizationInput, StatusPageConfigUncheckedCreateWithoutOrganizationInput>
  }

  export type MemberUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutOrganizationInput, MemberUncheckedUpdateWithoutOrganizationInput>
    create: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutOrganizationInput, MemberUncheckedUpdateWithoutOrganizationInput>
  }

  export type MemberUpdateManyWithWhereWithoutOrganizationInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type MemberScalarWhereInput = {
    AND?: MemberScalarWhereInput | MemberScalarWhereInput[]
    OR?: MemberScalarWhereInput[]
    NOT?: MemberScalarWhereInput | MemberScalarWhereInput[]
    id?: StringFilter<"Member"> | string
    email?: StringFilter<"Member"> | string
    password?: StringFilter<"Member"> | string
    name?: StringFilter<"Member"> | string
    role?: EnumMemberRoleFilter<"Member"> | $Enums.MemberRole
    orgId?: StringFilter<"Member"> | string
    createdAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeFilter<"Member"> | Date | string
  }

  export type MonitorUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: MonitorWhereUniqueInput
    update: XOR<MonitorUpdateWithoutOrganizationInput, MonitorUncheckedUpdateWithoutOrganizationInput>
    create: XOR<MonitorCreateWithoutOrganizationInput, MonitorUncheckedCreateWithoutOrganizationInput>
  }

  export type MonitorUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: MonitorWhereUniqueInput
    data: XOR<MonitorUpdateWithoutOrganizationInput, MonitorUncheckedUpdateWithoutOrganizationInput>
  }

  export type MonitorUpdateManyWithWhereWithoutOrganizationInput = {
    where: MonitorScalarWhereInput
    data: XOR<MonitorUpdateManyMutationInput, MonitorUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type MonitorScalarWhereInput = {
    AND?: MonitorScalarWhereInput | MonitorScalarWhereInput[]
    OR?: MonitorScalarWhereInput[]
    NOT?: MonitorScalarWhereInput | MonitorScalarWhereInput[]
    id?: StringFilter<"Monitor"> | string
    name?: StringFilter<"Monitor"> | string
    type?: EnumMonitorTypeFilter<"Monitor"> | $Enums.MonitorType
    url?: StringNullableFilter<"Monitor"> | string | null
    target?: StringNullableFilter<"Monitor"> | string | null
    method?: EnumHttpMethodFilter<"Monitor"> | $Enums.HttpMethod
    interval?: IntFilter<"Monitor"> | number
    timeout?: IntFilter<"Monitor"> | number
    status?: EnumMonitorStatusFilter<"Monitor"> | $Enums.MonitorStatus
    currentStatus?: StringFilter<"Monitor"> | string
    enabled?: BoolFilter<"Monitor"> | boolean
    orgId?: StringFilter<"Monitor"> | string
    componentId?: StringNullableFilter<"Monitor"> | string | null
    headers?: JsonNullableFilter<"Monitor">
    body?: StringNullableFilter<"Monitor"> | string | null
    expectedStatus?: IntNullableFilter<"Monitor"> | number | null
    keyword?: StringNullableFilter<"Monitor"> | string | null
    keywordType?: EnumKeywordTypeNullableFilter<"Monitor"> | $Enums.KeywordType | null
    heartbeatToken?: StringNullableFilter<"Monitor"> | string | null
    heartbeatGrace?: IntNullableFilter<"Monitor"> | number | null
    sslExpiryThreshold?: IntNullableFilter<"Monitor"> | number | null
    alertAfter?: IntFilter<"Monitor"> | number
    recoveryAfter?: IntFilter<"Monitor"> | number
    lastCheckedAt?: DateTimeNullableFilter<"Monitor"> | Date | string | null
    uptimeDay?: FloatNullableFilter<"Monitor"> | number | null
    uptimeWeek?: FloatNullableFilter<"Monitor"> | number | null
    uptimeMonth?: FloatNullableFilter<"Monitor"> | number | null
    avgResponseTime?: FloatNullableFilter<"Monitor"> | number | null
    createdAt?: DateTimeFilter<"Monitor"> | Date | string
    updatedAt?: DateTimeFilter<"Monitor"> | Date | string
  }

  export type ComponentUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ComponentWhereUniqueInput
    update: XOR<ComponentUpdateWithoutOrganizationInput, ComponentUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ComponentCreateWithoutOrganizationInput, ComponentUncheckedCreateWithoutOrganizationInput>
  }

  export type ComponentUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ComponentWhereUniqueInput
    data: XOR<ComponentUpdateWithoutOrganizationInput, ComponentUncheckedUpdateWithoutOrganizationInput>
  }

  export type ComponentUpdateManyWithWhereWithoutOrganizationInput = {
    where: ComponentScalarWhereInput
    data: XOR<ComponentUpdateManyMutationInput, ComponentUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ComponentScalarWhereInput = {
    AND?: ComponentScalarWhereInput | ComponentScalarWhereInput[]
    OR?: ComponentScalarWhereInput[]
    NOT?: ComponentScalarWhereInput | ComponentScalarWhereInput[]
    id?: StringFilter<"Component"> | string
    name?: StringFilter<"Component"> | string
    description?: StringNullableFilter<"Component"> | string | null
    status?: EnumComponentStatusFilter<"Component"> | $Enums.ComponentStatus
    order?: IntFilter<"Component"> | number
    orgId?: StringFilter<"Component"> | string
    groupId?: StringNullableFilter<"Component"> | string | null
    createdAt?: DateTimeFilter<"Component"> | Date | string
    updatedAt?: DateTimeFilter<"Component"> | Date | string
  }

  export type ComponentGroupUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ComponentGroupWhereUniqueInput
    update: XOR<ComponentGroupUpdateWithoutOrganizationInput, ComponentGroupUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ComponentGroupCreateWithoutOrganizationInput, ComponentGroupUncheckedCreateWithoutOrganizationInput>
  }

  export type ComponentGroupUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ComponentGroupWhereUniqueInput
    data: XOR<ComponentGroupUpdateWithoutOrganizationInput, ComponentGroupUncheckedUpdateWithoutOrganizationInput>
  }

  export type ComponentGroupUpdateManyWithWhereWithoutOrganizationInput = {
    where: ComponentGroupScalarWhereInput
    data: XOR<ComponentGroupUpdateManyMutationInput, ComponentGroupUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ComponentGroupScalarWhereInput = {
    AND?: ComponentGroupScalarWhereInput | ComponentGroupScalarWhereInput[]
    OR?: ComponentGroupScalarWhereInput[]
    NOT?: ComponentGroupScalarWhereInput | ComponentGroupScalarWhereInput[]
    id?: StringFilter<"ComponentGroup"> | string
    name?: StringFilter<"ComponentGroup"> | string
    order?: IntFilter<"ComponentGroup"> | number
    orgId?: StringFilter<"ComponentGroup"> | string
    createdAt?: DateTimeFilter<"ComponentGroup"> | Date | string
    updatedAt?: DateTimeFilter<"ComponentGroup"> | Date | string
  }

  export type IncidentUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: IncidentWhereUniqueInput
    update: XOR<IncidentUpdateWithoutOrganizationInput, IncidentUncheckedUpdateWithoutOrganizationInput>
    create: XOR<IncidentCreateWithoutOrganizationInput, IncidentUncheckedCreateWithoutOrganizationInput>
  }

  export type IncidentUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: IncidentWhereUniqueInput
    data: XOR<IncidentUpdateWithoutOrganizationInput, IncidentUncheckedUpdateWithoutOrganizationInput>
  }

  export type IncidentUpdateManyWithWhereWithoutOrganizationInput = {
    where: IncidentScalarWhereInput
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type IncidentScalarWhereInput = {
    AND?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
    OR?: IncidentScalarWhereInput[]
    NOT?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
    id?: StringFilter<"Incident"> | string
    title?: StringFilter<"Incident"> | string
    status?: EnumIncidentStatusFilter<"Incident"> | $Enums.IncidentStatus
    severity?: EnumIncidentSeverityFilter<"Incident"> | $Enums.IncidentSeverity
    orgId?: StringFilter<"Incident"> | string
    createdAt?: DateTimeFilter<"Incident"> | Date | string
    updatedAt?: DateTimeFilter<"Incident"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Incident"> | Date | string | null
  }

  export type SubscriberUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: SubscriberWhereUniqueInput
    update: XOR<SubscriberUpdateWithoutOrganizationInput, SubscriberUncheckedUpdateWithoutOrganizationInput>
    create: XOR<SubscriberCreateWithoutOrganizationInput, SubscriberUncheckedCreateWithoutOrganizationInput>
  }

  export type SubscriberUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: SubscriberWhereUniqueInput
    data: XOR<SubscriberUpdateWithoutOrganizationInput, SubscriberUncheckedUpdateWithoutOrganizationInput>
  }

  export type SubscriberUpdateManyWithWhereWithoutOrganizationInput = {
    where: SubscriberScalarWhereInput
    data: XOR<SubscriberUpdateManyMutationInput, SubscriberUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type SubscriberScalarWhereInput = {
    AND?: SubscriberScalarWhereInput | SubscriberScalarWhereInput[]
    OR?: SubscriberScalarWhereInput[]
    NOT?: SubscriberScalarWhereInput | SubscriberScalarWhereInput[]
    id?: StringFilter<"Subscriber"> | string
    type?: EnumSubscriberTypeFilter<"Subscriber"> | $Enums.SubscriberType
    email?: StringNullableFilter<"Subscriber"> | string | null
    webhookUrl?: StringNullableFilter<"Subscriber"> | string | null
    confirmed?: BoolFilter<"Subscriber"> | boolean
    token?: StringFilter<"Subscriber"> | string
    orgId?: StringFilter<"Subscriber"> | string
    createdAt?: DateTimeFilter<"Subscriber"> | Date | string
  }

  export type NotificationChannelUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: NotificationChannelWhereUniqueInput
    update: XOR<NotificationChannelUpdateWithoutOrganizationInput, NotificationChannelUncheckedUpdateWithoutOrganizationInput>
    create: XOR<NotificationChannelCreateWithoutOrganizationInput, NotificationChannelUncheckedCreateWithoutOrganizationInput>
  }

  export type NotificationChannelUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: NotificationChannelWhereUniqueInput
    data: XOR<NotificationChannelUpdateWithoutOrganizationInput, NotificationChannelUncheckedUpdateWithoutOrganizationInput>
  }

  export type NotificationChannelUpdateManyWithWhereWithoutOrganizationInput = {
    where: NotificationChannelScalarWhereInput
    data: XOR<NotificationChannelUpdateManyMutationInput, NotificationChannelUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type NotificationChannelScalarWhereInput = {
    AND?: NotificationChannelScalarWhereInput | NotificationChannelScalarWhereInput[]
    OR?: NotificationChannelScalarWhereInput[]
    NOT?: NotificationChannelScalarWhereInput | NotificationChannelScalarWhereInput[]
    id?: StringFilter<"NotificationChannel"> | string
    name?: StringFilter<"NotificationChannel"> | string
    type?: EnumNotificationChannelTypeFilter<"NotificationChannel"> | $Enums.NotificationChannelType
    config?: JsonFilter<"NotificationChannel">
    enabled?: BoolFilter<"NotificationChannel"> | boolean
    orgId?: StringFilter<"NotificationChannel"> | string
    createdAt?: DateTimeFilter<"NotificationChannel"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationChannel"> | Date | string
  }

  export type ApiKeyUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ApiKeyWhereUniqueInput
    update: XOR<ApiKeyUpdateWithoutOrganizationInput, ApiKeyUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ApiKeyCreateWithoutOrganizationInput, ApiKeyUncheckedCreateWithoutOrganizationInput>
  }

  export type ApiKeyUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ApiKeyWhereUniqueInput
    data: XOR<ApiKeyUpdateWithoutOrganizationInput, ApiKeyUncheckedUpdateWithoutOrganizationInput>
  }

  export type ApiKeyUpdateManyWithWhereWithoutOrganizationInput = {
    where: ApiKeyScalarWhereInput
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ApiKeyScalarWhereInput = {
    AND?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    OR?: ApiKeyScalarWhereInput[]
    NOT?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    key?: StringFilter<"ApiKey"> | string
    orgId?: StringFilter<"ApiKey"> | string
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
  }

  export type StatusPageConfigUpsertWithoutOrganizationInput = {
    update: XOR<StatusPageConfigUpdateWithoutOrganizationInput, StatusPageConfigUncheckedUpdateWithoutOrganizationInput>
    create: XOR<StatusPageConfigCreateWithoutOrganizationInput, StatusPageConfigUncheckedCreateWithoutOrganizationInput>
    where?: StatusPageConfigWhereInput
  }

  export type StatusPageConfigUpdateToOneWithWhereWithoutOrganizationInput = {
    where?: StatusPageConfigWhereInput
    data: XOR<StatusPageConfigUpdateWithoutOrganizationInput, StatusPageConfigUncheckedUpdateWithoutOrganizationInput>
  }

  export type StatusPageConfigUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    faviconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    customCss?: NullableStringFieldUpdateOperationsInput | string | null
    showUptime?: BoolFieldUpdateOperationsInput | boolean
    showResponseTime?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusPageConfigUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    faviconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    customCss?: NullableStringFieldUpdateOperationsInput | string | null
    showUptime?: BoolFieldUpdateOperationsInput | boolean
    showResponseTime?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateWithoutMembersInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    monitors?: MonitorCreateNestedManyWithoutOrganizationInput
    components?: ComponentCreateNestedManyWithoutOrganizationInput
    componentGroups?: ComponentGroupCreateNestedManyWithoutOrganizationInput
    incidents?: IncidentCreateNestedManyWithoutOrganizationInput
    subscribers?: SubscriberCreateNestedManyWithoutOrganizationInput
    notificationChannels?: NotificationChannelCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput
    statusPageConfig?: StatusPageConfigCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    monitors?: MonitorUncheckedCreateNestedManyWithoutOrganizationInput
    components?: ComponentUncheckedCreateNestedManyWithoutOrganizationInput
    componentGroups?: ComponentGroupUncheckedCreateNestedManyWithoutOrganizationInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrganizationInput
    subscribers?: SubscriberUncheckedCreateNestedManyWithoutOrganizationInput
    notificationChannels?: NotificationChannelUncheckedCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput
    statusPageConfig?: StatusPageConfigUncheckedCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutMembersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
  }

  export type OrganizationUpsertWithoutMembersInput = {
    update: XOR<OrganizationUpdateWithoutMembersInput, OrganizationUncheckedUpdateWithoutMembersInput>
    create: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutMembersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutMembersInput, OrganizationUncheckedUpdateWithoutMembersInput>
  }

  export type OrganizationUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monitors?: MonitorUpdateManyWithoutOrganizationNestedInput
    components?: ComponentUpdateManyWithoutOrganizationNestedInput
    componentGroups?: ComponentGroupUpdateManyWithoutOrganizationNestedInput
    incidents?: IncidentUpdateManyWithoutOrganizationNestedInput
    subscribers?: SubscriberUpdateManyWithoutOrganizationNestedInput
    notificationChannels?: NotificationChannelUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput
    statusPageConfig?: StatusPageConfigUpdateOneWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monitors?: MonitorUncheckedUpdateManyWithoutOrganizationNestedInput
    components?: ComponentUncheckedUpdateManyWithoutOrganizationNestedInput
    componentGroups?: ComponentGroupUncheckedUpdateManyWithoutOrganizationNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrganizationNestedInput
    subscribers?: SubscriberUncheckedUpdateManyWithoutOrganizationNestedInput
    notificationChannels?: NotificationChannelUncheckedUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput
    statusPageConfig?: StatusPageConfigUncheckedUpdateOneWithoutOrganizationNestedInput
  }

  export type OrganizationCreateWithoutMonitorsInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MemberCreateNestedManyWithoutOrganizationInput
    components?: ComponentCreateNestedManyWithoutOrganizationInput
    componentGroups?: ComponentGroupCreateNestedManyWithoutOrganizationInput
    incidents?: IncidentCreateNestedManyWithoutOrganizationInput
    subscribers?: SubscriberCreateNestedManyWithoutOrganizationInput
    notificationChannels?: NotificationChannelCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput
    statusPageConfig?: StatusPageConfigCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutMonitorsInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    components?: ComponentUncheckedCreateNestedManyWithoutOrganizationInput
    componentGroups?: ComponentGroupUncheckedCreateNestedManyWithoutOrganizationInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrganizationInput
    subscribers?: SubscriberUncheckedCreateNestedManyWithoutOrganizationInput
    notificationChannels?: NotificationChannelUncheckedCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput
    statusPageConfig?: StatusPageConfigUncheckedCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutMonitorsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutMonitorsInput, OrganizationUncheckedCreateWithoutMonitorsInput>
  }

  export type ComponentCreateWithoutMonitorsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ComponentStatus
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutComponentsInput
    group?: ComponentGroupCreateNestedOneWithoutComponentsInput
    incidents?: IncidentComponentCreateNestedManyWithoutComponentInput
  }

  export type ComponentUncheckedCreateWithoutMonitorsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ComponentStatus
    order?: number
    orgId: string
    groupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    incidents?: IncidentComponentUncheckedCreateNestedManyWithoutComponentInput
  }

  export type ComponentCreateOrConnectWithoutMonitorsInput = {
    where: ComponentWhereUniqueInput
    create: XOR<ComponentCreateWithoutMonitorsInput, ComponentUncheckedCreateWithoutMonitorsInput>
  }

  export type MonitorCheckCreateWithoutMonitorInput = {
    id?: string
    status: $Enums.MonitorStatus
    responseTime?: number | null
    statusCode?: number | null
    message?: string | null
    error?: string | null
    region?: string | null
    checkedAt?: Date | string
  }

  export type MonitorCheckUncheckedCreateWithoutMonitorInput = {
    id?: string
    status: $Enums.MonitorStatus
    responseTime?: number | null
    statusCode?: number | null
    message?: string | null
    error?: string | null
    region?: string | null
    checkedAt?: Date | string
  }

  export type MonitorCheckCreateOrConnectWithoutMonitorInput = {
    where: MonitorCheckWhereUniqueInput
    create: XOR<MonitorCheckCreateWithoutMonitorInput, MonitorCheckUncheckedCreateWithoutMonitorInput>
  }

  export type MonitorCheckCreateManyMonitorInputEnvelope = {
    data: MonitorCheckCreateManyMonitorInput | MonitorCheckCreateManyMonitorInput[]
    skipDuplicates?: boolean
  }

  export type MonitorAlertCreateWithoutMonitorInput = {
    id?: string
    type: string
    message: string
    createdAt?: Date | string
  }

  export type MonitorAlertUncheckedCreateWithoutMonitorInput = {
    id?: string
    type: string
    message: string
    createdAt?: Date | string
  }

  export type MonitorAlertCreateOrConnectWithoutMonitorInput = {
    where: MonitorAlertWhereUniqueInput
    create: XOR<MonitorAlertCreateWithoutMonitorInput, MonitorAlertUncheckedCreateWithoutMonitorInput>
  }

  export type MonitorAlertCreateManyMonitorInputEnvelope = {
    data: MonitorAlertCreateManyMonitorInput | MonitorAlertCreateManyMonitorInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutMonitorsInput = {
    update: XOR<OrganizationUpdateWithoutMonitorsInput, OrganizationUncheckedUpdateWithoutMonitorsInput>
    create: XOR<OrganizationCreateWithoutMonitorsInput, OrganizationUncheckedCreateWithoutMonitorsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutMonitorsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutMonitorsInput, OrganizationUncheckedUpdateWithoutMonitorsInput>
  }

  export type OrganizationUpdateWithoutMonitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    components?: ComponentUpdateManyWithoutOrganizationNestedInput
    componentGroups?: ComponentGroupUpdateManyWithoutOrganizationNestedInput
    incidents?: IncidentUpdateManyWithoutOrganizationNestedInput
    subscribers?: SubscriberUpdateManyWithoutOrganizationNestedInput
    notificationChannels?: NotificationChannelUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput
    statusPageConfig?: StatusPageConfigUpdateOneWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutMonitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    components?: ComponentUncheckedUpdateManyWithoutOrganizationNestedInput
    componentGroups?: ComponentGroupUncheckedUpdateManyWithoutOrganizationNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrganizationNestedInput
    subscribers?: SubscriberUncheckedUpdateManyWithoutOrganizationNestedInput
    notificationChannels?: NotificationChannelUncheckedUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput
    statusPageConfig?: StatusPageConfigUncheckedUpdateOneWithoutOrganizationNestedInput
  }

  export type ComponentUpsertWithoutMonitorsInput = {
    update: XOR<ComponentUpdateWithoutMonitorsInput, ComponentUncheckedUpdateWithoutMonitorsInput>
    create: XOR<ComponentCreateWithoutMonitorsInput, ComponentUncheckedCreateWithoutMonitorsInput>
    where?: ComponentWhereInput
  }

  export type ComponentUpdateToOneWithWhereWithoutMonitorsInput = {
    where?: ComponentWhereInput
    data: XOR<ComponentUpdateWithoutMonitorsInput, ComponentUncheckedUpdateWithoutMonitorsInput>
  }

  export type ComponentUpdateWithoutMonitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComponentStatusFieldUpdateOperationsInput | $Enums.ComponentStatus
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutComponentsNestedInput
    group?: ComponentGroupUpdateOneWithoutComponentsNestedInput
    incidents?: IncidentComponentUpdateManyWithoutComponentNestedInput
  }

  export type ComponentUncheckedUpdateWithoutMonitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComponentStatusFieldUpdateOperationsInput | $Enums.ComponentStatus
    order?: IntFieldUpdateOperationsInput | number
    orgId?: StringFieldUpdateOperationsInput | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    incidents?: IncidentComponentUncheckedUpdateManyWithoutComponentNestedInput
  }

  export type MonitorCheckUpsertWithWhereUniqueWithoutMonitorInput = {
    where: MonitorCheckWhereUniqueInput
    update: XOR<MonitorCheckUpdateWithoutMonitorInput, MonitorCheckUncheckedUpdateWithoutMonitorInput>
    create: XOR<MonitorCheckCreateWithoutMonitorInput, MonitorCheckUncheckedCreateWithoutMonitorInput>
  }

  export type MonitorCheckUpdateWithWhereUniqueWithoutMonitorInput = {
    where: MonitorCheckWhereUniqueInput
    data: XOR<MonitorCheckUpdateWithoutMonitorInput, MonitorCheckUncheckedUpdateWithoutMonitorInput>
  }

  export type MonitorCheckUpdateManyWithWhereWithoutMonitorInput = {
    where: MonitorCheckScalarWhereInput
    data: XOR<MonitorCheckUpdateManyMutationInput, MonitorCheckUncheckedUpdateManyWithoutMonitorInput>
  }

  export type MonitorCheckScalarWhereInput = {
    AND?: MonitorCheckScalarWhereInput | MonitorCheckScalarWhereInput[]
    OR?: MonitorCheckScalarWhereInput[]
    NOT?: MonitorCheckScalarWhereInput | MonitorCheckScalarWhereInput[]
    id?: StringFilter<"MonitorCheck"> | string
    monitorId?: StringFilter<"MonitorCheck"> | string
    status?: EnumMonitorStatusFilter<"MonitorCheck"> | $Enums.MonitorStatus
    responseTime?: IntNullableFilter<"MonitorCheck"> | number | null
    statusCode?: IntNullableFilter<"MonitorCheck"> | number | null
    message?: StringNullableFilter<"MonitorCheck"> | string | null
    error?: StringNullableFilter<"MonitorCheck"> | string | null
    region?: StringNullableFilter<"MonitorCheck"> | string | null
    checkedAt?: DateTimeFilter<"MonitorCheck"> | Date | string
  }

  export type MonitorAlertUpsertWithWhereUniqueWithoutMonitorInput = {
    where: MonitorAlertWhereUniqueInput
    update: XOR<MonitorAlertUpdateWithoutMonitorInput, MonitorAlertUncheckedUpdateWithoutMonitorInput>
    create: XOR<MonitorAlertCreateWithoutMonitorInput, MonitorAlertUncheckedCreateWithoutMonitorInput>
  }

  export type MonitorAlertUpdateWithWhereUniqueWithoutMonitorInput = {
    where: MonitorAlertWhereUniqueInput
    data: XOR<MonitorAlertUpdateWithoutMonitorInput, MonitorAlertUncheckedUpdateWithoutMonitorInput>
  }

  export type MonitorAlertUpdateManyWithWhereWithoutMonitorInput = {
    where: MonitorAlertScalarWhereInput
    data: XOR<MonitorAlertUpdateManyMutationInput, MonitorAlertUncheckedUpdateManyWithoutMonitorInput>
  }

  export type MonitorAlertScalarWhereInput = {
    AND?: MonitorAlertScalarWhereInput | MonitorAlertScalarWhereInput[]
    OR?: MonitorAlertScalarWhereInput[]
    NOT?: MonitorAlertScalarWhereInput | MonitorAlertScalarWhereInput[]
    id?: StringFilter<"MonitorAlert"> | string
    monitorId?: StringFilter<"MonitorAlert"> | string
    type?: StringFilter<"MonitorAlert"> | string
    message?: StringFilter<"MonitorAlert"> | string
    createdAt?: DateTimeFilter<"MonitorAlert"> | Date | string
  }

  export type MonitorCreateWithoutChecksInput = {
    id?: string
    name: string
    type: $Enums.MonitorType
    url?: string | null
    target?: string | null
    method?: $Enums.HttpMethod
    interval?: number
    timeout?: number
    status?: $Enums.MonitorStatus
    currentStatus?: string
    enabled?: boolean
    headers?: NullableJsonNullValueInput | InputJsonValue
    body?: string | null
    expectedStatus?: number | null
    keyword?: string | null
    keywordType?: $Enums.KeywordType | null
    heartbeatToken?: string | null
    heartbeatGrace?: number | null
    sslExpiryThreshold?: number | null
    alertAfter?: number
    recoveryAfter?: number
    lastCheckedAt?: Date | string | null
    uptimeDay?: number | null
    uptimeWeek?: number | null
    uptimeMonth?: number | null
    avgResponseTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutMonitorsInput
    component?: ComponentCreateNestedOneWithoutMonitorsInput
    alerts?: MonitorAlertCreateNestedManyWithoutMonitorInput
  }

  export type MonitorUncheckedCreateWithoutChecksInput = {
    id?: string
    name: string
    type: $Enums.MonitorType
    url?: string | null
    target?: string | null
    method?: $Enums.HttpMethod
    interval?: number
    timeout?: number
    status?: $Enums.MonitorStatus
    currentStatus?: string
    enabled?: boolean
    orgId: string
    componentId?: string | null
    headers?: NullableJsonNullValueInput | InputJsonValue
    body?: string | null
    expectedStatus?: number | null
    keyword?: string | null
    keywordType?: $Enums.KeywordType | null
    heartbeatToken?: string | null
    heartbeatGrace?: number | null
    sslExpiryThreshold?: number | null
    alertAfter?: number
    recoveryAfter?: number
    lastCheckedAt?: Date | string | null
    uptimeDay?: number | null
    uptimeWeek?: number | null
    uptimeMonth?: number | null
    avgResponseTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: MonitorAlertUncheckedCreateNestedManyWithoutMonitorInput
  }

  export type MonitorCreateOrConnectWithoutChecksInput = {
    where: MonitorWhereUniqueInput
    create: XOR<MonitorCreateWithoutChecksInput, MonitorUncheckedCreateWithoutChecksInput>
  }

  export type MonitorUpsertWithoutChecksInput = {
    update: XOR<MonitorUpdateWithoutChecksInput, MonitorUncheckedUpdateWithoutChecksInput>
    create: XOR<MonitorCreateWithoutChecksInput, MonitorUncheckedCreateWithoutChecksInput>
    where?: MonitorWhereInput
  }

  export type MonitorUpdateToOneWithWhereWithoutChecksInput = {
    where?: MonitorWhereInput
    data: XOR<MonitorUpdateWithoutChecksInput, MonitorUncheckedUpdateWithoutChecksInput>
  }

  export type MonitorUpdateWithoutChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMonitorTypeFieldUpdateOperationsInput | $Enums.MonitorType
    url?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod
    interval?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    status?: EnumMonitorStatusFieldUpdateOperationsInput | $Enums.MonitorStatus
    currentStatus?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    headers?: NullableJsonNullValueInput | InputJsonValue
    body?: NullableStringFieldUpdateOperationsInput | string | null
    expectedStatus?: NullableIntFieldUpdateOperationsInput | number | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    keywordType?: NullableEnumKeywordTypeFieldUpdateOperationsInput | $Enums.KeywordType | null
    heartbeatToken?: NullableStringFieldUpdateOperationsInput | string | null
    heartbeatGrace?: NullableIntFieldUpdateOperationsInput | number | null
    sslExpiryThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    alertAfter?: IntFieldUpdateOperationsInput | number
    recoveryAfter?: IntFieldUpdateOperationsInput | number
    lastCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uptimeDay?: NullableFloatFieldUpdateOperationsInput | number | null
    uptimeWeek?: NullableFloatFieldUpdateOperationsInput | number | null
    uptimeMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    avgResponseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutMonitorsNestedInput
    component?: ComponentUpdateOneWithoutMonitorsNestedInput
    alerts?: MonitorAlertUpdateManyWithoutMonitorNestedInput
  }

  export type MonitorUncheckedUpdateWithoutChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMonitorTypeFieldUpdateOperationsInput | $Enums.MonitorType
    url?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod
    interval?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    status?: EnumMonitorStatusFieldUpdateOperationsInput | $Enums.MonitorStatus
    currentStatus?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    orgId?: StringFieldUpdateOperationsInput | string
    componentId?: NullableStringFieldUpdateOperationsInput | string | null
    headers?: NullableJsonNullValueInput | InputJsonValue
    body?: NullableStringFieldUpdateOperationsInput | string | null
    expectedStatus?: NullableIntFieldUpdateOperationsInput | number | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    keywordType?: NullableEnumKeywordTypeFieldUpdateOperationsInput | $Enums.KeywordType | null
    heartbeatToken?: NullableStringFieldUpdateOperationsInput | string | null
    heartbeatGrace?: NullableIntFieldUpdateOperationsInput | number | null
    sslExpiryThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    alertAfter?: IntFieldUpdateOperationsInput | number
    recoveryAfter?: IntFieldUpdateOperationsInput | number
    lastCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uptimeDay?: NullableFloatFieldUpdateOperationsInput | number | null
    uptimeWeek?: NullableFloatFieldUpdateOperationsInput | number | null
    uptimeMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    avgResponseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: MonitorAlertUncheckedUpdateManyWithoutMonitorNestedInput
  }

  export type MonitorCreateWithoutAlertsInput = {
    id?: string
    name: string
    type: $Enums.MonitorType
    url?: string | null
    target?: string | null
    method?: $Enums.HttpMethod
    interval?: number
    timeout?: number
    status?: $Enums.MonitorStatus
    currentStatus?: string
    enabled?: boolean
    headers?: NullableJsonNullValueInput | InputJsonValue
    body?: string | null
    expectedStatus?: number | null
    keyword?: string | null
    keywordType?: $Enums.KeywordType | null
    heartbeatToken?: string | null
    heartbeatGrace?: number | null
    sslExpiryThreshold?: number | null
    alertAfter?: number
    recoveryAfter?: number
    lastCheckedAt?: Date | string | null
    uptimeDay?: number | null
    uptimeWeek?: number | null
    uptimeMonth?: number | null
    avgResponseTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutMonitorsInput
    component?: ComponentCreateNestedOneWithoutMonitorsInput
    checks?: MonitorCheckCreateNestedManyWithoutMonitorInput
  }

  export type MonitorUncheckedCreateWithoutAlertsInput = {
    id?: string
    name: string
    type: $Enums.MonitorType
    url?: string | null
    target?: string | null
    method?: $Enums.HttpMethod
    interval?: number
    timeout?: number
    status?: $Enums.MonitorStatus
    currentStatus?: string
    enabled?: boolean
    orgId: string
    componentId?: string | null
    headers?: NullableJsonNullValueInput | InputJsonValue
    body?: string | null
    expectedStatus?: number | null
    keyword?: string | null
    keywordType?: $Enums.KeywordType | null
    heartbeatToken?: string | null
    heartbeatGrace?: number | null
    sslExpiryThreshold?: number | null
    alertAfter?: number
    recoveryAfter?: number
    lastCheckedAt?: Date | string | null
    uptimeDay?: number | null
    uptimeWeek?: number | null
    uptimeMonth?: number | null
    avgResponseTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checks?: MonitorCheckUncheckedCreateNestedManyWithoutMonitorInput
  }

  export type MonitorCreateOrConnectWithoutAlertsInput = {
    where: MonitorWhereUniqueInput
    create: XOR<MonitorCreateWithoutAlertsInput, MonitorUncheckedCreateWithoutAlertsInput>
  }

  export type MonitorUpsertWithoutAlertsInput = {
    update: XOR<MonitorUpdateWithoutAlertsInput, MonitorUncheckedUpdateWithoutAlertsInput>
    create: XOR<MonitorCreateWithoutAlertsInput, MonitorUncheckedCreateWithoutAlertsInput>
    where?: MonitorWhereInput
  }

  export type MonitorUpdateToOneWithWhereWithoutAlertsInput = {
    where?: MonitorWhereInput
    data: XOR<MonitorUpdateWithoutAlertsInput, MonitorUncheckedUpdateWithoutAlertsInput>
  }

  export type MonitorUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMonitorTypeFieldUpdateOperationsInput | $Enums.MonitorType
    url?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod
    interval?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    status?: EnumMonitorStatusFieldUpdateOperationsInput | $Enums.MonitorStatus
    currentStatus?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    headers?: NullableJsonNullValueInput | InputJsonValue
    body?: NullableStringFieldUpdateOperationsInput | string | null
    expectedStatus?: NullableIntFieldUpdateOperationsInput | number | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    keywordType?: NullableEnumKeywordTypeFieldUpdateOperationsInput | $Enums.KeywordType | null
    heartbeatToken?: NullableStringFieldUpdateOperationsInput | string | null
    heartbeatGrace?: NullableIntFieldUpdateOperationsInput | number | null
    sslExpiryThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    alertAfter?: IntFieldUpdateOperationsInput | number
    recoveryAfter?: IntFieldUpdateOperationsInput | number
    lastCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uptimeDay?: NullableFloatFieldUpdateOperationsInput | number | null
    uptimeWeek?: NullableFloatFieldUpdateOperationsInput | number | null
    uptimeMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    avgResponseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutMonitorsNestedInput
    component?: ComponentUpdateOneWithoutMonitorsNestedInput
    checks?: MonitorCheckUpdateManyWithoutMonitorNestedInput
  }

  export type MonitorUncheckedUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMonitorTypeFieldUpdateOperationsInput | $Enums.MonitorType
    url?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod
    interval?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    status?: EnumMonitorStatusFieldUpdateOperationsInput | $Enums.MonitorStatus
    currentStatus?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    orgId?: StringFieldUpdateOperationsInput | string
    componentId?: NullableStringFieldUpdateOperationsInput | string | null
    headers?: NullableJsonNullValueInput | InputJsonValue
    body?: NullableStringFieldUpdateOperationsInput | string | null
    expectedStatus?: NullableIntFieldUpdateOperationsInput | number | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    keywordType?: NullableEnumKeywordTypeFieldUpdateOperationsInput | $Enums.KeywordType | null
    heartbeatToken?: NullableStringFieldUpdateOperationsInput | string | null
    heartbeatGrace?: NullableIntFieldUpdateOperationsInput | number | null
    sslExpiryThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    alertAfter?: IntFieldUpdateOperationsInput | number
    recoveryAfter?: IntFieldUpdateOperationsInput | number
    lastCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uptimeDay?: NullableFloatFieldUpdateOperationsInput | number | null
    uptimeWeek?: NullableFloatFieldUpdateOperationsInput | number | null
    uptimeMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    avgResponseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checks?: MonitorCheckUncheckedUpdateManyWithoutMonitorNestedInput
  }

  export type OrganizationCreateWithoutComponentGroupsInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MemberCreateNestedManyWithoutOrganizationInput
    monitors?: MonitorCreateNestedManyWithoutOrganizationInput
    components?: ComponentCreateNestedManyWithoutOrganizationInput
    incidents?: IncidentCreateNestedManyWithoutOrganizationInput
    subscribers?: SubscriberCreateNestedManyWithoutOrganizationInput
    notificationChannels?: NotificationChannelCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput
    statusPageConfig?: StatusPageConfigCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutComponentGroupsInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    monitors?: MonitorUncheckedCreateNestedManyWithoutOrganizationInput
    components?: ComponentUncheckedCreateNestedManyWithoutOrganizationInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrganizationInput
    subscribers?: SubscriberUncheckedCreateNestedManyWithoutOrganizationInput
    notificationChannels?: NotificationChannelUncheckedCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput
    statusPageConfig?: StatusPageConfigUncheckedCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutComponentGroupsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutComponentGroupsInput, OrganizationUncheckedCreateWithoutComponentGroupsInput>
  }

  export type ComponentCreateWithoutGroupInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ComponentStatus
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutComponentsInput
    monitors?: MonitorCreateNestedManyWithoutComponentInput
    incidents?: IncidentComponentCreateNestedManyWithoutComponentInput
  }

  export type ComponentUncheckedCreateWithoutGroupInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ComponentStatus
    order?: number
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    monitors?: MonitorUncheckedCreateNestedManyWithoutComponentInput
    incidents?: IncidentComponentUncheckedCreateNestedManyWithoutComponentInput
  }

  export type ComponentCreateOrConnectWithoutGroupInput = {
    where: ComponentWhereUniqueInput
    create: XOR<ComponentCreateWithoutGroupInput, ComponentUncheckedCreateWithoutGroupInput>
  }

  export type ComponentCreateManyGroupInputEnvelope = {
    data: ComponentCreateManyGroupInput | ComponentCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutComponentGroupsInput = {
    update: XOR<OrganizationUpdateWithoutComponentGroupsInput, OrganizationUncheckedUpdateWithoutComponentGroupsInput>
    create: XOR<OrganizationCreateWithoutComponentGroupsInput, OrganizationUncheckedCreateWithoutComponentGroupsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutComponentGroupsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutComponentGroupsInput, OrganizationUncheckedUpdateWithoutComponentGroupsInput>
  }

  export type OrganizationUpdateWithoutComponentGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    monitors?: MonitorUpdateManyWithoutOrganizationNestedInput
    components?: ComponentUpdateManyWithoutOrganizationNestedInput
    incidents?: IncidentUpdateManyWithoutOrganizationNestedInput
    subscribers?: SubscriberUpdateManyWithoutOrganizationNestedInput
    notificationChannels?: NotificationChannelUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput
    statusPageConfig?: StatusPageConfigUpdateOneWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutComponentGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    monitors?: MonitorUncheckedUpdateManyWithoutOrganizationNestedInput
    components?: ComponentUncheckedUpdateManyWithoutOrganizationNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrganizationNestedInput
    subscribers?: SubscriberUncheckedUpdateManyWithoutOrganizationNestedInput
    notificationChannels?: NotificationChannelUncheckedUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput
    statusPageConfig?: StatusPageConfigUncheckedUpdateOneWithoutOrganizationNestedInput
  }

  export type ComponentUpsertWithWhereUniqueWithoutGroupInput = {
    where: ComponentWhereUniqueInput
    update: XOR<ComponentUpdateWithoutGroupInput, ComponentUncheckedUpdateWithoutGroupInput>
    create: XOR<ComponentCreateWithoutGroupInput, ComponentUncheckedCreateWithoutGroupInput>
  }

  export type ComponentUpdateWithWhereUniqueWithoutGroupInput = {
    where: ComponentWhereUniqueInput
    data: XOR<ComponentUpdateWithoutGroupInput, ComponentUncheckedUpdateWithoutGroupInput>
  }

  export type ComponentUpdateManyWithWhereWithoutGroupInput = {
    where: ComponentScalarWhereInput
    data: XOR<ComponentUpdateManyMutationInput, ComponentUncheckedUpdateManyWithoutGroupInput>
  }

  export type OrganizationCreateWithoutComponentsInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MemberCreateNestedManyWithoutOrganizationInput
    monitors?: MonitorCreateNestedManyWithoutOrganizationInput
    componentGroups?: ComponentGroupCreateNestedManyWithoutOrganizationInput
    incidents?: IncidentCreateNestedManyWithoutOrganizationInput
    subscribers?: SubscriberCreateNestedManyWithoutOrganizationInput
    notificationChannels?: NotificationChannelCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput
    statusPageConfig?: StatusPageConfigCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutComponentsInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    monitors?: MonitorUncheckedCreateNestedManyWithoutOrganizationInput
    componentGroups?: ComponentGroupUncheckedCreateNestedManyWithoutOrganizationInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrganizationInput
    subscribers?: SubscriberUncheckedCreateNestedManyWithoutOrganizationInput
    notificationChannels?: NotificationChannelUncheckedCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput
    statusPageConfig?: StatusPageConfigUncheckedCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutComponentsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutComponentsInput, OrganizationUncheckedCreateWithoutComponentsInput>
  }

  export type ComponentGroupCreateWithoutComponentsInput = {
    id?: string
    name: string
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutComponentGroupsInput
  }

  export type ComponentGroupUncheckedCreateWithoutComponentsInput = {
    id?: string
    name: string
    order?: number
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComponentGroupCreateOrConnectWithoutComponentsInput = {
    where: ComponentGroupWhereUniqueInput
    create: XOR<ComponentGroupCreateWithoutComponentsInput, ComponentGroupUncheckedCreateWithoutComponentsInput>
  }

  export type MonitorCreateWithoutComponentInput = {
    id?: string
    name: string
    type: $Enums.MonitorType
    url?: string | null
    target?: string | null
    method?: $Enums.HttpMethod
    interval?: number
    timeout?: number
    status?: $Enums.MonitorStatus
    currentStatus?: string
    enabled?: boolean
    headers?: NullableJsonNullValueInput | InputJsonValue
    body?: string | null
    expectedStatus?: number | null
    keyword?: string | null
    keywordType?: $Enums.KeywordType | null
    heartbeatToken?: string | null
    heartbeatGrace?: number | null
    sslExpiryThreshold?: number | null
    alertAfter?: number
    recoveryAfter?: number
    lastCheckedAt?: Date | string | null
    uptimeDay?: number | null
    uptimeWeek?: number | null
    uptimeMonth?: number | null
    avgResponseTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutMonitorsInput
    checks?: MonitorCheckCreateNestedManyWithoutMonitorInput
    alerts?: MonitorAlertCreateNestedManyWithoutMonitorInput
  }

  export type MonitorUncheckedCreateWithoutComponentInput = {
    id?: string
    name: string
    type: $Enums.MonitorType
    url?: string | null
    target?: string | null
    method?: $Enums.HttpMethod
    interval?: number
    timeout?: number
    status?: $Enums.MonitorStatus
    currentStatus?: string
    enabled?: boolean
    orgId: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    body?: string | null
    expectedStatus?: number | null
    keyword?: string | null
    keywordType?: $Enums.KeywordType | null
    heartbeatToken?: string | null
    heartbeatGrace?: number | null
    sslExpiryThreshold?: number | null
    alertAfter?: number
    recoveryAfter?: number
    lastCheckedAt?: Date | string | null
    uptimeDay?: number | null
    uptimeWeek?: number | null
    uptimeMonth?: number | null
    avgResponseTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checks?: MonitorCheckUncheckedCreateNestedManyWithoutMonitorInput
    alerts?: MonitorAlertUncheckedCreateNestedManyWithoutMonitorInput
  }

  export type MonitorCreateOrConnectWithoutComponentInput = {
    where: MonitorWhereUniqueInput
    create: XOR<MonitorCreateWithoutComponentInput, MonitorUncheckedCreateWithoutComponentInput>
  }

  export type MonitorCreateManyComponentInputEnvelope = {
    data: MonitorCreateManyComponentInput | MonitorCreateManyComponentInput[]
    skipDuplicates?: boolean
  }

  export type IncidentComponentCreateWithoutComponentInput = {
    id?: string
    status: $Enums.ComponentStatus
    incident: IncidentCreateNestedOneWithoutComponentsInput
  }

  export type IncidentComponentUncheckedCreateWithoutComponentInput = {
    id?: string
    incidentId: string
    status: $Enums.ComponentStatus
  }

  export type IncidentComponentCreateOrConnectWithoutComponentInput = {
    where: IncidentComponentWhereUniqueInput
    create: XOR<IncidentComponentCreateWithoutComponentInput, IncidentComponentUncheckedCreateWithoutComponentInput>
  }

  export type IncidentComponentCreateManyComponentInputEnvelope = {
    data: IncidentComponentCreateManyComponentInput | IncidentComponentCreateManyComponentInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutComponentsInput = {
    update: XOR<OrganizationUpdateWithoutComponentsInput, OrganizationUncheckedUpdateWithoutComponentsInput>
    create: XOR<OrganizationCreateWithoutComponentsInput, OrganizationUncheckedCreateWithoutComponentsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutComponentsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutComponentsInput, OrganizationUncheckedUpdateWithoutComponentsInput>
  }

  export type OrganizationUpdateWithoutComponentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    monitors?: MonitorUpdateManyWithoutOrganizationNestedInput
    componentGroups?: ComponentGroupUpdateManyWithoutOrganizationNestedInput
    incidents?: IncidentUpdateManyWithoutOrganizationNestedInput
    subscribers?: SubscriberUpdateManyWithoutOrganizationNestedInput
    notificationChannels?: NotificationChannelUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput
    statusPageConfig?: StatusPageConfigUpdateOneWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutComponentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    monitors?: MonitorUncheckedUpdateManyWithoutOrganizationNestedInput
    componentGroups?: ComponentGroupUncheckedUpdateManyWithoutOrganizationNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrganizationNestedInput
    subscribers?: SubscriberUncheckedUpdateManyWithoutOrganizationNestedInput
    notificationChannels?: NotificationChannelUncheckedUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput
    statusPageConfig?: StatusPageConfigUncheckedUpdateOneWithoutOrganizationNestedInput
  }

  export type ComponentGroupUpsertWithoutComponentsInput = {
    update: XOR<ComponentGroupUpdateWithoutComponentsInput, ComponentGroupUncheckedUpdateWithoutComponentsInput>
    create: XOR<ComponentGroupCreateWithoutComponentsInput, ComponentGroupUncheckedCreateWithoutComponentsInput>
    where?: ComponentGroupWhereInput
  }

  export type ComponentGroupUpdateToOneWithWhereWithoutComponentsInput = {
    where?: ComponentGroupWhereInput
    data: XOR<ComponentGroupUpdateWithoutComponentsInput, ComponentGroupUncheckedUpdateWithoutComponentsInput>
  }

  export type ComponentGroupUpdateWithoutComponentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutComponentGroupsNestedInput
  }

  export type ComponentGroupUncheckedUpdateWithoutComponentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitorUpsertWithWhereUniqueWithoutComponentInput = {
    where: MonitorWhereUniqueInput
    update: XOR<MonitorUpdateWithoutComponentInput, MonitorUncheckedUpdateWithoutComponentInput>
    create: XOR<MonitorCreateWithoutComponentInput, MonitorUncheckedCreateWithoutComponentInput>
  }

  export type MonitorUpdateWithWhereUniqueWithoutComponentInput = {
    where: MonitorWhereUniqueInput
    data: XOR<MonitorUpdateWithoutComponentInput, MonitorUncheckedUpdateWithoutComponentInput>
  }

  export type MonitorUpdateManyWithWhereWithoutComponentInput = {
    where: MonitorScalarWhereInput
    data: XOR<MonitorUpdateManyMutationInput, MonitorUncheckedUpdateManyWithoutComponentInput>
  }

  export type IncidentComponentUpsertWithWhereUniqueWithoutComponentInput = {
    where: IncidentComponentWhereUniqueInput
    update: XOR<IncidentComponentUpdateWithoutComponentInput, IncidentComponentUncheckedUpdateWithoutComponentInput>
    create: XOR<IncidentComponentCreateWithoutComponentInput, IncidentComponentUncheckedCreateWithoutComponentInput>
  }

  export type IncidentComponentUpdateWithWhereUniqueWithoutComponentInput = {
    where: IncidentComponentWhereUniqueInput
    data: XOR<IncidentComponentUpdateWithoutComponentInput, IncidentComponentUncheckedUpdateWithoutComponentInput>
  }

  export type IncidentComponentUpdateManyWithWhereWithoutComponentInput = {
    where: IncidentComponentScalarWhereInput
    data: XOR<IncidentComponentUpdateManyMutationInput, IncidentComponentUncheckedUpdateManyWithoutComponentInput>
  }

  export type IncidentComponentScalarWhereInput = {
    AND?: IncidentComponentScalarWhereInput | IncidentComponentScalarWhereInput[]
    OR?: IncidentComponentScalarWhereInput[]
    NOT?: IncidentComponentScalarWhereInput | IncidentComponentScalarWhereInput[]
    id?: StringFilter<"IncidentComponent"> | string
    incidentId?: StringFilter<"IncidentComponent"> | string
    componentId?: StringFilter<"IncidentComponent"> | string
    status?: EnumComponentStatusFilter<"IncidentComponent"> | $Enums.ComponentStatus
  }

  export type OrganizationCreateWithoutIncidentsInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MemberCreateNestedManyWithoutOrganizationInput
    monitors?: MonitorCreateNestedManyWithoutOrganizationInput
    components?: ComponentCreateNestedManyWithoutOrganizationInput
    componentGroups?: ComponentGroupCreateNestedManyWithoutOrganizationInput
    subscribers?: SubscriberCreateNestedManyWithoutOrganizationInput
    notificationChannels?: NotificationChannelCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput
    statusPageConfig?: StatusPageConfigCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutIncidentsInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    monitors?: MonitorUncheckedCreateNestedManyWithoutOrganizationInput
    components?: ComponentUncheckedCreateNestedManyWithoutOrganizationInput
    componentGroups?: ComponentGroupUncheckedCreateNestedManyWithoutOrganizationInput
    subscribers?: SubscriberUncheckedCreateNestedManyWithoutOrganizationInput
    notificationChannels?: NotificationChannelUncheckedCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput
    statusPageConfig?: StatusPageConfigUncheckedCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutIncidentsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutIncidentsInput, OrganizationUncheckedCreateWithoutIncidentsInput>
  }

  export type IncidentUpdateCreateWithoutIncidentInput = {
    id?: string
    status: $Enums.IncidentStatus
    message: string
    createdAt?: Date | string
  }

  export type IncidentUpdateUncheckedCreateWithoutIncidentInput = {
    id?: string
    status: $Enums.IncidentStatus
    message: string
    createdAt?: Date | string
  }

  export type IncidentUpdateCreateOrConnectWithoutIncidentInput = {
    where: IncidentUpdateWhereUniqueInput
    create: XOR<IncidentUpdateCreateWithoutIncidentInput, IncidentUpdateUncheckedCreateWithoutIncidentInput>
  }

  export type IncidentUpdateCreateManyIncidentInputEnvelope = {
    data: IncidentUpdateCreateManyIncidentInput | IncidentUpdateCreateManyIncidentInput[]
    skipDuplicates?: boolean
  }

  export type IncidentComponentCreateWithoutIncidentInput = {
    id?: string
    status: $Enums.ComponentStatus
    component: ComponentCreateNestedOneWithoutIncidentsInput
  }

  export type IncidentComponentUncheckedCreateWithoutIncidentInput = {
    id?: string
    componentId: string
    status: $Enums.ComponentStatus
  }

  export type IncidentComponentCreateOrConnectWithoutIncidentInput = {
    where: IncidentComponentWhereUniqueInput
    create: XOR<IncidentComponentCreateWithoutIncidentInput, IncidentComponentUncheckedCreateWithoutIncidentInput>
  }

  export type IncidentComponentCreateManyIncidentInputEnvelope = {
    data: IncidentComponentCreateManyIncidentInput | IncidentComponentCreateManyIncidentInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutIncidentsInput = {
    update: XOR<OrganizationUpdateWithoutIncidentsInput, OrganizationUncheckedUpdateWithoutIncidentsInput>
    create: XOR<OrganizationCreateWithoutIncidentsInput, OrganizationUncheckedCreateWithoutIncidentsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutIncidentsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutIncidentsInput, OrganizationUncheckedUpdateWithoutIncidentsInput>
  }

  export type OrganizationUpdateWithoutIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    monitors?: MonitorUpdateManyWithoutOrganizationNestedInput
    components?: ComponentUpdateManyWithoutOrganizationNestedInput
    componentGroups?: ComponentGroupUpdateManyWithoutOrganizationNestedInput
    subscribers?: SubscriberUpdateManyWithoutOrganizationNestedInput
    notificationChannels?: NotificationChannelUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput
    statusPageConfig?: StatusPageConfigUpdateOneWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    monitors?: MonitorUncheckedUpdateManyWithoutOrganizationNestedInput
    components?: ComponentUncheckedUpdateManyWithoutOrganizationNestedInput
    componentGroups?: ComponentGroupUncheckedUpdateManyWithoutOrganizationNestedInput
    subscribers?: SubscriberUncheckedUpdateManyWithoutOrganizationNestedInput
    notificationChannels?: NotificationChannelUncheckedUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput
    statusPageConfig?: StatusPageConfigUncheckedUpdateOneWithoutOrganizationNestedInput
  }

  export type IncidentUpdateUpsertWithWhereUniqueWithoutIncidentInput = {
    where: IncidentUpdateWhereUniqueInput
    update: XOR<IncidentUpdateUpdateWithoutIncidentInput, IncidentUpdateUncheckedUpdateWithoutIncidentInput>
    create: XOR<IncidentUpdateCreateWithoutIncidentInput, IncidentUpdateUncheckedCreateWithoutIncidentInput>
  }

  export type IncidentUpdateUpdateWithWhereUniqueWithoutIncidentInput = {
    where: IncidentUpdateWhereUniqueInput
    data: XOR<IncidentUpdateUpdateWithoutIncidentInput, IncidentUpdateUncheckedUpdateWithoutIncidentInput>
  }

  export type IncidentUpdateUpdateManyWithWhereWithoutIncidentInput = {
    where: IncidentUpdateScalarWhereInput
    data: XOR<IncidentUpdateUpdateManyMutationInput, IncidentUpdateUncheckedUpdateManyWithoutIncidentInput>
  }

  export type IncidentUpdateScalarWhereInput = {
    AND?: IncidentUpdateScalarWhereInput | IncidentUpdateScalarWhereInput[]
    OR?: IncidentUpdateScalarWhereInput[]
    NOT?: IncidentUpdateScalarWhereInput | IncidentUpdateScalarWhereInput[]
    id?: StringFilter<"IncidentUpdate"> | string
    incidentId?: StringFilter<"IncidentUpdate"> | string
    status?: EnumIncidentStatusFilter<"IncidentUpdate"> | $Enums.IncidentStatus
    message?: StringFilter<"IncidentUpdate"> | string
    createdAt?: DateTimeFilter<"IncidentUpdate"> | Date | string
  }

  export type IncidentComponentUpsertWithWhereUniqueWithoutIncidentInput = {
    where: IncidentComponentWhereUniqueInput
    update: XOR<IncidentComponentUpdateWithoutIncidentInput, IncidentComponentUncheckedUpdateWithoutIncidentInput>
    create: XOR<IncidentComponentCreateWithoutIncidentInput, IncidentComponentUncheckedCreateWithoutIncidentInput>
  }

  export type IncidentComponentUpdateWithWhereUniqueWithoutIncidentInput = {
    where: IncidentComponentWhereUniqueInput
    data: XOR<IncidentComponentUpdateWithoutIncidentInput, IncidentComponentUncheckedUpdateWithoutIncidentInput>
  }

  export type IncidentComponentUpdateManyWithWhereWithoutIncidentInput = {
    where: IncidentComponentScalarWhereInput
    data: XOR<IncidentComponentUpdateManyMutationInput, IncidentComponentUncheckedUpdateManyWithoutIncidentInput>
  }

  export type IncidentCreateWithoutUpdatesInput = {
    id?: string
    title: string
    status?: $Enums.IncidentStatus
    severity?: $Enums.IncidentSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    organization: OrganizationCreateNestedOneWithoutIncidentsInput
    components?: IncidentComponentCreateNestedManyWithoutIncidentInput
  }

  export type IncidentUncheckedCreateWithoutUpdatesInput = {
    id?: string
    title: string
    status?: $Enums.IncidentStatus
    severity?: $Enums.IncidentSeverity
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    components?: IncidentComponentUncheckedCreateNestedManyWithoutIncidentInput
  }

  export type IncidentCreateOrConnectWithoutUpdatesInput = {
    where: IncidentWhereUniqueInput
    create: XOR<IncidentCreateWithoutUpdatesInput, IncidentUncheckedCreateWithoutUpdatesInput>
  }

  export type IncidentUpsertWithoutUpdatesInput = {
    update: XOR<IncidentUpdateWithoutUpdatesInput, IncidentUncheckedUpdateWithoutUpdatesInput>
    create: XOR<IncidentCreateWithoutUpdatesInput, IncidentUncheckedCreateWithoutUpdatesInput>
    where?: IncidentWhereInput
  }

  export type IncidentUpdateToOneWithWhereWithoutUpdatesInput = {
    where?: IncidentWhereInput
    data: XOR<IncidentUpdateWithoutUpdatesInput, IncidentUncheckedUpdateWithoutUpdatesInput>
  }

  export type IncidentUpdateWithoutUpdatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: OrganizationUpdateOneRequiredWithoutIncidentsNestedInput
    components?: IncidentComponentUpdateManyWithoutIncidentNestedInput
  }

  export type IncidentUncheckedUpdateWithoutUpdatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    components?: IncidentComponentUncheckedUpdateManyWithoutIncidentNestedInput
  }

  export type IncidentCreateWithoutComponentsInput = {
    id?: string
    title: string
    status?: $Enums.IncidentStatus
    severity?: $Enums.IncidentSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    organization: OrganizationCreateNestedOneWithoutIncidentsInput
    updates?: IncidentUpdateCreateNestedManyWithoutIncidentInput
  }

  export type IncidentUncheckedCreateWithoutComponentsInput = {
    id?: string
    title: string
    status?: $Enums.IncidentStatus
    severity?: $Enums.IncidentSeverity
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    updates?: IncidentUpdateUncheckedCreateNestedManyWithoutIncidentInput
  }

  export type IncidentCreateOrConnectWithoutComponentsInput = {
    where: IncidentWhereUniqueInput
    create: XOR<IncidentCreateWithoutComponentsInput, IncidentUncheckedCreateWithoutComponentsInput>
  }

  export type ComponentCreateWithoutIncidentsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ComponentStatus
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutComponentsInput
    group?: ComponentGroupCreateNestedOneWithoutComponentsInput
    monitors?: MonitorCreateNestedManyWithoutComponentInput
  }

  export type ComponentUncheckedCreateWithoutIncidentsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ComponentStatus
    order?: number
    orgId: string
    groupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    monitors?: MonitorUncheckedCreateNestedManyWithoutComponentInput
  }

  export type ComponentCreateOrConnectWithoutIncidentsInput = {
    where: ComponentWhereUniqueInput
    create: XOR<ComponentCreateWithoutIncidentsInput, ComponentUncheckedCreateWithoutIncidentsInput>
  }

  export type IncidentUpsertWithoutComponentsInput = {
    update: XOR<IncidentUpdateWithoutComponentsInput, IncidentUncheckedUpdateWithoutComponentsInput>
    create: XOR<IncidentCreateWithoutComponentsInput, IncidentUncheckedCreateWithoutComponentsInput>
    where?: IncidentWhereInput
  }

  export type IncidentUpdateToOneWithWhereWithoutComponentsInput = {
    where?: IncidentWhereInput
    data: XOR<IncidentUpdateWithoutComponentsInput, IncidentUncheckedUpdateWithoutComponentsInput>
  }

  export type IncidentUpdateWithoutComponentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: OrganizationUpdateOneRequiredWithoutIncidentsNestedInput
    updates?: IncidentUpdateUpdateManyWithoutIncidentNestedInput
  }

  export type IncidentUncheckedUpdateWithoutComponentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updates?: IncidentUpdateUncheckedUpdateManyWithoutIncidentNestedInput
  }

  export type ComponentUpsertWithoutIncidentsInput = {
    update: XOR<ComponentUpdateWithoutIncidentsInput, ComponentUncheckedUpdateWithoutIncidentsInput>
    create: XOR<ComponentCreateWithoutIncidentsInput, ComponentUncheckedCreateWithoutIncidentsInput>
    where?: ComponentWhereInput
  }

  export type ComponentUpdateToOneWithWhereWithoutIncidentsInput = {
    where?: ComponentWhereInput
    data: XOR<ComponentUpdateWithoutIncidentsInput, ComponentUncheckedUpdateWithoutIncidentsInput>
  }

  export type ComponentUpdateWithoutIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComponentStatusFieldUpdateOperationsInput | $Enums.ComponentStatus
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutComponentsNestedInput
    group?: ComponentGroupUpdateOneWithoutComponentsNestedInput
    monitors?: MonitorUpdateManyWithoutComponentNestedInput
  }

  export type ComponentUncheckedUpdateWithoutIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComponentStatusFieldUpdateOperationsInput | $Enums.ComponentStatus
    order?: IntFieldUpdateOperationsInput | number
    orgId?: StringFieldUpdateOperationsInput | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monitors?: MonitorUncheckedUpdateManyWithoutComponentNestedInput
  }

  export type OrganizationCreateWithoutSubscribersInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MemberCreateNestedManyWithoutOrganizationInput
    monitors?: MonitorCreateNestedManyWithoutOrganizationInput
    components?: ComponentCreateNestedManyWithoutOrganizationInput
    componentGroups?: ComponentGroupCreateNestedManyWithoutOrganizationInput
    incidents?: IncidentCreateNestedManyWithoutOrganizationInput
    notificationChannels?: NotificationChannelCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput
    statusPageConfig?: StatusPageConfigCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutSubscribersInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    monitors?: MonitorUncheckedCreateNestedManyWithoutOrganizationInput
    components?: ComponentUncheckedCreateNestedManyWithoutOrganizationInput
    componentGroups?: ComponentGroupUncheckedCreateNestedManyWithoutOrganizationInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrganizationInput
    notificationChannels?: NotificationChannelUncheckedCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput
    statusPageConfig?: StatusPageConfigUncheckedCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutSubscribersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutSubscribersInput, OrganizationUncheckedCreateWithoutSubscribersInput>
  }

  export type AlertCreateWithoutSubscriberInput = {
    id?: string
    incidentId?: string | null
    subject: string
    body: string
    status?: $Enums.AlertStatus
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AlertUncheckedCreateWithoutSubscriberInput = {
    id?: string
    incidentId?: string | null
    subject: string
    body: string
    status?: $Enums.AlertStatus
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AlertCreateOrConnectWithoutSubscriberInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutSubscriberInput, AlertUncheckedCreateWithoutSubscriberInput>
  }

  export type AlertCreateManySubscriberInputEnvelope = {
    data: AlertCreateManySubscriberInput | AlertCreateManySubscriberInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutSubscribersInput = {
    update: XOR<OrganizationUpdateWithoutSubscribersInput, OrganizationUncheckedUpdateWithoutSubscribersInput>
    create: XOR<OrganizationCreateWithoutSubscribersInput, OrganizationUncheckedCreateWithoutSubscribersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutSubscribersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutSubscribersInput, OrganizationUncheckedUpdateWithoutSubscribersInput>
  }

  export type OrganizationUpdateWithoutSubscribersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    monitors?: MonitorUpdateManyWithoutOrganizationNestedInput
    components?: ComponentUpdateManyWithoutOrganizationNestedInput
    componentGroups?: ComponentGroupUpdateManyWithoutOrganizationNestedInput
    incidents?: IncidentUpdateManyWithoutOrganizationNestedInput
    notificationChannels?: NotificationChannelUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput
    statusPageConfig?: StatusPageConfigUpdateOneWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutSubscribersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    monitors?: MonitorUncheckedUpdateManyWithoutOrganizationNestedInput
    components?: ComponentUncheckedUpdateManyWithoutOrganizationNestedInput
    componentGroups?: ComponentGroupUncheckedUpdateManyWithoutOrganizationNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrganizationNestedInput
    notificationChannels?: NotificationChannelUncheckedUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput
    statusPageConfig?: StatusPageConfigUncheckedUpdateOneWithoutOrganizationNestedInput
  }

  export type AlertUpsertWithWhereUniqueWithoutSubscriberInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutSubscriberInput, AlertUncheckedUpdateWithoutSubscriberInput>
    create: XOR<AlertCreateWithoutSubscriberInput, AlertUncheckedCreateWithoutSubscriberInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutSubscriberInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutSubscriberInput, AlertUncheckedUpdateWithoutSubscriberInput>
  }

  export type AlertUpdateManyWithWhereWithoutSubscriberInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutSubscriberInput>
  }

  export type AlertScalarWhereInput = {
    AND?: AlertScalarWhereInput | AlertScalarWhereInput[]
    OR?: AlertScalarWhereInput[]
    NOT?: AlertScalarWhereInput | AlertScalarWhereInput[]
    id?: StringFilter<"Alert"> | string
    subscriberId?: StringFilter<"Alert"> | string
    incidentId?: StringNullableFilter<"Alert"> | string | null
    subject?: StringFilter<"Alert"> | string
    body?: StringFilter<"Alert"> | string
    status?: EnumAlertStatusFilter<"Alert"> | $Enums.AlertStatus
    sentAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    createdAt?: DateTimeFilter<"Alert"> | Date | string
  }

  export type SubscriberCreateWithoutAlertsInput = {
    id?: string
    type?: $Enums.SubscriberType
    email?: string | null
    webhookUrl?: string | null
    confirmed?: boolean
    token?: string
    createdAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutSubscribersInput
  }

  export type SubscriberUncheckedCreateWithoutAlertsInput = {
    id?: string
    type?: $Enums.SubscriberType
    email?: string | null
    webhookUrl?: string | null
    confirmed?: boolean
    token?: string
    orgId: string
    createdAt?: Date | string
  }

  export type SubscriberCreateOrConnectWithoutAlertsInput = {
    where: SubscriberWhereUniqueInput
    create: XOR<SubscriberCreateWithoutAlertsInput, SubscriberUncheckedCreateWithoutAlertsInput>
  }

  export type SubscriberUpsertWithoutAlertsInput = {
    update: XOR<SubscriberUpdateWithoutAlertsInput, SubscriberUncheckedUpdateWithoutAlertsInput>
    create: XOR<SubscriberCreateWithoutAlertsInput, SubscriberUncheckedCreateWithoutAlertsInput>
    where?: SubscriberWhereInput
  }

  export type SubscriberUpdateToOneWithWhereWithoutAlertsInput = {
    where?: SubscriberWhereInput
    data: XOR<SubscriberUpdateWithoutAlertsInput, SubscriberUncheckedUpdateWithoutAlertsInput>
  }

  export type SubscriberUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriberTypeFieldUpdateOperationsInput | $Enums.SubscriberType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutSubscribersNestedInput
  }

  export type SubscriberUncheckedUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriberTypeFieldUpdateOperationsInput | $Enums.SubscriberType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateWithoutNotificationChannelsInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MemberCreateNestedManyWithoutOrganizationInput
    monitors?: MonitorCreateNestedManyWithoutOrganizationInput
    components?: ComponentCreateNestedManyWithoutOrganizationInput
    componentGroups?: ComponentGroupCreateNestedManyWithoutOrganizationInput
    incidents?: IncidentCreateNestedManyWithoutOrganizationInput
    subscribers?: SubscriberCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput
    statusPageConfig?: StatusPageConfigCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutNotificationChannelsInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    monitors?: MonitorUncheckedCreateNestedManyWithoutOrganizationInput
    components?: ComponentUncheckedCreateNestedManyWithoutOrganizationInput
    componentGroups?: ComponentGroupUncheckedCreateNestedManyWithoutOrganizationInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrganizationInput
    subscribers?: SubscriberUncheckedCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput
    statusPageConfig?: StatusPageConfigUncheckedCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutNotificationChannelsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutNotificationChannelsInput, OrganizationUncheckedCreateWithoutNotificationChannelsInput>
  }

  export type OrganizationUpsertWithoutNotificationChannelsInput = {
    update: XOR<OrganizationUpdateWithoutNotificationChannelsInput, OrganizationUncheckedUpdateWithoutNotificationChannelsInput>
    create: XOR<OrganizationCreateWithoutNotificationChannelsInput, OrganizationUncheckedCreateWithoutNotificationChannelsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutNotificationChannelsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutNotificationChannelsInput, OrganizationUncheckedUpdateWithoutNotificationChannelsInput>
  }

  export type OrganizationUpdateWithoutNotificationChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    monitors?: MonitorUpdateManyWithoutOrganizationNestedInput
    components?: ComponentUpdateManyWithoutOrganizationNestedInput
    componentGroups?: ComponentGroupUpdateManyWithoutOrganizationNestedInput
    incidents?: IncidentUpdateManyWithoutOrganizationNestedInput
    subscribers?: SubscriberUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput
    statusPageConfig?: StatusPageConfigUpdateOneWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutNotificationChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    monitors?: MonitorUncheckedUpdateManyWithoutOrganizationNestedInput
    components?: ComponentUncheckedUpdateManyWithoutOrganizationNestedInput
    componentGroups?: ComponentGroupUncheckedUpdateManyWithoutOrganizationNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrganizationNestedInput
    subscribers?: SubscriberUncheckedUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput
    statusPageConfig?: StatusPageConfigUncheckedUpdateOneWithoutOrganizationNestedInput
  }

  export type OrganizationCreateWithoutApiKeysInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MemberCreateNestedManyWithoutOrganizationInput
    monitors?: MonitorCreateNestedManyWithoutOrganizationInput
    components?: ComponentCreateNestedManyWithoutOrganizationInput
    componentGroups?: ComponentGroupCreateNestedManyWithoutOrganizationInput
    incidents?: IncidentCreateNestedManyWithoutOrganizationInput
    subscribers?: SubscriberCreateNestedManyWithoutOrganizationInput
    notificationChannels?: NotificationChannelCreateNestedManyWithoutOrganizationInput
    statusPageConfig?: StatusPageConfigCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutApiKeysInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    monitors?: MonitorUncheckedCreateNestedManyWithoutOrganizationInput
    components?: ComponentUncheckedCreateNestedManyWithoutOrganizationInput
    componentGroups?: ComponentGroupUncheckedCreateNestedManyWithoutOrganizationInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrganizationInput
    subscribers?: SubscriberUncheckedCreateNestedManyWithoutOrganizationInput
    notificationChannels?: NotificationChannelUncheckedCreateNestedManyWithoutOrganizationInput
    statusPageConfig?: StatusPageConfigUncheckedCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutApiKeysInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutApiKeysInput, OrganizationUncheckedCreateWithoutApiKeysInput>
  }

  export type OrganizationUpsertWithoutApiKeysInput = {
    update: XOR<OrganizationUpdateWithoutApiKeysInput, OrganizationUncheckedUpdateWithoutApiKeysInput>
    create: XOR<OrganizationCreateWithoutApiKeysInput, OrganizationUncheckedCreateWithoutApiKeysInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutApiKeysInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutApiKeysInput, OrganizationUncheckedUpdateWithoutApiKeysInput>
  }

  export type OrganizationUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    monitors?: MonitorUpdateManyWithoutOrganizationNestedInput
    components?: ComponentUpdateManyWithoutOrganizationNestedInput
    componentGroups?: ComponentGroupUpdateManyWithoutOrganizationNestedInput
    incidents?: IncidentUpdateManyWithoutOrganizationNestedInput
    subscribers?: SubscriberUpdateManyWithoutOrganizationNestedInput
    notificationChannels?: NotificationChannelUpdateManyWithoutOrganizationNestedInput
    statusPageConfig?: StatusPageConfigUpdateOneWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    monitors?: MonitorUncheckedUpdateManyWithoutOrganizationNestedInput
    components?: ComponentUncheckedUpdateManyWithoutOrganizationNestedInput
    componentGroups?: ComponentGroupUncheckedUpdateManyWithoutOrganizationNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrganizationNestedInput
    subscribers?: SubscriberUncheckedUpdateManyWithoutOrganizationNestedInput
    notificationChannels?: NotificationChannelUncheckedUpdateManyWithoutOrganizationNestedInput
    statusPageConfig?: StatusPageConfigUncheckedUpdateOneWithoutOrganizationNestedInput
  }

  export type OrganizationCreateWithoutStatusPageConfigInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MemberCreateNestedManyWithoutOrganizationInput
    monitors?: MonitorCreateNestedManyWithoutOrganizationInput
    components?: ComponentCreateNestedManyWithoutOrganizationInput
    componentGroups?: ComponentGroupCreateNestedManyWithoutOrganizationInput
    incidents?: IncidentCreateNestedManyWithoutOrganizationInput
    subscribers?: SubscriberCreateNestedManyWithoutOrganizationInput
    notificationChannels?: NotificationChannelCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutStatusPageConfigInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    monitors?: MonitorUncheckedCreateNestedManyWithoutOrganizationInput
    components?: ComponentUncheckedCreateNestedManyWithoutOrganizationInput
    componentGroups?: ComponentGroupUncheckedCreateNestedManyWithoutOrganizationInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutOrganizationInput
    subscribers?: SubscriberUncheckedCreateNestedManyWithoutOrganizationInput
    notificationChannels?: NotificationChannelUncheckedCreateNestedManyWithoutOrganizationInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutStatusPageConfigInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutStatusPageConfigInput, OrganizationUncheckedCreateWithoutStatusPageConfigInput>
  }

  export type OrganizationUpsertWithoutStatusPageConfigInput = {
    update: XOR<OrganizationUpdateWithoutStatusPageConfigInput, OrganizationUncheckedUpdateWithoutStatusPageConfigInput>
    create: XOR<OrganizationCreateWithoutStatusPageConfigInput, OrganizationUncheckedCreateWithoutStatusPageConfigInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutStatusPageConfigInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutStatusPageConfigInput, OrganizationUncheckedUpdateWithoutStatusPageConfigInput>
  }

  export type OrganizationUpdateWithoutStatusPageConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    monitors?: MonitorUpdateManyWithoutOrganizationNestedInput
    components?: ComponentUpdateManyWithoutOrganizationNestedInput
    componentGroups?: ComponentGroupUpdateManyWithoutOrganizationNestedInput
    incidents?: IncidentUpdateManyWithoutOrganizationNestedInput
    subscribers?: SubscriberUpdateManyWithoutOrganizationNestedInput
    notificationChannels?: NotificationChannelUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutStatusPageConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    monitors?: MonitorUncheckedUpdateManyWithoutOrganizationNestedInput
    components?: ComponentUncheckedUpdateManyWithoutOrganizationNestedInput
    componentGroups?: ComponentGroupUncheckedUpdateManyWithoutOrganizationNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutOrganizationNestedInput
    subscribers?: SubscriberUncheckedUpdateManyWithoutOrganizationNestedInput
    notificationChannels?: NotificationChannelUncheckedUpdateManyWithoutOrganizationNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type MemberCreateManyOrganizationInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.MemberRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MonitorCreateManyOrganizationInput = {
    id?: string
    name: string
    type: $Enums.MonitorType
    url?: string | null
    target?: string | null
    method?: $Enums.HttpMethod
    interval?: number
    timeout?: number
    status?: $Enums.MonitorStatus
    currentStatus?: string
    enabled?: boolean
    componentId?: string | null
    headers?: NullableJsonNullValueInput | InputJsonValue
    body?: string | null
    expectedStatus?: number | null
    keyword?: string | null
    keywordType?: $Enums.KeywordType | null
    heartbeatToken?: string | null
    heartbeatGrace?: number | null
    sslExpiryThreshold?: number | null
    alertAfter?: number
    recoveryAfter?: number
    lastCheckedAt?: Date | string | null
    uptimeDay?: number | null
    uptimeWeek?: number | null
    uptimeMonth?: number | null
    avgResponseTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComponentCreateManyOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ComponentStatus
    order?: number
    groupId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComponentGroupCreateManyOrganizationInput = {
    id?: string
    name: string
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentCreateManyOrganizationInput = {
    id?: string
    title: string
    status?: $Enums.IncidentStatus
    severity?: $Enums.IncidentSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type SubscriberCreateManyOrganizationInput = {
    id?: string
    type?: $Enums.SubscriberType
    email?: string | null
    webhookUrl?: string | null
    confirmed?: boolean
    token?: string
    createdAt?: Date | string
  }

  export type NotificationChannelCreateManyOrganizationInput = {
    id?: string
    name: string
    type: $Enums.NotificationChannelType
    config: JsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyCreateManyOrganizationInput = {
    id?: string
    name: string
    key: string
    expiresAt?: Date | string | null
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MemberUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitorUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMonitorTypeFieldUpdateOperationsInput | $Enums.MonitorType
    url?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod
    interval?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    status?: EnumMonitorStatusFieldUpdateOperationsInput | $Enums.MonitorStatus
    currentStatus?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    headers?: NullableJsonNullValueInput | InputJsonValue
    body?: NullableStringFieldUpdateOperationsInput | string | null
    expectedStatus?: NullableIntFieldUpdateOperationsInput | number | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    keywordType?: NullableEnumKeywordTypeFieldUpdateOperationsInput | $Enums.KeywordType | null
    heartbeatToken?: NullableStringFieldUpdateOperationsInput | string | null
    heartbeatGrace?: NullableIntFieldUpdateOperationsInput | number | null
    sslExpiryThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    alertAfter?: IntFieldUpdateOperationsInput | number
    recoveryAfter?: IntFieldUpdateOperationsInput | number
    lastCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uptimeDay?: NullableFloatFieldUpdateOperationsInput | number | null
    uptimeWeek?: NullableFloatFieldUpdateOperationsInput | number | null
    uptimeMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    avgResponseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    component?: ComponentUpdateOneWithoutMonitorsNestedInput
    checks?: MonitorCheckUpdateManyWithoutMonitorNestedInput
    alerts?: MonitorAlertUpdateManyWithoutMonitorNestedInput
  }

  export type MonitorUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMonitorTypeFieldUpdateOperationsInput | $Enums.MonitorType
    url?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod
    interval?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    status?: EnumMonitorStatusFieldUpdateOperationsInput | $Enums.MonitorStatus
    currentStatus?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    componentId?: NullableStringFieldUpdateOperationsInput | string | null
    headers?: NullableJsonNullValueInput | InputJsonValue
    body?: NullableStringFieldUpdateOperationsInput | string | null
    expectedStatus?: NullableIntFieldUpdateOperationsInput | number | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    keywordType?: NullableEnumKeywordTypeFieldUpdateOperationsInput | $Enums.KeywordType | null
    heartbeatToken?: NullableStringFieldUpdateOperationsInput | string | null
    heartbeatGrace?: NullableIntFieldUpdateOperationsInput | number | null
    sslExpiryThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    alertAfter?: IntFieldUpdateOperationsInput | number
    recoveryAfter?: IntFieldUpdateOperationsInput | number
    lastCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uptimeDay?: NullableFloatFieldUpdateOperationsInput | number | null
    uptimeWeek?: NullableFloatFieldUpdateOperationsInput | number | null
    uptimeMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    avgResponseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checks?: MonitorCheckUncheckedUpdateManyWithoutMonitorNestedInput
    alerts?: MonitorAlertUncheckedUpdateManyWithoutMonitorNestedInput
  }

  export type MonitorUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMonitorTypeFieldUpdateOperationsInput | $Enums.MonitorType
    url?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod
    interval?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    status?: EnumMonitorStatusFieldUpdateOperationsInput | $Enums.MonitorStatus
    currentStatus?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    componentId?: NullableStringFieldUpdateOperationsInput | string | null
    headers?: NullableJsonNullValueInput | InputJsonValue
    body?: NullableStringFieldUpdateOperationsInput | string | null
    expectedStatus?: NullableIntFieldUpdateOperationsInput | number | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    keywordType?: NullableEnumKeywordTypeFieldUpdateOperationsInput | $Enums.KeywordType | null
    heartbeatToken?: NullableStringFieldUpdateOperationsInput | string | null
    heartbeatGrace?: NullableIntFieldUpdateOperationsInput | number | null
    sslExpiryThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    alertAfter?: IntFieldUpdateOperationsInput | number
    recoveryAfter?: IntFieldUpdateOperationsInput | number
    lastCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uptimeDay?: NullableFloatFieldUpdateOperationsInput | number | null
    uptimeWeek?: NullableFloatFieldUpdateOperationsInput | number | null
    uptimeMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    avgResponseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComponentUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComponentStatusFieldUpdateOperationsInput | $Enums.ComponentStatus
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: ComponentGroupUpdateOneWithoutComponentsNestedInput
    monitors?: MonitorUpdateManyWithoutComponentNestedInput
    incidents?: IncidentComponentUpdateManyWithoutComponentNestedInput
  }

  export type ComponentUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComponentStatusFieldUpdateOperationsInput | $Enums.ComponentStatus
    order?: IntFieldUpdateOperationsInput | number
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monitors?: MonitorUncheckedUpdateManyWithoutComponentNestedInput
    incidents?: IncidentComponentUncheckedUpdateManyWithoutComponentNestedInput
  }

  export type ComponentUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComponentStatusFieldUpdateOperationsInput | $Enums.ComponentStatus
    order?: IntFieldUpdateOperationsInput | number
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComponentGroupUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    components?: ComponentUpdateManyWithoutGroupNestedInput
  }

  export type ComponentGroupUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    components?: ComponentUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type ComponentGroupUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updates?: IncidentUpdateUpdateManyWithoutIncidentNestedInput
    components?: IncidentComponentUpdateManyWithoutIncidentNestedInput
  }

  export type IncidentUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updates?: IncidentUpdateUncheckedUpdateManyWithoutIncidentNestedInput
    components?: IncidentComponentUncheckedUpdateManyWithoutIncidentNestedInput
  }

  export type IncidentUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriberUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriberTypeFieldUpdateOperationsInput | $Enums.SubscriberType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUpdateManyWithoutSubscriberNestedInput
  }

  export type SubscriberUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriberTypeFieldUpdateOperationsInput | $Enums.SubscriberType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutSubscriberNestedInput
  }

  export type SubscriberUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriberTypeFieldUpdateOperationsInput | $Enums.SubscriberType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationChannelUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationChannelTypeFieldUpdateOperationsInput | $Enums.NotificationChannelType
    config?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationChannelUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationChannelTypeFieldUpdateOperationsInput | $Enums.NotificationChannelType
    config?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationChannelUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationChannelTypeFieldUpdateOperationsInput | $Enums.NotificationChannelType
    config?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitorCheckCreateManyMonitorInput = {
    id?: string
    status: $Enums.MonitorStatus
    responseTime?: number | null
    statusCode?: number | null
    message?: string | null
    error?: string | null
    region?: string | null
    checkedAt?: Date | string
  }

  export type MonitorAlertCreateManyMonitorInput = {
    id?: string
    type: string
    message: string
    createdAt?: Date | string
  }

  export type MonitorCheckUpdateWithoutMonitorInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumMonitorStatusFieldUpdateOperationsInput | $Enums.MonitorStatus
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitorCheckUncheckedUpdateWithoutMonitorInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumMonitorStatusFieldUpdateOperationsInput | $Enums.MonitorStatus
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitorCheckUncheckedUpdateManyWithoutMonitorInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumMonitorStatusFieldUpdateOperationsInput | $Enums.MonitorStatus
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitorAlertUpdateWithoutMonitorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitorAlertUncheckedUpdateWithoutMonitorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitorAlertUncheckedUpdateManyWithoutMonitorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComponentCreateManyGroupInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ComponentStatus
    order?: number
    orgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComponentUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComponentStatusFieldUpdateOperationsInput | $Enums.ComponentStatus
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutComponentsNestedInput
    monitors?: MonitorUpdateManyWithoutComponentNestedInput
    incidents?: IncidentComponentUpdateManyWithoutComponentNestedInput
  }

  export type ComponentUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComponentStatusFieldUpdateOperationsInput | $Enums.ComponentStatus
    order?: IntFieldUpdateOperationsInput | number
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monitors?: MonitorUncheckedUpdateManyWithoutComponentNestedInput
    incidents?: IncidentComponentUncheckedUpdateManyWithoutComponentNestedInput
  }

  export type ComponentUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumComponentStatusFieldUpdateOperationsInput | $Enums.ComponentStatus
    order?: IntFieldUpdateOperationsInput | number
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitorCreateManyComponentInput = {
    id?: string
    name: string
    type: $Enums.MonitorType
    url?: string | null
    target?: string | null
    method?: $Enums.HttpMethod
    interval?: number
    timeout?: number
    status?: $Enums.MonitorStatus
    currentStatus?: string
    enabled?: boolean
    orgId: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    body?: string | null
    expectedStatus?: number | null
    keyword?: string | null
    keywordType?: $Enums.KeywordType | null
    heartbeatToken?: string | null
    heartbeatGrace?: number | null
    sslExpiryThreshold?: number | null
    alertAfter?: number
    recoveryAfter?: number
    lastCheckedAt?: Date | string | null
    uptimeDay?: number | null
    uptimeWeek?: number | null
    uptimeMonth?: number | null
    avgResponseTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentComponentCreateManyComponentInput = {
    id?: string
    incidentId: string
    status: $Enums.ComponentStatus
  }

  export type MonitorUpdateWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMonitorTypeFieldUpdateOperationsInput | $Enums.MonitorType
    url?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod
    interval?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    status?: EnumMonitorStatusFieldUpdateOperationsInput | $Enums.MonitorStatus
    currentStatus?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    headers?: NullableJsonNullValueInput | InputJsonValue
    body?: NullableStringFieldUpdateOperationsInput | string | null
    expectedStatus?: NullableIntFieldUpdateOperationsInput | number | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    keywordType?: NullableEnumKeywordTypeFieldUpdateOperationsInput | $Enums.KeywordType | null
    heartbeatToken?: NullableStringFieldUpdateOperationsInput | string | null
    heartbeatGrace?: NullableIntFieldUpdateOperationsInput | number | null
    sslExpiryThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    alertAfter?: IntFieldUpdateOperationsInput | number
    recoveryAfter?: IntFieldUpdateOperationsInput | number
    lastCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uptimeDay?: NullableFloatFieldUpdateOperationsInput | number | null
    uptimeWeek?: NullableFloatFieldUpdateOperationsInput | number | null
    uptimeMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    avgResponseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutMonitorsNestedInput
    checks?: MonitorCheckUpdateManyWithoutMonitorNestedInput
    alerts?: MonitorAlertUpdateManyWithoutMonitorNestedInput
  }

  export type MonitorUncheckedUpdateWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMonitorTypeFieldUpdateOperationsInput | $Enums.MonitorType
    url?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod
    interval?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    status?: EnumMonitorStatusFieldUpdateOperationsInput | $Enums.MonitorStatus
    currentStatus?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    orgId?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    body?: NullableStringFieldUpdateOperationsInput | string | null
    expectedStatus?: NullableIntFieldUpdateOperationsInput | number | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    keywordType?: NullableEnumKeywordTypeFieldUpdateOperationsInput | $Enums.KeywordType | null
    heartbeatToken?: NullableStringFieldUpdateOperationsInput | string | null
    heartbeatGrace?: NullableIntFieldUpdateOperationsInput | number | null
    sslExpiryThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    alertAfter?: IntFieldUpdateOperationsInput | number
    recoveryAfter?: IntFieldUpdateOperationsInput | number
    lastCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uptimeDay?: NullableFloatFieldUpdateOperationsInput | number | null
    uptimeWeek?: NullableFloatFieldUpdateOperationsInput | number | null
    uptimeMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    avgResponseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checks?: MonitorCheckUncheckedUpdateManyWithoutMonitorNestedInput
    alerts?: MonitorAlertUncheckedUpdateManyWithoutMonitorNestedInput
  }

  export type MonitorUncheckedUpdateManyWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMonitorTypeFieldUpdateOperationsInput | $Enums.MonitorType
    url?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod
    interval?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    status?: EnumMonitorStatusFieldUpdateOperationsInput | $Enums.MonitorStatus
    currentStatus?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    orgId?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    body?: NullableStringFieldUpdateOperationsInput | string | null
    expectedStatus?: NullableIntFieldUpdateOperationsInput | number | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    keywordType?: NullableEnumKeywordTypeFieldUpdateOperationsInput | $Enums.KeywordType | null
    heartbeatToken?: NullableStringFieldUpdateOperationsInput | string | null
    heartbeatGrace?: NullableIntFieldUpdateOperationsInput | number | null
    sslExpiryThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    alertAfter?: IntFieldUpdateOperationsInput | number
    recoveryAfter?: IntFieldUpdateOperationsInput | number
    lastCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uptimeDay?: NullableFloatFieldUpdateOperationsInput | number | null
    uptimeWeek?: NullableFloatFieldUpdateOperationsInput | number | null
    uptimeMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    avgResponseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentComponentUpdateWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumComponentStatusFieldUpdateOperationsInput | $Enums.ComponentStatus
    incident?: IncidentUpdateOneRequiredWithoutComponentsNestedInput
  }

  export type IncidentComponentUncheckedUpdateWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    status?: EnumComponentStatusFieldUpdateOperationsInput | $Enums.ComponentStatus
  }

  export type IncidentComponentUncheckedUpdateManyWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    status?: EnumComponentStatusFieldUpdateOperationsInput | $Enums.ComponentStatus
  }

  export type IncidentUpdateCreateManyIncidentInput = {
    id?: string
    status: $Enums.IncidentStatus
    message: string
    createdAt?: Date | string
  }

  export type IncidentComponentCreateManyIncidentInput = {
    id?: string
    componentId: string
    status: $Enums.ComponentStatus
  }

  export type IncidentUpdateUpdateWithoutIncidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUpdateUncheckedUpdateWithoutIncidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUpdateUncheckedUpdateManyWithoutIncidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentComponentUpdateWithoutIncidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumComponentStatusFieldUpdateOperationsInput | $Enums.ComponentStatus
    component?: ComponentUpdateOneRequiredWithoutIncidentsNestedInput
  }

  export type IncidentComponentUncheckedUpdateWithoutIncidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    status?: EnumComponentStatusFieldUpdateOperationsInput | $Enums.ComponentStatus
  }

  export type IncidentComponentUncheckedUpdateManyWithoutIncidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    status?: EnumComponentStatusFieldUpdateOperationsInput | $Enums.ComponentStatus
  }

  export type AlertCreateManySubscriberInput = {
    id?: string
    incidentId?: string | null
    subject: string
    body: string
    status?: $Enums.AlertStatus
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AlertUpdateWithoutSubscriberInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUncheckedUpdateWithoutSubscriberInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUncheckedUpdateManyWithoutSubscriberInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use OrganizationCountOutputTypeDefaultArgs instead
     */
    export type OrganizationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MonitorCountOutputTypeDefaultArgs instead
     */
    export type MonitorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MonitorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComponentGroupCountOutputTypeDefaultArgs instead
     */
    export type ComponentGroupCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComponentGroupCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComponentCountOutputTypeDefaultArgs instead
     */
    export type ComponentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComponentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IncidentCountOutputTypeDefaultArgs instead
     */
    export type IncidentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IncidentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriberCountOutputTypeDefaultArgs instead
     */
    export type SubscriberCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriberCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationDefaultArgs instead
     */
    export type OrganizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MemberDefaultArgs instead
     */
    export type MemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MonitorDefaultArgs instead
     */
    export type MonitorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MonitorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MonitorCheckDefaultArgs instead
     */
    export type MonitorCheckArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MonitorCheckDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MonitorAlertDefaultArgs instead
     */
    export type MonitorAlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MonitorAlertDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComponentGroupDefaultArgs instead
     */
    export type ComponentGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComponentGroupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComponentDefaultArgs instead
     */
    export type ComponentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComponentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IncidentDefaultArgs instead
     */
    export type IncidentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IncidentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IncidentComponentDefaultArgs instead
     */
    export type IncidentComponentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IncidentComponentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriberDefaultArgs instead
     */
    export type SubscriberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlertDefaultArgs instead
     */
    export type AlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlertDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationChannelDefaultArgs instead
     */
    export type NotificationChannelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationChannelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApiKeyDefaultArgs instead
     */
    export type ApiKeyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApiKeyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StatusPageConfigDefaultArgs instead
     */
    export type StatusPageConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StatusPageConfigDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}